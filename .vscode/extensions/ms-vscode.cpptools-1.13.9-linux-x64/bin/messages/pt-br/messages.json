[
  "erro desconhecido",
  "última linha do arquivo termina sem uma nova linha",
  "última linha do arquivo termina sem uma barra invertida",
  "#include arquivo %sq inclui a si mesmo",
  "memória insuficiente",
  null,
  "comentário anexado ao fim do arquivo",
  "token não reconhecido",
  "faltando aspas de fechamento",
  "comentários aninhados não são permitidos",
  "'#' não esperado aqui",
  "diretivas de pré-processamento não reconhecidas",
  "análise reinicia aqui, depois do erro de sintaxe anterior",
  "esperado nome de arquivo",
  "texto extra depois do esperado fim da diretiva de pré-processamento",
  null,
  null,
  "esperado um ']'",
  "esperado um ')'",
  "texto extra depois do esperado fim de número",
  "o identificador %sq não está definido",
  "os qualificadores de tipo não possuem significado nesta declaração",
  "número hexadecimal inválido",
  "constante inteira é muito grande",
  "dígito octal inválido",
  "cadeia de caracteres entre aspas devem possuir pelo menos um caractere",
  "muitos caracteres em uma constante de caractere",
  "valor do caractere está fora do intervalo",
  "a expressão deve possuir um valor constante",
  "esperada uma expressão",
  "constante flutuante está fora do intervalo",
  "a expressão deve possuir um tipo integral",
  "a expressão deve possuir um tipo aritmético",
  "esperado um número de linha",
  "número de linha inválido",
  "diretiva #error: %s",
  "o #if para essa diretiva está faltando",
  "o #endif para essa diretiva está faltando",
  "diretiva não é permitida -- um #else já apareceu",
  "divisão por zero",
  "esperado um identificador",
  "expressão deve possuir tipo aritmético ou ponteiro",
  "os tipos de operandos são incompatíveis (%t1 e %t2)",
  null,
  "expressões devem possuir tipo ponteiro",
  "#undef pode não ser utilizada nesse nome pré-definido",
  "%no é pré-definida; tentativa de redefinição ignorada",
  "redefinição incompatível da macro %nod",
  null,
  "nome de parâmetro de macro duplicado",
  "'##' pode não ser o primeiro na definição da macro",
  "'##' pode não ser o último na definição da macro",
  "esperado um nome de parâmetro de macro",
  "esperado um ':'",
  "muito poucos argumentos na invocação de %n",
  "muitos argumentos na invocação de %n",
  "o operando de sizeof pode não ser uma função",
  "este operador não é permitido em uma expressão constante",
  "esse operador não é permitido em uma expressão de pré-processamento",
  "chamada de função não é permitido em uma expressão constante",
  "esse operador não é permitido em uma expressão constante integral",
  "o resultado da operação de inteiros está fora do intervalo",
  "contagem de deslocamentos é negativa",
  "contagem de deslocamentos é muito grande",
  "a declaração não declara nada",
  "esperado um ';'",
  "o valor da enumeração está fora do intervalo de 'int'",
  "esperado um '}'",
  "a conversão de inteiro resultou em uma mudança de sinal",
  "a conversão de inteiro resultou em um truncamento",
  "tipos incompletos não são permitidos",
  "o operando sizeof pode não ser um campo de bit",
  null,
  null,
  null,
  "o operando de '*' precisa ser um ponteiro, mas tem o tipo %t",
  "o argumento da macro está vazio",
  "essa declaração não possui classe de armazenamento ou especificador de tipo",
  "uma declaração de parâmetro pode não possuir um inicializador",
  "esperado um especificador de tipo",
  "uma classe de armazenamento pode não ter sido especificada aqui",
  "mais de uma classe de armazenamento pode não ter sido especificada",
  "classe de armazenamento não está em primeiro",
  "qualificador de tipo especificado mais de uma vez",
  "combinação de qualificadores de tipo inválida",
  "classe de armazenamento inválida para um parâmetro",
  "classe de armazenamento inválida para uma função",
  "um especificador de tipo pode não ser utilizado aqui",
  "matriz de funções não é permitida aqui",
  "matriz de void não é permitida",
  "função retornando função não é permitido",
  "função retornando matriz não é permitido",
  "lista de identificadores de parâmetros pode ser utilizada somente em uma definição de função",
  "o tipo da função pode não vir de um typedef",
  "o tamanho de uma matriz deve ser maior do que zero",
  "matriz é muito grande",
  "uma unidade de tradução deve conter pelo menos uma declaração",
  "uma função pode não retornar um valor desse tipo",
  "uma matriz pode não conter elementos desse tipo",
  "uma declaração aqui deve declarar um parâmetro",
  "nome de parâmetro duplicado",
  "%sq já foi declarado no escopo atual",
  "a declaração de encaminhamento do tipo de enumeração não é padrão",
  "classe é muito grande",
  "struct ou union é muito grande",
  "tamanho inválido para campo de bit",
  "tipo inválido para um campo de bit",
  "um campo de bit de tamanho zero não deve ser nomeado",
  "campo de bit com sinal de tamanho 1",
  "expressões que precedem parênteses de chamada aparente devem possuir tipo de função (ponteiro-para-) ",
  "esperado ou uma definição ou um nome de rótulo",
  "instrução é inalcançável",
  "esperado 'while'",
  null,
  "%n foi referenciado mas não definido",
  "uma instrução continue pode ser utilizada apenas dentro de um laço",
  "uma instrução break pode ser utilizada apenas dentro de um laço ou switch",
  "não void %n deve retornar um valor",
  "uma função void pode não retornar um valor",
  "conversão para tipo %t não é permitida",
  "tipo do valor de retorno não corresponde ao tipo da função",
  "um rótulo case pode ser utilizado apenas dentro de um switch",
  "um rótulo default pode ser utilizado apenas dentro de um switch",
  null,
  "o rótulo label já apareceu nesse switch",
  "esperado um '('",
  "expressão deve ser um lvalue",
  "esperado uma instrução",
  "laço é inalcançável",
  "uma função de escopo de bloco pode possuir apenas a classe de armazenamento extern",
  "esperado um '{'",
  "a expressão precisa ter um tipo de ponteiro-para-classe, mas tem o tipo %t",
  "a expressão precisa ter o tipo de ponteiro-para-struct-ou-união, mas tem o tipo %t",
  "esperado um nome de membro",
  "esperado um nome de campo",
  "%n não possui membro %sq",
  "%n não possui campo %sq",
  "a expressão deve ser um lvalue modificável",
  "não é permitido capturar o endereço de uma variável register",
  "não é permitido capturar o endereço de um campo de bit",
  "muitos argumentos na chamada da função",
  "parâmetros prototipados sem nome não são permitidos quando o corpo está presente",
  "a expressão precisa ter o tipo de ponteiro-para-objeto, mas tem o tipo %t",
  "programa muito grande ou complicado para compilar",
  "um valor de tipo %t1 não pode ser utilizado para inicializar uma entidade do tipo %t2",
  "%n pode não ser inicializado",
  "muitos valores de inicializadores",
  "declaração é incompatível com %nfd",
  "%n já foi inicializado",
  "uma declaração de escopo global pode não possuir essa classe de armazenamento",
  "um nome de tipo pode não ser declarado novamente como um parâmetro",
  "um nome de typedef pode não ser declarado novamente como um parâmetro",
  "conversão de inteiro não zero para ponteiro",
  "a expressão precisa ter tipo de classe, mas tem o tipo %t",
  "a expressão precisa ter tipo struct ou de união, mas tem o tipo %t",
  "operador de atribuição antigo",
  "inicializador antigo",
  "a expressão deve ser uma expressão constante integral",
  "a expressão deve um lvalue ou uma designadora de funções",
  "declaração é incompatível com o %nod anterior",
  "nome externo entrou em conflito com o nome externo de %nd",
  "#pragma não reconhecido",
  null,
  "não pôde abrir arquivo temporário %sq: %s2",
  "nome de diretório para arquivos temporários é muito longo (%sq)",
  "muito poucos argumentos na chamada da função",
  "constante flutuante inválida",
  "argumento do tipo %t1 é incompatível com parâmetro do tipo %t2",
  "uma tipo de função não é permitido aqui",
  "esperado uma declaração",
  "ponteiro aponta para fora do objeto considerado",
  "conversão de tipo inválida",
  "conflito de vínculo interno/externo com a declaração anterior %p",
  "valor de ponto flutuante não cabe no tipo integral requerido",
  "a expressão não possui efeito",
  "subscrito fora do intervalo",
  null,
  "%n foi declarado mas nunca referenciado",
  "'&' não possui efeito quando aplicado a uma matriz",
  "o operador da direta de '%%' é zero",
  "argumento é incompatível com parâmetro formal",
  "argumento é incompatível com conversão de formato de cadeia de caracteres correspondente",
  "não pôde abrir o arquivo fonte %sq (nenhum diretório na lista de busca)",
  "tipo de conversão deve ser integral",
  "tipo de conversão deve ser aritmético ou ponteiro",
  "inicialização dinâmica em código inalcançável",
  "comparação sem sentido de inteiros sem sinal com zero",
  "utilização de '=' onde '==' pode ter sido a intenção",
  "tipo enumerado se misturou com outro tipo",
  "erro ao gravar arquivo %s",
  "arquivo de linguagem intermediária inválido",
  "qualificador de tipo não tem sentido no tipo de conversão",
  "sequência de caractere de escape não reconhecida",
  "utilizado zero para identificador de pré-processamento não definido %sq",
  "esperando uma cadeia de caracteres asm",
  "uma função asm deve ser prototipada",
  "uma função asm pode não possuir uma elipse",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "erro ao excluir arquivo %sq: %s2",
  "valor integral não cabe no tipo de ponto-flutuante requerido",
  "valor de ponto-flutuante não cabe no tipo de ponto-flutuante requerido",
  "resultado da operação de ponto-flutuante está fora do intervalo",
  "função %sq declarada implicitamente",
  "a cadeia de caracteres de formato requer mais argumentos",
  "a cadeia de caracteres de formato termina antes desse argumento",
  "conversão de cadeia de caracteres de formato invávlida",
  "recursão de macro",
  "vírgula ao final não é padrão",
  "campo de bit não pode conter todos os valores do tipo enumerado",
  "tipo não padrão para um campo de bit",
  "a declaração não é visível de fora da função",
  "antigo typedef de 'void' ignorado",
  "operador da esquerda não é um struct ou union contendo esse campo",
  "ponteiro não aponta para struct ou union contendo esse campo",
  "variável %sq foi declarada com um tipo nunca-completado",
  "expressão de controle é constante",
  "expressão de seletor é constante",
  "especificador inválido em um parâmetro",
  "especificador inválido fora de uma declaração de classe",
  "especificador duplicado em declaração",
  "não é permitido a uma union ter uma classe base",
  "especificadores de controle de múltiplos acessos não são permitidos",
  "faltando definição de classe ou struct",
  "o nome qualificado não é um membro da classe %t ou de suas classes base",
  "uma referência a um membro não estático deve ser relativa ao objeto específico",
  "um membro de dados não estático pode não ser definido fora da sua classe",
  "%n já foi definido",
  "ponteiro para referência não é permitido",
  "referência para referência não é permitido",
  "referência para void não é permitido",
  "matriz de referências não é permitido",
  "referência %n requer um inicializador",
  "esperado um ','",
  "nome de tipo não é permitido",
  "definição de tipo não é permitido",
  "redeclaração inválida de nome de tipo %nod",
  "const %n requer um inicializador",
  "'this' pode ser utilizado apenas dentro de uma função membro não estática",
  "valor constante não é conhecido",
  "faltando tipo explícito (assumido 'int')",
  "controle de acesso não especificado (%sq por padrão)",
  "não é um nome de classe ou struct",
  "nome de classe base duplicado",
  "classe base inválida",
  "%nd está inacessível",
  "%no está ambíguo",
  "estilo antigo de lista de parâmetros (anacronismo)",
  "declaração pode não aparecer depois de instrução executável em bloco",
  "conversão para classe base inacessível %t não é permitido",
  null,
  null,
  null,
  null,
  "chamada de macro incorretamente terminada",
  null,
  "nome seguido de '::' deve ser uma classe ou o nome de um namespace",
  "declaração de friend inválida",
  "um construtor ou destrutor pode não retornar um valor",
  "declaração inválida de destrutor",
  "declaração de um membro com o mesmo nome que sua classe",
  "qualificador de escopo global ('::' à frente) não é permitido",
  "o escopo global não possui %sq",
  "nome qualificado não é permitido",
  "referência NULL não é permitido",
  "inicialização com '{...}' não é permitida para objetos do tipo %t",
  "classe base %t está ambígua",
  "classe derivada %t1 contém mais de uma instância da classe %t2",
  "não é possível converter ponteiro para classe base %t2 para apontar para classe derivada %t1 -- classe base é virtual",
  "nenhuma instância do construtor %no corresponde à lista de argumentos",
  "construtor cópia para classe %t está ambíguo",
  "não há construtor padrão para a classe %t",
  "%sq não é um membro de dados não estáticos ou classe base da classe %t",
  "classe base não virtual indireta não é permitido",
  "membro union inválido -- a classe %t tem uma função membro proibida",
  null,
  "uso inválido de matriz de elementos não lvalue",
  "esperado um operador",
  "membro herdado não é permitido",
  "não é possível determinar qual instância de %n é a desejada",
  "um ponteiro para uma função associada pode ser utilizada apenas para chamar a função",
  "o nome do typedef já foi declarado (com o mesmo tipo)",
  "%n já foi definido",
  null,
  "nenhum instância de %n corresponde à lista de argumentos",
  "definição de tipo não é permitida na declaração do tipo de retorno de uma função",
  "argumento padrão não está no final da lista de parâmetros",
  "Nova definição do argumento padrão",
  "mais de uma instância de %n corresponde à lista de argumento:",
  "mais de uma instância do construtor %n corresponde à lista de argumento:",
  "o argumento padrão do tipo %t1 é incompatível com parâmetro do tipo %t2",
  "não é possível sobrecarregar funções que se diferenciam somente pelo tipo de retorno",
  "não há conversão apropriada, que possa ser definida pelo usuário, de %t1 para %t2",
  null,
  "somente funções membro não estáticas podem ser virtuais",
  "o objeto tem qualificadores de tipo que não são compatíveis com a função membro",
  "programa muito grande para compilar (muitas funções virtuais)",
  "o tipo de retorno não é idêntico nem covariante com o tipo de retorno %t da função virtual sobrescrita %no",
  "sobrescrita do %n virtual está ambíguo",
  "especificador puro ('= 0') permitido somente em funções virtuais",
  "especificador puro malformatado (somente '= 0' é permitido)",
  "inicializador de membro de dados não é permitido",
  "objeto do tipo de classe abstrata %t não é permitido:",
  "função retornando classe abstrata %t não é permitido:",
  "declaração de friend duplicada",
  "especificadores embutidos permitidos somente em declarações de funções",
  "'inline' não é permitido",
  "classe de armazenamento inválida para uma função embutida",
  "classe de armazenamento inválida para um membro de classe",
  "membro de classe local %n requer uma definição",
  "%nfd inacessível",
  null,
  "classe %t não possui um construtor cópia para copiar um objeto constante",
  "definição de função membro declarada implicitamente não é permitido",
  "classe %t não possui construtor cópia adequado",
  "especificação de vínculo não é permitida",
  "especificação de vínculo externo desconhecida",
  "especificação de vínculo é incompatível com %nod anterior",
  "mais de uma instância da função sobrecarregada %no possui vínculo 'C'",
  "classe %t possui mais de um construtor padrão",
  "valor copiado para variável temporária, referência para temporária utilizada",
  "'operador%s' deve ser uma função membro",
  "operador não pode ser uma função membro estática",
  "nenhum argumento é permitido em conversão definida pelo usuário",
  "muitos parâmetros para essa função operadora",
  "muito poucos parâmetros para essa função operadora",
  "operador não membro requer um parâmetro com o tipo da classe",
  "argumento padrão não é permitido",
  "mais de uma conversão definida pelo usuário de %t1 para %t2 se aplica:",
  "nenhum operador %sq corresponde a esses operandos",
  "mais de um operador %sq corresponde a esses operandos:",
  "primeiro parâmetro da função de alocação deve ser do tipo 'size_t'",
  "função de alocação requer tipo de retorno 'void *'",
  "função de desalocação requer tipo de retorno 'void'",
  "primeiro parâmetro da função de desalocação deve ser do tipo void *'",
  null,
  "tipo deve ser um tipo de objeto",
  "classe base %t já foi inicializada",
  "nome da classe base é exigido -- %t assumido (anacronismo)",
  "%n já foi inicializado",
  "está faltando nome de membro ou classe base",
  "atribuição para 'this' (anacronismo)",
  "palavra-chave 'overload' utilizada (anacronismo)",
  "union anônima inválida -- membro não público não é permitido",
  "union anônima inválida -- função membro não é permitida",
  "union anônima em escopo global ou de namespace deve ser declarada estática",
  "%nf não fornece nenhum inicializador para:",
  "construtor gerado implicitamente para classe %t não pode ser inicializado:",
  "%n não define nenhum construtor para inicializar o seguinte:",
  "%n possui uma constante ou membro de referência não inicializado",
  "%n possui um campo de constante não inicializado",
  "a classe %t não possui nenhum operador de atribuição para copiar um objeto constante",
  "a classe %t não possui nenhum operador de atribuição adequado",
  "operador de atribuição ambíguo para a classe %t",
  null,
  "declaração requer um nome de typedef",
  null,
  "'virtual' não é permitido",
  "'static' não é permitido",
  "conversão de função associada para ponteiro de função normal (anacronismo)",
  "expressão deve possuir tipo ponteiro para membro",
  "extra ';' ignorado",
  "inicializador em-classe para membro não estático não é padrão",
  null,
  "nenhuma instância do %no sobrecarregado corresponde à lista de argumentos",
  null,
  "nenhuma instância de %n corresponde ao tipo exigido",
  "expressão de exclusão de tamanho de matriz utilizada (anacronismo)",
  null,
  "uma conversão para a classe abstrata %t não é permitido:",
  "a função 'main' pode não ser chamada ou ter seu endereço capturado",
  "um inicializador new pode não ser especificado para uma matriz",
  "a função membro %no pode não ser declarada novamente fora da sua classe",
  "o ponteiro para o tipo de classe incompleta %t não é permitido",
  "referência para variável local de função não é permitido",
  "função com um único argumento utilizada como sufixo %sq (anacronismo)",
  null,
  "operador de atribuição gerado implicitamente não pode ser copiado:",
  "conversão para matriz de tipo não é padrão (tratado como conversão para %t)",
  "%n possui um operador new%s() mas não possui um operador delete%s() padrão",
  "%n possui um operador delete%s() padrão, mas nenhum operador new%s()",
  "destrutor para classe base %nod não é virtual",
  null,
  "redeclaração inválida de membro %npd",
  "função 'main' não pode ser declarada de modo embutido",
  "função membro com o mesmo nome que a sua classe deve ser um construtor",
  "utilização de %n aninhado (anacronismo)",
  "um destrutor pode não ter parâmetros",
  "construtor cópia para classe %t pode não possuir um parâmetro do tipo %t",
  "%n retorna o tipo incompleto %t",
  "%nd protegido não está acessível através de um objeto ou ponteiro %t",
  "um parâmetro não é permitido",
  "uma declaração 'asm' não é permitida aqui",
  "não há função de conversão adequada de %t1 para %t2",
  "exclusão de ponteiro para classe incompleta",
  "não há construtor adequado para converter %t1 para %t2",
  "é possível aplicar mais de um construtor para converter %t1 para %t2:",
  "é possível aplicar mais de uma função de conversão de %t1 para %t2:",
  "é possível aplicar mais de uma função de conversão de %t para um tipo embutido:",
  "constante %n",
  "referência %n",
  "%npTd",
  "operador embutido %sq",
  "%nod, ambíguo por herança",
  "um construtor or destrutor pode não ter seu endereço capturado",
  null,
  "variável temporária utilizada para valor inicial de referência de uma não constante (anacronismo)",
  "nome qualificado não é permitido em declaração de membro",
  "tipo enumerado misturado com outro tipo (anacronismo)",
  "o tamanho de uma matriz em 'new' deve ser não negativo",
  "referência de retorno para variável temporária local",
  null,
  "declaração 'enum' não é permitida",
  "qualificadores fizeram a associação da referência do tipo %t1 para o inicializador do tipo %t2",
  "uma referência do tipo %t1 (não qualificada como constante) não pode ser inicializada com um valor do tipo %t2",
  "um ponteiro para função pode não ser excluído",
  "função de conversão deve ser um função membro não estática",
  "declaração de modelo não é permitida aqui",
  "esperado um '<'",
  "esperado um '>'",
  "está faltando uma declaração de parâmetro de modelo",
  "está faltando um lista de argumentos para %nf",
  "muito poucos argumentos para %nf",
  "muitos argumentos para %nf",
  null,
  "%n1 não é utilizado na declaração de tipos de parâmetro de %n2",
  "dois tipos aninhados possuem o mesmo nome: %no1 e %nod2 (compatibilidade com cfront)",
  "global %no1 foi declarado depois do %nod2 aninhado (compatilbilidade com cfront)",
  null,
  "mais de uma instância de %n corresponde ao tipo exigido",
  "o tipo 'long long' não é padrão",
  "omissão de %sq não é padrão",
  "tipo de retorno pode não ser especificado em uma função de conversão",
  "detectado durante:",
  "instanciação de %nt %p",
  "geração implícita de %nt %p",
  "recursão excessiva na instanciação de %n",
  "%sq não é uma função o membro de dados estático",
  "argumento do tipo %t1 é incompatível com parâmetro de modelo do tipo %t2",
  "exigência de uma variável temporária ou conversão na inicialização não é permitida",
  "declaração de %sq esconde parâmetros da função",
  "valor inicial de referência para um não constante deve ser um lvalue",
  "definição implícita de %nt %p",
  "'modelo' não é permitido",
  "%t não é um modelo de classe",
  null,
  "'main' não é um nome válido para uma função template",
  "referência inválida para %n (union/não nunion não correspondida)",
  "um modelo de argumento pode não referenciar um tipo local",
  "rotular algo como %s é incompatível com declaração de %nfd",
  "o escopo global não possui nenhum rótulo nomeado %sq",
  "%n não possui nenhum membro de rótulo nomeado %sq",
  "typedef de função membro (permitido para compatibilidade com cfront)",
  "%n pode ser utilizado somente em declarações de ponteiro para membro",
  null,
  "um argumento de template pode não referenciar uma entidade não externa",
  "nome seguido de '::~' deve ser um nome de classe ou o nome de um tipo",
  null,
  "tipo utilizado como nome de destrutor não corresponde ao tipo %t",
  "%n redeclarado 'inline' depois de ter sido chamado",
  null,
  "classe de armazenamento inválida para uma declaração de modelo",
  "%nd é um tipo inacessível (permitido somente para compatibilidade com cfront)",
  null,
  "declaração explícita de instanciação inválida",
  "%nf não é uma entidade que pode ser instanciada",
  "%n, gerado pelo compilador, não pode ser instanciado explicitamente",
  "%n embutido não pode ser instanciado explicitamente",
  null,
  "%n não pode ser instanciado -- nenhuma definição de modelo foi fornecida",
  "%n não pode ser instanciado -- foi explicitamente especializado",
  null,
  null,
  "nenhuma instância de %n corresponde ao tipo especificado",
  "a declaração de uma lista de parâmetros void com um um typedef não é um padrão",
  "global %n1 utilizado ao invés de %n2 (compatibilidade com cfront)",
  "parâmetro de modelo %sq pode não ser redeclarado nesse escopo",
  "declaração de %sq esconde parâmetro de template",
  "a lista de argumentos de modelo deve corresponder à lista de parâmetros",
  null,
  "parâmetro extra do sufixo 'operador%s' deve ser do tipo 'int'",
  "o nome de um operador deve ser declarado como uma função",
  "nome de operador não é permitido",
  "%n não pode ser especializado no escopo atual",
  "formulário não padronizado para capturar o endereço de uma função membro",
  "muito poucos parâmetros de modelo -- não corresponde à declaração anterior (declarado %p)",
  "muitos parâmetros de modelo -- não corresponde à declaração anterior (declarado %p)",
  "modelo de função para operador delete(void *) não é permitido",
  "modelo de classe e parâmetro de modelo podem não ter o mesmo nome",
  null,
  "um argumento de modelo pode não referenciar um tipo sem nome",
  "essa operação em um tipo de enumeração requer uma função de operador aplicável definida pelo usuário",
  "qualificador de tipo em um tipo de referência não é permitido",
  "um valor do tipo %t1 não pode ser atribuído para uma entidade do tipo %t2",
  "comparação sem sentido de inteiro sem sinal com uma constante negativa",
  "não pode converter para a classe incompleta %t",
  "objetos constantes requerem inicialização",
  "objeto possui uma constante ou membro de referência não inicializado",
  "pré-processamento de diretiva não padrão",
  "%n pode não ter uma lista de argumentos de template",
  "inicialização com '{...}' esperado para objeto de agregação",
  "tipos de ponteiro para membro de seleção de classe são incompatíveis (%t1 e %t2)",
  "declaração de friend sem sentido",
  "'.' utilizado no lugar de '::' para formar um nome qualificado",
  "função não constante chamada para objeto constante (anacronismo)",
  "uma instrução dependente pode não ser uma declaração",
  "um parâmetro pode não ter tipo void",
  "instanciação de %na %p",
  "processando lista de argumento de modelo para %na %p",
  "esse operador não é permitido em uma expressão de argumento de modelo",
  "bloco try requer pelo menos um manipulador",
  "um manipulador requer uma declaração de exceção",
  "um manipulador é mascarado pelo manipulador padrão",
  "um manipulador é potencialmente mascarado pelo manipulador anterior para o tipo %t",
  "utilize um tipo local para especificar uma exceção",
  "tipo redundante na especificação de uma exceção",
  "especificação da exceção é incompatível com aquela da %nd%s anterior",
  "previamente especificado: nenhuma exceção será lançada",
  "omitido anteriormente: %t",
  "especificado anteriormente mas omitido aqui: %t",
  "o suporte para tratamento de exceções está desabilitado",
  "permitir todas as exceções é incompatível com o %nd anterior",
  "não pôde criar o arquivo de requisição de instanciação %sq",
  "operação não aritmética não permitida em um argumento de modelo sem tipo",
  "utilização de um tipo local para declarar uma variável não local",
  "utilização de tipo local para declarar uma função",
  "transferência de controle desvia a inicialização de:",
  "%nd",
  "transferência de controle dentro de um manipulador de exceção",
  "%n é utilizado antes de seu valor ser definido",
  "%n foi definido mas nunca utilizado",
  "%n não pode ser definido no escopo atual",
  "especificação de exceção não é permitida",
  "conflito de vínculo interno/externo para %nfd",
  "%nf não será chamado para conversões implícitas ou explícitas",
  "rótulo como %s é incompatível com parâmetro de modelo de tipo %t",
  "modelo de função para operador new(size_t) não é permitido",
  null,
  "ponteiro para membro do tipo %t não é permitido",
  "elipse não é permitido na lista de parâmetros de uma função operador",
  "%no está reservada para futuro uso como palavra-chave",
  "definição de macro inválida: %s",
  "indefinição de macro inválida: %s",
  null,
  null,
  "nome do arquivo IL deve ser especificado se a entrada for ",
  null,
  null,
  null,
  null,
  "erro no argumento da opção de depuração",
  "opção inválida: %s",
  "o back end requer o nome do arquivo IL",
  "não foi possível abrir o arquivo de nível de integridade %s",
  "número inválido: %s",
  "id incorreto da CPU host",
  "modo de instanciação inválido: %s",
  null,
  "limite de erro inválido: %s",
  null,
  null,
  null,
  null,
  null,
  null,
  "tabelas de funções virtuais podem ser ignoradas somente quando se estiver compilando C++",
  "opção de anacronismo pode ser utilizada somente quando se estiver compilando C++",
  "opção de modo de instanciação pode ser utilizada somente quando se estiver compilando C++",
  "modo de instanciação automático pode ser utilizado somente quando se estiver compilando C++",
  "modo de inclusão de modelo implícito pode ser utilizado somente quando se estiver compilando C++",
  "opção de tratamento de exceção pode ser utilizada somente quando se estiver compilando C++",
  "modo estrito é incompatível com modo K&R",
  "modo estrito é incompatível com modo cfront",
  "faltando o nome do arquivo fonte",
  "arquivos de saída podem não ser especificados ao se compilar muitos arquivos de entrada",
  "muitos argumentos na linha de comando",
  "um arquivo de saída foi especificado, mas nenhum é necessário",
  "exibição de IL requer o nome do arquivo de IL",
  "um parâmetro de modelo pode nunca ter um tipo void",
  "instanciação recursiva excessiva de %n devido ao modo instancie-tudo",
  "modo estrito é incompatível com anacronismos permitidos",
  "uma expressão throw pode não ter um tipo void",
  "modo de instanciação local é incompatível com instanciação automática",
  "parâmetro do tipo de classe abstrata %t não é permitido:",
  "matriz de classe abstrata %t não é permitido:",
  "parâmetro ponto-flutuante de modelo não é padrão",
  "esse pragma deve preceder uma declaração imediatamente",
  "esse pragma deve preceder uma instrução imediatamente",
  "esse pragma deve preceder uma declaração ou instrução imediatamente",
  "esse tipo de pragma pode não ser utilizado aqui",
  null,
  "função virtual sobrecarregada %no1 é somente parcialmente sobrescrita por %n2",
  "definição específica de função modelo embutida deve preceder seu primeiro uso",
  "rótulo de erro inválido na opção de controle de diagnóstico: %s",
  "número de erro inválido na opção de controle de diagnóstico: %s",
  null,
  null,
  "conversão de ponteiro para função-membro para ponteiro de função",
  "struct ou union declaram membros sem nome",
  "campo sem nome não padrão",
  "membro sem nome não padrão",
  null,
  null,
  null,
  "%sq não é um nome de tipo",
  "não é possível abrir o arquivo de entrada de cabeçalho pré-compilado %sq: %s2",
  "arquivo de cabeçalho pré-compilado %sq é ou inválido ou não gerado por essa versão do compilador",
  "arquivo de cabeçalho pré-compilado %sq não foi gerado nesse diretório",
  "os arquivos de cabeçalhos utilizados para gerar o arquivo de cabeçalho pré-compilado %sq mudaram",
  "as opções de linha de comando não correspondem àquelas utilizadas quando o arquivo de cabeçalho pré-compilado %sq foi criado",
  "a sequência inicial de diretivas de pré-processamento não é compatível com aquelas do arquivo de cabeçalho pré-compilado %sq",
  "não é possível obter memória mapeada",
  "%s': usando arquivo de cabeçalho pré-compilado '%s'",
  "'%s': criando arquivo de cabeçalho pré-compilado '%s'",
  "utilização de memória conflita com arquivo de cabeçalho pré-compilado %sq",
  "tamanho da memória PCH inválido: %s ",
  "opções de PCH devem aparecer primeiro na linha de comando",
  "memória insuficiente para alocação de memória PCH",
  "arquivos de cabeçalho pré-compilados podem não ser utilizados quando se estiver compilando muitos arquivos de entrada",
  "memória pré-alocada insuficiente para a geração do arquivo de cabeçalho pré-compilado (%s bytes exigidos)",
  "entidade muito grande no programa evita a geração do arquivo de cabeçalho pré-compilado",
  "%sq não é um diretório válido",
  "não pode construir um nome de arquivo temporário",
  "'restrict' não é permitido",
  "um ponteiro ou referência para tipo de função pode não ser qualificado como 'restrito'",
  null,
  "um modificador de convenção de chamada pode não ser especificado aqui",
  "modificadores de convenção de chamada conflitantes",
  "modo estrito é incompatível com modo Microsoft",
  "modo cfront é incompatível com modo Microsoft",
  "a convenção de chamada especificada aqui é ignorada",
  "uma convenção de chamada pode não ser seguida por um declarador aninhado",
  "convenção de chamada é ignorada para esse tipo",
  null,
  "modificadores de declaração são incompatíveis com declaração anterior",
  "o modificador %sq não é permitido nessa declaração",
  "transferência de controle dentro de um bloco try",
  "especificação embutida é incompatível com %nod anterior",
  "chaves de fechamento da definição do modelo não encontrada",
  "opção wchar_t keyword pode ser utilizada somente quando se estiver compilando C++",
  "valor de alinhamento de empacotamento inválido",
  "esperado uma constante inteira",
  "chamada de função virtual pura",
  "cadeia de caracteres identificadora de arquivo fonte inválida",
  "um modelo de classe não pode ser definido em uma declaração de friend",
  "'asm' não é permitido",
  "'asm' deve ser utilizado com uma definição de função",
  "função 'asm' não é padrão",
  "elipse com parâmetros não explícitos não é padrão",
  "'&...' não é padrão",
  "uso inválido de '&...'",
  null,
  "variável temporária utilizada para valor inicial de referência para constante volatile (anacronismo)",
  "a referência do tipo %t1 não pode ser inicializada com um valor do tipo %t2",
  "valor inicial de referência para constante volatile deve ser um lvalue",
  "opção de compatilibidade SVR4 C pode ser utilizada somente quando se estiver compilando ANSI C",
  "utilizando declaração fora do escopo de %nd",
  "modo estrito é incompatível com modo SVR4 C",
  "chamada de %nd não pode ser embutida",
  "%n não pode ser embutido",
  "diretório PCH inválido: %s",
  "esperado __except ou __finally",
  "uma instrução __leave pode ser utilizada apenas dentro de um __try",
  "detectado durante a instanciação de %nt %p",
  "detectado durante a geração implícita de %nt %p",
  "detectado durante instanciação de %na %p",
  "detectado durante processamento de lista de argumento de modelo para %na %p",
  "detectado durante definição implícita de %nt %p",
  "%sq não encontrado na pilha de alinhamento de pacote",
  "pilha de alinhamento de pacote vazia",
  "opção RTTI pode ser utilizada somente quando se estiver compilando C++",
  "%nfd, exigido para a cópia que foi eliminada, está inacessível",
  "%nf, exigido para a cópia que foi eliminada, não está disponível para chamada porque um parâmetro de referência não pode ser associado a rvalue",
  "<typeinfo> deve estar incluso antes que o typeid seja utilizado",
  "%s não pode converter constantes e outros qualificadores de tipo",
  "o tipo em um dynamic_cast deve ser um ponteiro ou uma referência para um tipo de classe completo, ou void *",
  "o operando de um ponteiro dynamic_cast deve ser um ponteiro para um tipo de classe completo",
  "o operando de uma referência dynamic_cast deve ser um lvalue de um tipo de classe completo",
  "o operando de um dynamic_cast de tempo de execução deve possuir um tipo de classe polimórfico",
  "opção bool pode ser utilizada somente quando se estiver compilando em C++",
  null,
  "um tipo matriz não é permitido aqui",
  "esperado um '='",
  null,
  "%sq, declarada em condição, pode não ser redeclarada nesse escopo",
  "argumentos de modelo padrão não são permitidos para modelos de funções",
  "esperado um ',' ou '>'",
  "esperado uma lista de parâmetro de modelo",
  "o incremento de um valor bool é preterido",
  "tipo bool não é permitido",
  "deslocamento da classe base %no1 dentro da classe %no2 é muito grande",
  "expressão deve possuir tipo bool (ou ser conversível para bool)",
  "opções de matriz new e delete podem ser utilizadas somente quando se estiver compilando C++",
  "%n não é o nome de uma variável",
  "modificador __based não é permitido aqui",
  "__based não precede um operador de ponteiro, __based ignorado",
  "o modificador da variável in __based deve possuir tipo de ponteiro",
  "o tipo em um const_cast deve ser um ponteiro, referência, ou ponteiro para membro para um tipo objeto",
  "um const_cast pode ajustar somente qualificadores de tipo; ele não pode alterar o tipo por trás",
  "mutable não é permitido",
  "redeclaração de %n não é permitido para alterar seu acesso",
  null,
  "o uso do token alternativo '<:' parece que não foi intencional",
  "o uso do token alternativo '%%' parece que não foi intencional",
  "definição de namespace não é permitido",
  "nome deve ser um nome de namespace",
  "definição do alias do namespace não é permitido",
  "nome qualificado de namespace é exigido",
  "um nome de namespace não é permitido",
  "combinação inválida de atributos DLL",
  "%n não é um modelo de classe",
  "matriz com tipo de elemento incompleto não é padrão",
  "operador de alocação pode não ser declarado em um namespace",
  "operador de desalocação pode não ser declarado em um namespace",
  "%np1 entra em conflito com a declaração using de %np2",
  "a declaração using de %np1 entra em conflito com %npd2",
  "opção de namespace pode ser utilizada somente quando se estiver compilando C++",
  "declaração using ignorada -- ela se refere ao namespace atual",
  "um nome qualificado de classe é exigido",
  "os tipos de argumentos são: (%s)",
  "os tipos de operandos são: %s",
  null,
  "%n não possui nenhum membro %sq",
  null,
  "atributos de memória especificados incompatíveis",
  "atributo de memória ignorado",
  "atributo de memória pode não ser seguido por um declarador aninhado",
  "atributo de memória especificado mais de uma vez",
  "convenção de chamada especificada mais de uma vez",
  "um qualificador de tipo não é permitido",
  "%npd1 foi utilizado antes do seu modelo ser declarado",
  "funções membro estáticas e não estáticas com os mesmos tipos de parâmetros não podem ser sobrecarregadas",
  "nenhuma declaração anterior de %np",
  "um id de modelo não é permitido",
  "um nome qualificado de classe não é permitido",
  "%n pode não ser redeclarado no escopo atual",
  "nome qualificado não é permitido na declaração de membro do namespace",
  "%n não é o nome de um tipo",
  "instanciação explícita não é permitida no escopo atual",
  "%n não pode ser explicitamente instanciada no escopo atual",
  "%n instanciado explicitamente mais de uma vez",
  "nome de tipo pode ser utilizado somente dentro de um modelo",
  "a opção special_subscript_cost pode ser utilizada somente quando se estiver compilando C++",
  "a opção de nome de tipo pode ser utilizada somente quando se estiver compilando C++",
  "a opção de nome de tipo implícito pode ser utilizada somente quando se estiver compilando C++",
  "caractere não padrão no início da definição de macro parecida com objeto",
  "especificação de exceção para %n1 virtual é incompatível com aquela do %n2 sobrescrito",
  "conversão de ponteiro para um inteiro menor",
  "especificação de exceção para %n1 virtual implicitamente declarado é incompatível com aquela do %n2 sobrescrito",
  "%no1, chamado implicitamente de %np2, é ambíguo",
  "a opção 'explicit' pode ser utilizada somente quando se estiver compilando C++",
  "'explicit' não é permitido",
  "declaração entra em conflito com %sq (nome de classe reservado)",
  "somente '()' é permitido como inicializador para matriz %n",
  "'virtual' não é permitido em uma declaração de modelo de função",
  "union anônima inválida -- modelo de membro de classe não é permitido",
  "a profundidade de aninhamento de modelo não corresponde à declaração anterior de %n",
  "essa declaração não pode ter várias cláusulas 'template <...>'",
  "a opção para controlar o escopo for-init pode ser utilizada somente quando se estiver compilando C++",
  "%sq, declarado para inicialização loop, talvez não seja declarado novamente nesse escopo",
  "referência para %nd1 -- inferior ao antigo para regras de escopo -init seria %nd2",
  "a opção para controlar avisos sobre as diferenças no for-init pode ser utilizada somente quando se estiver compilando C++",
  "definição de %n virtual é exigido aqui",
  "comentário vazio interpretado como operador token-pasting '##'",
  "uma classe de armazenamento não é permitida em uma declaração de friend",
  "lista de parâmetros de modelo para %no não é permitido nessa declaração",
  "%n não é um modelo de membro de classe válido",
  "não é um membro de classe ou declaração de modelo de função válido",
  "uma declaração de modelo contendo uma lista de parâmetros de modelo não pode ser seguida por uma declaração de especialização explícita",
  "especialização explícita de %n1 deve preceder o primeiro uso de %n2",
  "especialização explícita não permitida no escopo atual",
  "especialização parcial de %n não é permitida",
  "%nf não é uma entidade que possa ser explicitamente especializada",
  "a especialização explícita de %n deve preceder seu primeiro uso",
  "o parâmetro de modelo %sq não pode ser usado em um especificador de tipo elaborado",
  "especialização %n requer a sintaxe 'template<>'",
  null,
  null,
  "a opção 'old_specializations' pode ser utilizada somente quando se estiver compilando C++",
  "a especialização %n sem sintaxe 'template<>' não é padrão",
  "essa declaração não pode ter vínculo 'C' externo",
  "%sq não é uma classe ou nome de modelo de função no escopo atual",
  "a especificação de um argumento padrão quando se está redeclarando um modelo de função não referenciado não é padrão",
  "a especificação de um argumento padrão quando se está redeclarando um modelo de função já referenciado não é permitido",
  "não pode converter ponteiro para membro de classe base %t2 para ponteiro para membro de classe derivada %t1 -- classe base é virtual",
  "especificação de exceção é incompatível com aquela da %nd%s",
  "permitir todas as exceções é incompatível com o %nd",
  "término não esperado da expressão de argumento padrão",
  "inicialização padrão de referência não é permitida",
  "%n não inicializado possui um membro constante",
  "classe base não inicializada %t possui um membro constante",
  "constante %n requer exige um inicializador -- classe %t não possui construtor padrão definido pelo usuário",
  "objeto constante requer um inicializador -- classe %t não possui construtor padrão definido pelo usuário",
  "a opção 'implicit_extern_c_type_conversion' pode ser utilizada somente quando se estiver compilando C++",
  "o modo estrito é compatível com regras longas de preservação",
  "qualificador de tipo ou tipo de retorno são sem sentido",
  "em uma definição de função não é permitido um qualificador de tipo em um tipo de retorno 'void'",
  "declaração de membro de dados estáticos não permitida nessa classe",
  "a instanciação de modelo resultou em uma declaração de função inválida",
  "'...' não é permitido",
  "a opção 'extern_inline' pode ser utilizada somente quando se estiver compilando C++",
  "o inline externo %n foi referenciado, mas não definido",
  "nome de destrutor inválido para tipo %t",
  null,
  "a referência destruidora é ambígua -- %n1 e %n2 não podem ser usados",
  "inline virtual %n nunca definido",
  "%n nunca foi referenciado",
  "apenas um membro de uma união pode ser especificado em uma lista inicializadora do construtor",
  "suporte a 'new[]' e 'delete[]' desabilitado",
  "double' usado para 'long double' no código C gerado",
  "%n não possui exclusão do operador correspondente%s (a ser chamado se uma exceção ocorrer durante a inicialização de um objeto alocado)",
  "o suporte para exclusão de posicionamento está desabilitado",
  "nenhuma exclusão apropriada do operador está visível",
  "ponteiro ou referência para o tipo incompleto não é permitida",
  "especialização parcial inválida -- %n já está totalmente especializado",
  "especificações de exceção incompatíveis",
  "referência de retorno para variável local",
  "a omissão do tipo explícito não é padrão ('int' assumed)",
  "mais de uma especialização parcial corresponde à lista de argumentos do modelo de %n",
  "%nod",
  "uma lista de argumentos do modelo não é permitida em uma declaração de um modelo primário",
  "as especializações parciais podem não ter argumentos de modelo padrão",
  "%n1 não é usado ou não pode ser deduzido a partir da lista de argumentos do modelo de %n2",
  null,
  "a lista de argumentos do modelo da especialização parcial inclui um argumento sem tipo cujo tipo depende de um parâmetro de modelo",
  "essa especialização parcial teria sido usada para instanciar %n",
  "essa especialização parcial poderia ter deixado a instanciação de %n ambígua",
  "a expressão deve ter o tipo integral ou de enumeração",
  "a expressão deve ter tipos aritméticos ou de enumeração",
  "a expressão deve ter tipos aritméticos, de enumeração ou de ponteiro",
  "o tipo de conversão deve ser integral ou de enumeração",
  "o tipo de conversão deve ser aritmético, de enumeração ou de ponteiro",
  "a expressão deve ser um ponteiro para um tipo de objeto completo",
  null,
  "uma especialização parcial de argumento sem tipo deve ser o nome de um parâmetro sem tipo ou uma constante",
  "o tipo de retorno não é idêntico ao tipo de retorno %t da função virtual sobrescrita %no",
  "a opção 'guiding_decls' pode ser utilizada somente quando se estiver compilando C++",
  "deve ser declarada uma especialização parcial de um modelo de classe no namespace do qual é um membro",
  "%n é um função virtual pura",
  "virtual pura %n não é sobrescrita por ninguém",
  "atributo __declspec ignorado",
  "caractere inválido em linha de entrada",
  "função retorna tipo incompleto %t",
  "o efeito dessa diretiva '#pragma pack' é local para %n",
  "%s não é um modelo",
  "uma declaração de friend pode não declarar uma especialização parcial",
  "especificação de exceção ignorada",
  "declaração de 'size_t' não corresponde ao tipo esperado %t",
  "espaço necessário entre os delimitadores '>' adjacentes das listas de argumentos do modelo aninhado ('>>' é o operador shift à esquerda)",
  "não foi possível localizar %sq para permitir o processamento de caracteres multibyte",
  "sequência de caracteres de multibyte inválida",
  "a instanciação de modelo resultou no tipo de função inesperada de %t1 (o significado de um nome pode ter sido alterado desde a declaração do modelo -- o tipo de modelo é %t2)",
  "declaração de orientação ambígua -- mais de um modelo de função %no corresponde ao tipo %t",
  "operação não integral não permitida no argumento de modelo sem tipo",
  "a opção 'embedded_c++' pode ser utilizada somente quando se estiver compilando C++",
  "C++ embutido não suporta modelos",
  "C++ embutido não suporta tratamento de exceções",
  "C++ embutido não suporta namespaces",
  "C++ embutido não suporta informação de tipo em tempo de execução",
  "C++ embutido a nova sintaxe de conversão",
  "C++ embutido não suporta declarações using",
  "C++ embutido não suporta 'mutable'",
  "C++ embutido não suporta herança múltipla ou virtual",
  "número de versão da Microsoft inválido: %s",
  "a representação ponteiro para membro %sq já foi definida para %n",
  "%t1 não pode ser usado para designar o construtor para %t2",
  "sufixo ou constante integral inválida",
  "o operando de __uuidof deve ter uma classe ou um tipo de enumeração para o qual __declspec(uuid('...')) foi especificado",
  "cadeia GUID inválida em __declspec(uuid('...'))",
  "a opção 'vla' pode ser utilizada somente quando se estiver compilando C",
  "a matriz de comprimento variável com vínculo não especificado não é permitida",
  "uma lista de argumentos de modelo explícito não é permitida nessa declaração",
  "uma entidade com vínculo não pode ter um tipo que envolve uma matriz de comprimento variável",
  "uma matriz de comprimento variável não pode ter duração de armazenamento estático",
  "%n não é um modelo",
  "dimensão da matriz de comprimento variável (declarado %p)",
  "expected um argumento de modelo",
  null,
  "o operador não membro precisa de um parâmetro com classe ou tipo de enumeração",
  "a opção 'enum_overloading' pode ser utilizada somente quando se estiver compilando C++",
  null,
  "o qualificador de nome de destruidor %t1 não corresponde ao tipo %t2",
  "qualificador de tipo ignorado",
  "a opção 'nonstd_qualifier_deduction' pode ser utilizada somente quando se estiver compilando C++",
  "uma função declarada 'dllimport' talvez não possa ser definida",
  "especificação de propriedade incorreta; a forma correta é __declspec(property(get=name1,put=name2))",
  "a propriedade já foi especificada",
  "__declspec(property) não é permitido nessa declaração",
  "membro declarado com __declspec(property), mas nenhuma função 'get' foi especificada",
  "função __declspec(property) 'get' %sq ausente",
  "o membro é declarado with __declspec(property), mas nenhuma função 'put' foi especificada",
  "função __declspec(property) 'put' %sq ausente",
  "referência de membro de classe ambígua -- %nd1 usado preferencialmente em vez de %nd2",
  null,
  null,
  null,
  "não é possível converter ponteiro para membro da classe derivada %t1 para apontar para o membro da classe de base %t2 -- a classe de base é virtual",
  "diretório inválido para os arquivos de instanciação: %s",
  "a opção 'one_instantiation_per_object' pode ser utilizada somente quando se estiver compilando C++",
  null,
  null,
  "um nome de arquivo de informação de instanciação pode não ser especificado ao compilar vários arquivos de entrada",
  "a opção 'one_instantiation_per_object' pode não ser utilizada quando se estiver compilando muitos arquivos de entrada",
  "Existe mais de uma linha de comando com a abreviação '--%s':",
  "--%s",
  "os qualificadores de tipo nos tipos de função são ignorados",
  null,
  "a opção de tiebreaker anterior/posterior pode ser usada apenas ao compilar C++",
  "uso incorreto de va_start",
  "uso incorreto de va_arg",
  "uso incorreto de va_end",
  "a opção de instanciações pendentes pode ser utilizada somente quando se estiver compilando C++",
  "diretório inválido para arquivos #import:%s",
  "um diretório de importação pode ser especificado somente no modo Microsoft",
  "um membro com tipo de referência não é permitido em uma união",
  "typedef' talvez não seja especificado aqui",
  "a redeclaração de %n altera seu acesso",
  "um nome qualificado de classe ou namespace é exigido",
  "tipo de retorno 'int' omitido na declaração de função 'main'",
  "a representação ponteiro para membro %sq é muito restrita para %n",
  "instrução return ausente no final de não void%n",
  "declaração em uso duplicada de %no ignorada",
  "os campos de bits de enumeração nunca são assinados, mas a enumeração %t inclui um enumerador negativo",
  "a opção 'class_name_injection' pode ser utilizada somente quando se estiver compilando C++",
  "a opção 'arg_dep_lookup' pode ser utilizada somente quando se estiver compilando C++",
  "a opção 'friend_injection' pode ser utilizada somente quando se estiver compilando C++",
  "nome seguido de 'template' deve ser um modelo",
  null,
  "declaração de friend de classe local não padrão – nenhuma declaração anterior no escopo delimitador",
  "especificar um argumento padrão nessa declaração não é padrão",
  "a opção 'nonstd_using_decl' pode ser utilizada somente quando se estiver compilando C++",
  "o tipo de retorno da função 'main' deve ser 'int'",
  "um parâmetro de modelo sem tipo pode não ter tipo de classe",
  "um argumento de modelo padrão não pode ser especificado na declaração de um membro de um modelo de classe fora de sua classe",
  "uma instrução return não é permitida em um manipulador de um bloco try de função de um construtor",
  "os designadores estendidos e comuns não podem ser combinados em uma designação de inicializador",
  "a segunda subscrição não deve ser menor que a primeira",
  null,
  "a opção 'extended_designators' pode ser utilizada somente quando se estiver compilando C",
  "tamanho declarado para o campo de bit é maior que o tamanho do tipo de campo de bit; truncado para %s bits",
  "tipo usado como nome de construtor não corresponde ao tipo %t",
  "uso de um tipo sem vínculo para declarar uma variável com vínculo",
  "uso de um tipo sem vínculo para declarar uma função",
  "o tipo de retorno pode não ser específico em um construtor",
  "o tipo de retorno pode não ser especificado em um destruidor",
  "nome de caractere universal formado incorretamente",
  "o nome de caractere universal especifica um caractere inválido",
  "um nome de caractere universal não pode designar um caractere no conjunto de caractere básico",
  "esse caractere universal não é permitido em um identificador",
  "o identificador __VA_ARGS__ somente pode ser exibido nas listas de substituição das macros variadic",
  "o qualificador dessa declaração de friend é ignorado",
  "os designadores de intervalo de matriz não podem ser aplicados a inicializadores dinâmicos",
  "o nome de propriedade não pode ser exibido aqui",
  "o 'inline' usado como um qualificador de função é ignorado",
  "a opção 'compound_literals' pode ser utilizada somente quando se estiver compilando C",
  "um tipo de matriz de tamanho variável não é permitido",
  "um literal composto não é permitido em uma expressão constante integral",
  "um literal composto do tipo %t não é permitido",
  "uma declaração de friend de modelo não pode ser declarada em uma classe local",
  "operador '?' ambíguo: segundo operador do tipo %t1 pode ser convertido para o terceiro operador tipo %t2, e vice-versa",
  "chamada de um objeto de um tipo de classe sem operador() apropriado ou funções de conversão para o tipo ponteiro para função",
  "função substituta da conversão %np",
  "há mais de um modo no qual um objeto de tipo %t pode ser chamado para a lista de argumento:",
  "o nome typedef já foi declarado (com tipo similar)",
  "operador novo e exclusão de operador não podem receber vínculo interno",
  "classe de armazenamento 'mutable' não permitida para uniões anônimas",
  "arquivo de cabeçalho pré-compilado inválido",
  "o tipo de classe abstrata %t não é permitido como tipo catch",
  "um tipo de função qualificado não pode ser usado para declarar uma função sem membro ou uma função de membro estático",
  "um tipo de função qualificado não pode ser usado para declarar um parâmetro",
  "não é possível criar um ponteiro ou referência a um tipo de função qualificado",
  "chaves extra não são padrão",
  "definição de macro inválida: %s",
  "a subtração de tipos de ponteiro %t1 e %t2 não é padrão",
  "uma lista de parâmetros de modelo vazio não é permitida em uma declaração de parâmetro de modelo",
  "esperado 'class'",
  "a palavra-chave \"struct\" não pode ser usada ao declarar um parâmetro de modelo do modelo",
  "%np2 é oculto por %no1 -- a função virtual sobrescreve a intencionada?",
  "um nome qualificado não é permitido para uma declaração de friend que é uma definição de função",
  "%n1 não é compatível com %n2",
  "uma classe de armazenamento pode não ter sido especificada aqui",
  "membro de classe designado por uma declaração em uso deve ser visível em uma classe de base direta",
  null,
  "o modo Sun é incompatível com o modo cfront",
  "o modo estrito é incompatível com o modo Sun",
  "modo Sun é permitido somente quando se estiver compilando C++",
  "um parâmetro de modelo não pode ter o mesmo nome que seus parâmetros de modelo",
  "instanciação recursiva do argumento padrão",
  null,
  "%n não é uma entidade que pode ser definida",
  "o nome do destruidor deve ser qualificado",
  "friend class name may not be introduced with \"typename\"",
  "uma declaração em uso não pode nomear um construtor ou destruidor",
  "uma declaração de modelo friend qualificado deve fazer referência a um modelo específico declarado anteriormente",
  "especificador inválido em declaração de modelo de classe",
  "argumento é incompatível com parâmetro formal",
  "a opção 'dep_name' pode ser utilizada somente quando se estiver compilando C++",
  "loop in sequence of \"operator->\" functions starting at class %t1",
  "%n não tem classe de membro %sq",
  "o escopo global não tem classe nomeada %sq",
  "instanciação recursiva do argumento padrão de modelo",
  "as declarações de acesso e declarações em uso não podem ser exibidas em uniões",
  "%no não é um membro de classe",
  "a declaração de constante de membro não padrão não é permitida",
  "a opção 'ignore_std' pode ser utilizada somente quando se estiver compilando C++",
  "a opção 'parse_templates' pode ser utilizada somente quando se estiver compilando C++",
  "option \"dep_name\" cannot be used with \"no_parse_templates\"",
  "os modos de idioma especificados são incompatíveis",
  "redeclaração inválida de classes aninhadas",
  "o tipo que contém uma matriz de tamanho desconhecido não é permitido",
  "uma variável com duração de armazenamento estática não pode ser definida em uma função inline",
  "uma entidade com vínculo interno não pode ser referenciada em uma função inline com vínculo externo",
  "o tipo de argumento %t não corresponde a essa macro de função de tipo genérico",
  "matriz de comprimento variável %nod",
  "a declaração de friend não pode adicionar argumentos padrão à declaração anterior",
  "%n não pode ser declarado nesse escopo",
  "o identificador reservado %sq somente pode ser usado dentro de uma função",
  "esse caractere universal não pode iniciar um identificador",
  "esperado uma cadeia de caracteres literal",
  "pragma STDC não reconhecido",
  "esperado 'ON', 'OFF', ou 'DEFAULT'",
  "um pragma STDC somente pode ser exibido entre as declarações no escopo global ou antes de quaisquer declarações ou instruções em um escopo de bloco",
  "uso incorreto de va_copy",
  "%s somente pode ser usado com tipos de ponto flutuante",
  "o tipo complexo não é permitido",
  "tipo de designador inválido",
  "o valor do ponto flutuante não pode ser representado exatamente",
  "o resultado da operação de ponto flutuante complexo está fora do intervalo",
  "a conversão entre real e imaginário é zero",
  "um inicializador não pode ser especificado para um membro de matriz flexível",
  "imaginário *= imaginário define o operando esquerdo para zero",
  "standard requires that %n be given a type by a subsequent declaration (\"int\" assumed)",
  "a definição é exigida para inline %n",
  "conversão de inteiro para ponteiro menor",
  "um tipo de ponto flutuante deve ser incluído no especificador de tipo para um tipo _Complex ou _Imaginary",
  "os tipos não podem ser declarados em uniões anônimas",
  "retornando o ponteiro à variável de local",
  "retornando o ponteiro ao temporário de local",
  "a opção 'export' pode ser utilizada somente quando se estiver compilando C++",
  "option \"export\" cannot be used with \"no_dep_name\"",
  "option \"export\" cannot be used with \"implicit_include\"",
  "a declaração de %n é incompatível com a declaração de outra unidade de tradução",
  "a outra declaração é %p",
  "detectado durante a compilação da unidade de tradução secundária %sq",
  "compilação da unidade de tradução secundária %sq",
  "uma declaração de campo não pode ter um tipo que envolva uma matriz de tamanho variável",
  "a declaração de %n teve um significado diferente durante a compilação %sq",
  "esperado 'template'",
  "'export' não pode ser utilizado em uma instanciação explícita",
  "'export' não pode ser utilizado nessa declaração",
  "um membro de um namespace não nomeado não pode ser declarado como 'export'",
  "um modelo não pode ser declarado como 'export' depois que tiver sido definido",
  "uma declaração não pode ter um rótulo",
  "suporte para modelos exportados está desabilitado",
  null,
  "%n já definido durante a compilação de %sq",
  "%n já definido em outra unidade de tradução",
  "uma variável local não estática pode não ser utilizada em um especificação __based",
  "a opção para listar as dependências de um makefile pode não ser especificada quando se estiver compilando mais de uma unidade de tradução",
  null,
  "a opção para gerar uma saída pré-processada pode ser especificada ao compilar mais de uma unidade de tradução",
  "um campo com o mesmo nome que sua classe não pode ser declarado em uma classe com um construtor declarado pelo usuário",
  "\"implicit_include\" cannot be used when compiling more than one translation unit",
  "o arquivo de modelo exportado %sq está corrompido",
  "%n não pode ser instanciado -- ele foi explicitamente especializado na unidade de tradução que contém a definição exportada",
  "o tipo de objeto é: %s",
  "o objeto tem qualificadores de tipo que não são compatíveis com o membro %n",
  "nenhuma instância de %n corresponde à lista de argumento e objeto (o objeto tem qualificadores de tipo que evitam uma correspondência)",
  "um atributo especifica um modo incompatível com %t",
  "não há nenhum tipo com a largura especificada",
  "valor de alinhamento inválido especificado por atributo",
  "atributo inválido para %t",
  null,
  null,
  "atributo %sq não captura argumentos",
  null,
  "esperado um nome de atributo",
  "atributo %sq desconhecido",
  "atributos podem não aparecer aqui",
  "argumento inválido para atributo %sq",
  null,
  "em 'goto *expr', expr deve ter o tipo 'void *'",
  "'goto *expr' não é padrão",
  "capturar o endereço de um rótulo não é padrão",
  "nome do arquivo especificado mais de uma vez: %s",
  "diretiva #warning: %s",
  null,
  "o atributo 'transparent_union' aplica-se somente para unions, e %t não é uma union",
  "o atributo 'transparent_union' é ignorado por tipos incompletos",
  "%t não pode ser transparent porque %n não possui o mesmo tamanho que o primeiro campo",
  "%t1 não pode ser transparente porque possui um campo do tipo %t2 que não é do mesmo tamanho que o primeiro campo",
  null,
  "o atributo %sq não se aplica a variáveis locais",
  "atributos não são permitidos na definição de uma função",
  null,
  "a segunda constante em um intervalo case deve ser maior que a primeira",
  "um nome asm não é permitido na definição de uma função",
  "um nome asm é ignorado em um typedef",
  "unknown register name \"%s\"",
  null,
  "unknown asm constraint modifier \"%s\"",
  "unknown asm constraint letter \"%s\"",
  "o operando asm não possui letra de restrição",
  "an asm output operand must have one of the \"=\" or \"+\" modifiers",
  "an asm input operand may not have the \"=\" or \"+\" modifiers",
  null,
  null,
  "register \"%s\" used more than once",
  "register \"%s\" is both used and clobbered",
  "register \"%s\" clobbered more than once",
  "register \"%s\" has a fixed purpose and may not be used in an asm statement",
  "register \"%s\" has a fixed purpose and may not be clobbered in an asm statement",
  "um clobber vazio deve ser totalmente omitido",
  "esperado um operando asm",
  "esperado um registro para clobber",
  "\"format\" attribute requires an ellipsis parameter",
  "o primeiro argumento de substituição não é o primeiro argumento variável",
  "o índice de argumento do formato é maior que o número de parâmetros",
  "o argumento de formato não tem tipo de sequência",
  "the \"template\" keyword used for syntactic disambiguation may only be used within a template",
  "uma opção de depuração deve ser especificada na linha de comando para o pragma db_opt a ser usado",
  null,
  "o atributo %sq não é aplicável a um tipo sem função %t",
  "aritmético no ponteiro para tipo de função ou anulação",
  "a classe de armazenamento deve ser automática ou de registro",
  "%t1 seria promovido para %t2 ao passar por um parâmetro de elipse; usar o último tipo em vez disso",
  "%sq não é um membro de classe de base",
  "__super cannot appear after \"::\"",
  "__super somente pode ser usado em um escopo de classe",
  "__super must be followed by \"::\"",
  "[ %d contextos de instanciação não mostrados ]",
  "o nome danificado é muito longo",
  "declaração com alias para a entidade não definida %sq",
  "a declaração não corresponde a seu alias %n",
  "uma entidade declarada como alias não pode ter definição",
  "o tipo de campo de matriz de comprimento variável será tratado como tipo de campo de matriz de comprimento zero",
  "conversão não padrão em lvalue ignorada",
  "nome do sinalizador não reconhecido: %s",
  "o tipo de retorno de anulação não pode ser qualificado",
  "o especificador automático é ignorado aqui (inválido no padrão C/C++)",
  "a reduction in alignment without the \"packed\" attribute is ignored",
  "um modelo membro correspondente a %no é declarado como um modelo de um tipo diferente em outra unidade de tradução",
  "os inicializadores em excesso são ignorados",
  "va_start pode ser exibido apenas em uma função com um parâmetro de elipse",
  "the \"short_enums\" option is only valid in GNU C and GNU C++ modes",
  "arquivo de informação de exportação inválido %sq1 no número de linha %s2",
  "as expressões de instrução são apenas permitidas no escopo do bloco",
  "da unidade de tradução",
  "um nome asm é ignorado em uma variável automática de não registro",
  null,
  "pragma UPC não reconhecido",
  "o bloco compartilhado não corresponde a um especificado anteriormente",
  "a expressão entre colchetes é assumida como uma especificação de tamanho de bloco em vez de uma dimensão de matriz",
  "o tamanho de bloco de uma matriz compartilhada deve ser maior que zero",
  "vários tamanhos de bloco não são permitidos",
  "estrito ou reduzido exige compartilhado",
  "THREADS não permitido nesse contexto",
  "o tamanho de bloco especificado excede o valor máximo de %s",
  "a função que retorna compartilhada não é permitida",
  null,
  "uma dimensão de uma matriz de um tipo compartilhado deve ser um múltiplo de THREADS quando o número de segmentos não for constante",
  "o tipo compartilhado dentro de uma estrut. ou união não é permitido",
  "os parâmetros não podem ter tipos compartilhados",
  "uma dimensão THREADS dinâmica exige um tamanho de bloco definitivo",
  "as variáveis compartilhadas devem ser estáticas ou externas",
  "o argumento de upc_blocksizeof é um ponteiro para um tipo compartilhado (tipo não propriamente compartilhado)",
  "expressão de afinidade ignorada no upc_forall aninhado",
  "branch dentro ou fora de um loop upc_forall não é permitido",
  "a expressão de afinidade deve ter um tipo compartilhado ou apontar para um tipo compartilhado",
  "a afinidade tem tipo compartilhado (não ponteiro para compartilhado)",
  "tipos void* compartilhados somente podem ser comparados quanto à igualidade",
  "o modo UPC é incompatível com os modos C++ e K&R ",
  "caractere nulo (zero) na linha de entrada ignorado",
  "caractere nulo (zero) na sequência ou constante de caractere",
  "caractere nulo (zero) no nome do cabeçalho",
  "a declaração em para-inicializador oculta uma declaração no escopo circundante",
  "a declaração oculta é %p",
  "a declaração de protótipo de %nfd é ignorada após sua redeclaração não prototipada",
  null,
  "%npd deve ter vínculo C externo",
  "a declaração variável oculta a declaração em para-inicializador",
  "typedef %sq pode não ser usado em um especificador de tipo elaborado",
  "chamada de constante zero ignorada",
  "o parâmetro %sq pode não ser declarado novamente em uma cláusula variável do bloco try de função",
  "a especialização explícita inicial de %n deve ser declarada no namespace que contém o modelo",
  "\"cc\" clobber ignored",
  "\"template\" must be followed by an identifier",
  "MYTHREAD não permitido nesse contexto",
  "o qualificador de layout não pode qualificar o ponteiro para compartilhado",
  "o qualificador de layout não pode qualificar uma matriz incompleta",
  "a declaração %sq oculta o parâmetro manipulador",
  "conversão não padrão para o tipo de matriz ignorado",
  "esse pragma não pode ser usado em um operador _Pragma (uma diretiva #pragma deve ser usada)",
  "o campo usa proteção de origem para uma classe de base",
  "compiladores GNU C++ podem usar proteção de campo de bit",
  "%nd foi declarado 'obsoleto'",
  "um nome asm não é permitido em uma declaração de membro não estática",
  "tipo de função de formato não conhecido %sq ignorado",
  "a classe de base %no1 usa proteção de origem da classe de base %no2",
  "the \"init_priority\" attribute can only be used for definitions of static data members and namespace scope variables of class types",
  "a prioridade de inicialização solicitada é reservada para uso interno",
  "esse campo union/struct anônimo é oculto por %nd",
  "número de erro inválido",
  "etiqueta de erro inválida",
  "esperado um número de erro ou um rótulo de erro",
  "o tamanho da classe é afetado ",
  "as etiquetas podem ser referenciadas apenas em definições de função",
  "a transferência de controle em uma expressão de instrução não é permitida",
  null,
  "essa declaração não é permitida dentro de uma expressão de instrução",
  "não é possível definir, dentro de uma expressão de instrução, uma classe que não pode ser copiada de maneira trivial",
  null,
  "uma variável estática local inicializada dinamicamente não é permitida dentro de uma expressão de instrução",
  "uma matriz de comprimento variável não é permitida dentro de uma expressão de instrução",
  "uma expressão de instrução não é permitida dentro de um argumento padrão",
  "conversão não padrão entre ponteiro para função e ponteiro para dados",
  "tipos de interface não podem ter classes base virtuais",
  "tipos de interface não podem especificar 'private' ou 'protected'",
  "tipos de interface podem apenas derivar de outros tipos de interface",
  "%t é um tipo de interface",
  "tipos de interface não podem ter membros typedef",
  "tipos de interface não podem ter construtores ou destrutores declarados por usuário",
  "tipos de interface não podem ter operadores de membro declarados por usuário",
  "tipos de interface não podem ser declarados em funções",
  null,
  "tipos de interface não podem ter membros de dados",
  "tipos de interface não podem conter declarações de friend",
  null,
  "tipos de interface não podem ser tipos de classe aninhados",
  "tipos de interface não podem ter modelos de membros",
  "tipos de interface não podem ter funções membro estáticas",
  "esse pragma não pode ser usado em um operador __pragma (uma diretiva #pragma deve ser usada)",
  "o qualificador deve ser classe base de %t",
  "a declaração deve corresponder a uma função de membro virtual pura na classe de base indicada",
  "estouro de inteiro no cálculo interno devido ao tamanho ou complexidade de %t",
  "estouro de inteiro no cálculo interno",
  "__w64 somente pode ser especificado em tipos de ponteiro, longo e int.",
  "conversão de restrição potencial quando compilada em um ambiente em que os tipos de ponteiro, long e int. são amplos de 64 bits",
  "o valor atual do pragma pack é %s",
  "os argumentos para o pragma pack (mostrado) são ignorados",
  null,
  null,
  " __declspec(align(...)) anterior ignorado",
  "esperado um valor de argumento para o parâmetro de atributo %sq",
  "valor de argumento inválido para o parâmetro de atributo %sq",
  "esperado um valor boolean para o parâmetro de atributo %sq",
  "um argumento posicional não pode seguir um argumento nomeado em um atributo",
  "o atributo %sq1 não tem parâmetro nomeado %sq2",
  "esperado uma lista de argumentos para o atributo %sq",
  "esperado um ',' ou ']'",
  "o argumento de atributo %sq já recebeu um valor",
  "um valor não pode ser atribuído ao atributo %sq",
  "uma expressão throw pode não ter um tipo ponteiro para incompleto",
  "operador de alinhamento aplicado ao tipo incompleto",
  "%sq somente pode ser usado como atributo independente",
  "o atributo %sq não pode ser usado aqui",
  null,
  "atributos não são permitidos aqui",
  "valor de argumento inválido para o parâmetro de atributo %sq",
  "muitos argumentos de atributo",
  "a conversão da classe de base inacessível %t não é permitida",
  "option \"export\" requires distinct template signatures",
  "os literais de sequência com tipos de caracteres diferentes não podem ser concatenados",
  "erro de layout GNU não emulado, pois ele coloca a base virtual %no1 fora dos limites de objeto %no2",
  "base virtual %no1 colocada fora dos limites de objeto %no2",
  "nome qualificado não padrão na declaração de membro de namespace",
  "redução em alinhamento ignorada",
  "qualificador const ignorado",
  null,
  "qualificadores asm GNU inválidos",
  "um tipo de classe que não é trivial de ser copiado passou pelas reticências",
  "não é possível buscar por va_arg um tipo de classe que não pode ser copiado de maneira trivial",
  "the \"u\" or \"U\" suffix must appear before the \"l\" or \"L\" suffix in a fixed-point literal",
  "a opção 'fixed_point' pode ser utilizada somente quando se estiver compilando C",
  "o operando inteiro pode causar estouro de ponto fixo",
  "a constante de ponto fixo está fora do intervalo",
  "o valor de ponto fixo não pode ser representado exatamente",
  "a constante é muito grande para 'long long'; tipo 'long long' não atribuído fornecido (não padrão)",
  "o qualificador de layout não pode qualificar o ponteiro para o void compartilhado",
  "THREADS duplicados no tipo de matriz multidimensional",
  "uma diretiva de uso forte somente pode ser exibida em um escopo de namespace",
  "%nf declara uma função não modelo -- adicione <> para fazer referência a uma instância de modelo",
  "a operação pode causar estouro de ponto fixo",
  "a expressão deve ser do tipo integral, de enumeração ou de ponteiro fixo",
  "a expressão deve ter tipo integral ou fixed-point",
  "function declared with \"noreturn\" does return",
  "o nome asm foi ignorado, pois está em conflito com uma declaração anterior",
  "o typedef do membro de classe não pode ser redeclarado",
  "pegando o endereço de um temporário",
  "os atributos são ignorados em uma declaração de classe que não é também uma definição",
  "valor de ponto fixo implicitamente convertido para o tipo de ponto flutuante",
  "os tipos de ponto fixo não têm classificação",
  "um parâmetro de modelo pode não ter o tipo de ponto fixo",
  "as constantes de ponto flutuante hexadecimal não são permitidas",
  "a opção 'named_address_spaces' pode ser utilizada somente quando se estiver compilando C",
  "o valor de ponto flutuante não é adequado ao tipo de ponto fixo necessário",
  "o valor não pode ser convertido ao valor de ponto fixo exatamente",
  "a conversão de ponto fixo resultou em uma mudança de sinal",
  "o valor inteiro não é adequado ao tipo de ponto fixo necessário",
  "o resultado da operação de ponto fixo está fora do intervalo",
  "múltiplos espaços de endereço nomeados",
  "a variável com duração de armazenamento automático não pode ser armazenada em um espaço de endereço nomeado",
  "o tipo não pode ser qualificado com o espaço de endereço nomeado",
  "o tipo de função não pode ser qualificado com o espaço de endereço nomeado",
  "o tipo de campo não pode ser qualificado com o espaço de endereço nomeado",
  "o valor de ponto fixo não é adequado ao tipo de ponto flutuante necessário",
  "o valor de ponto fixo não é adequado ao tipo de inteiro necessário",
  "valor não adequado no tipo de ponto fixo exigido",
  "a opção 'named_registers' pode ser utilizada somente quando se estiver compilando C",
  "uma classe de armazenamento de registro nomeado não é permitida aqui",
  "%nd redeclarado com classe de armazenamento de registro nomeado incompatível",
  "a classe de armazenamento de registro nomeado não pode ser especificada para a variável com alias",
  "o especificador de armazenamento de registro nomeado já está em uso",
  "option \"embedded_c\" cannot be combined with options to control individual Embedded C features",
  "diretório EDG_BASE inválido: %s",
  null,
  "entrada da macro predefinida inválida na linha %s: %s2",
  "nome de modo da macro inválido %sq",
  "redefinição incompatível da macro predefinida %sq",
  "falta uma classe de armazenamento de registro nomeado na redeclaração de %nd",
  "o registro nomeado é muito pequeno para o tipo de variável",
  "as matrizes não podem ser declaradas com a classe de armazenamento de registro nomeada",
  "const_cast para o tipo de enumeração não é padrão",
  "a opção 'embedded_c' pode ser utilizada somente quando se estiver compilando C",
  "um qualificador de espaço de endereço nomeado não é permitido aqui",
  "um inicializador vazio é inválido para uma matriz com vínculo não especificado",
  "a função retorna o tipo de classe incompleto %t",
  "%n já foi inicializado; o inicializador fora da classe será ignorado",
  "a declaração oculta %nd",
  "um parâmetro não pode ser alocado em um espaço de endereço nomeado",
  "sufixo inválido no ponto fixo ou constante de ponto flutuante",
  "uma variável de registro não pode ser alocada em um espaço de endereço nomeado",
  "esperado 'SAT' ou 'DEFAULT'",
  "%n não tem exclusão de operador membro correspondente%s (a ser chamado se uma exceção for posicionada durante a inicialização de um objeto alocado)",
  "a thread-local variable cannot be declared with \"dllimport\" or \"dllexport\"",
  "um tipo de função de retorno não pode ser qualificado com um espaço de endereço nomeado",
  "um inicializador não pode ser especificado para um membro da matriz flexível cujos elementos têm um destruidor não trivial",
  "um inicializador não pode ser especificado para um membro da matriz flexível indireta",
  "número de versão do GNU inválido: %s",
  "os atributos variáveis que são exibidos depois de um inicializador entre parênteses são ignorados",
  "o resultado dessa conversão não pode ser usado como um lvalue",
  "negação de um valor de ponto fixo não atribuído",
  null,
  null,
  "os nomes de registro somente podem ser usados para variáveis de registro",
  "as variáveis de registro nomeado não pode ter tipo void",
  null,
  "os parâmetros não podem ter especificadores de escopo de vínculo",
  "múltiplos especificadores de escopo de vínculo",
  "os especificadores de escopo de vínculo somente são exibidos em funções e variáveis com vínculo externo",
  "uma redeclaração não pode ser um escopo de vínculo fraco",
  "especificador de escopo de vínculo não permitido nessa declaração",
  "nome qualificado não padrão na declaração de escopo global",
  "conversão implícita de um tipo integral de 64 bits para um tipo integral menor (problema de portabilidade potencial)",
  "conversão explícita de um tipo integral de 64 bits para um tipo integral menor (problema de portabilidade potencial)",
  "conversão de ponteiro para tipo integral de mesmo tamanho (problema de portabilidade potencial)",
  null,
  "o especificador friend não é permitido em uma definição de classe; o especificador friend é ignorado",
  "somente variáveis externas e estáticas podem usar o armazenamento local de segmento",
  "múltiplos especificadores de armazenamento local de segmento",
  "virtual %n não foi definido (e não pode ser definido em nenhum outro local, pois é um membro de um namespace não nomeado)",
  "caractere de retorno de carro na linha de origem fora do comentário ou literal de sequência/caractere",
  "a expressão deve ter um tipo de ponto fixo",
  "o uso inválido de especificador de acesso é ignorado",
  "ponteiro convertido para booliano",
  "ponteiro para membro convertido para booliano",
  "especificador de armazenamento ignorado",
  "dllexport e dllimport são ignorados nos modelos de classe",
  "a especificação dllexport/dllimport de classe de base é diferente da especificação da classe derivada",
  "a redeclaração não pode adicionar dllexport/dllimport ao %nod",
  "dllexport/dllimport em conflito com %nod; dllexport assumido",
  "não é possível definir a entidade dllimport",
  "dllexport/dllimport exige vínculo externo",
  "um membro de uma classe declarada com dllexport/dllimport não pode ser declarado com tal especificador",
  "campo do tipo de classe sem uma interface DLL usada em uma classe com uma interface DLL",
  "a declaração de membro entre parênteses não é padrão",
  "o espaço em branco entre a barra invertida e a nova linha em uma união de linha é ignorado",
  "dllexport/dllimport em conflito com %nod; dllimport/dllexport ignorado",
  "membro inválido para a classe de membro anônima -- a classe %t tem uma função de membro não permitida",
  "reinterpret_cast não padrão",
  "o especificador de formato posicional não pode ser zero",
  "uma classe local não pode fazer referência a um tipo de matriz de comprimento variável de uma função delimitadora",
  "o membro %nd já tem um especificador dllexport/dllimport explícito",
  "uma matriz de comprimento variável não é permitida em um tipo de retorno de função",
  "o tipo de matriz de comprimento variável não é permitido no ponteiro para membro do tipo %t",
  "o resultado de uma expressão de instrução não pode ter um tipo que envolve uma matriz de comprimento variável",
  "o suporte a trígrafos está desabilitado",
  "o atributo %sq somente pode ser exibido nas funções e variáveis com vínculo externo",
  "o modo estrito é incompatível com o tratamento do namespace padrão como um alias para o namespace global",
  "na expansão da macro '%s' %p",
  "<DESCONHECIDO>",
  "",
  "[ %d expansões de macro não mostradas ]",
  "na expansão da macro em %p",
  "nome de operando simbólico inválido %sq",
  "uma restrição de correspondência simbólica deve fazer referência a um dos primeiros dez operandos",
  "o uso de __if_exists não é suportado nesse contexto",
  "bloco __if_exists não fechado no mesmo escopo no qual foi aberto",
  "a variável local de segmento não pode ser inicializada dinamicamente",
  "conversion drops \"__unaligned\" qualifier",
  "alguns valores de enumerador não podem ser representados pelo tipo integral que destaca o tipo de enumeração",
  "o argumento padrão não é permitido em uma declaração de modelo de classe friend",
  "literal de caractere de múltiplos caracteres (problema de portabilidade potencial)",
  "esperado um tipo de classe, struct, ou union",
  "o segundo operando de offsetof deve ser um campo",
  "o segundo operando de offsetof pode não ser um campo de bit",
  "não é possível aplicar offsetof a um membro de uma base virtual",
  "offsetof aplicado a um tipo diferente de uma classe de layout padrão",
  "os argumentos padrão não são permitidos em uma declaração de friend de uma função membro",
  "argumentos padrão não são permitidos em declarações de friend que não são definições",
  "redeclaração de %nd anteriormente declarada como um friend com argumentos padrão não é permitida",
  "qualificador inválido para %t (uma classe derivada não é permitida aqui)",
  "qualificador inválido para a definição de classe %t",
  "nenhum push_macro anterior para %sq",
  "literal de sequência ampla não permitido",
  null,
  "%sq é somente permitido em C",
  "__ptr32 and __ptr64 must follow a \"*\"",
  "__ptr32 e __ptr64 não podem ser aplicáveis",
  "a lista de argumento do modelo de %sq deve corresponder à lista de parâmetro",
  "um tipo de classe incompleto não é permitido",
  "os tipos integrais complexos não são suportados",
  "__real e __imag somente podem ser aplicáveis a valores complexos",
  "__real/__imag aplicado ao valor real",
  "%nd foi declarado obsoleto (%sq)",
  "redefinição inválida de %nd",
  "dllimport/dllexport aplicado a um membro de um namespace não nomeado",
  "__thiscall somente pode ser exibido em declarações de função de membro não estático",
  "__thiscall não permitido na função com parâmetro de elipse",
  "especialização explícita de %n deve preceder seu primeiro uso (%p)",
  "um tipo de classe selado não pode ser usado como uma classe de base",
  "modificador de classe duplicado",
  "a member function cannot have both the \"abstract\" and \"sealed\" modifiers",
  "um membro selado não pode ser virtual puro",
  "nonvirtual function cannot be declared with \"abstract\" or \"sealed\" modifier",
  "uma função membro declarada como 'prioritária' não possui prioridade sobre um membro da classe base",
  "não é possível substituir %nd selado",
  "%nd was declared with the class modifier \"abstract\"",
  "na linha ",
  " de ",
  "com ",
  "palavra-chave",
  "macro",
  "rótulo",
  "parâmetro de template",
  "tipo",
  "união",
  "classe",
  "struct",
  "parâmetro de modelo",
  "modelo",
  "modelo de classe",
  "enumeração",
  "parâmetro",
  "parâmetro de manipulador",
  "variável",
  "sem tipo",
  "constante",
  "função",
  "função sobrecarregada",
  "membro",
  "campo",
  "namespace",
  "registro nomeado",
  "espaço de endereçamento nomeado",
  "modelo de função",
  "baseado no argumento do modelo",
  "baseado nos argumentos do modelo",
  " (declarado ",
  "(no final da fonte)",
  "No final da fonte",
  "Linha",
  "linha",
  "col.",
  "observação",
  "Observação",
  "aviso",
  "Aviso",
  "erro",
  "Erro",
  "erro catastrófico",
  "Erro catastrófico",
  "erro de linha de comando",
  "Erro de linha de comando",
  "erro interno",
  "Erro interno",
  null,
  null,
  "Limite de erro atingido.",
  "Laço de erro interno",
  "Laço no processamento de erro catastrófico.",
  null,
  "temporário",
  "saída de pré-processamento",
  "listagem bruto",
  "referência cruzada",
  "linguagem intermediária (1)",
  "linguagem intermediária (2)",
  "linguagem intermediária (3)",
  "linguagem intermediária (4)",
  "linguagem intermediária (5)",
  "linguagem intermediária (6)",
  "linguagem intermediária (7)",
  "linguagem intermediária (8)",
  "linguagem intermediária (9)",
  null,
  null,
  null,
  null,
  null,
  "faltando sinalização de não pode definir novamente",
  "faltando modo depois de ','",
  "faltando nome da macro",
  "valor de não pode definir novamente inválido",
  "modificador de função duplicado",
  "caractere inválido para literal char16_t",
  null,
  "convenção de chamadas não reconhecida %s, deve ser um dos:",
  null,
  null,
  null,
  "o tipo subjacente da enumeração deve ser integral",
  "algumas constantes enumeradoras não podem ser representadas por %t",
  "%sq não permitido no modo atual",
  "a opção de auxiliares de características de tipo pode ser usada apenas ao compilar C++",
  "attribute \"sentinel\" requires an ellipsis parameter",
  "o argumento deve ser um valor de ponteiro nulo e constante",
  "número insuficiente de argumentos para o valor de sentinela",
  "o argumento sentinel deve corresponder a um parâmetro de elipse",
  "__declspec(implementation_key(...) pode ser exibido apenas entre #pragma start_map_region e #pragma stop_map_region",
  "#pragma start_map_region já ativo: pragma ignorado",
  "nenhum #pragma start_map_region está ativo atualmente: pragma ignorado",
  "%n não pode ser usado para nomear um destruidor (um nome de tipo é exigido)",
  "nonstandard empty wide character literal treated as L\"\\0\"",
  "\"typename\" may not be specified here",
  "uma exclusão de operador sem posicionamento deve ser visível em uma classe com um destruidor virtual",
  "conflitos de vínculo de nome com a declaração anterior de %nd",
  "o alias cria um ciclo de entidades que sofreram alias",
  null,
  "uma variável com duração de armazenamento estático alocada em um registro específico não pode ser declarada com um inicializador",
  "uma variável alocada em um registro específico deve ser copiada de maneira trivial",
  "significado predefinido de %no descartado",
  null,
  "tipo de classe não adequado para uso com designadores",
  null,
  "o qualificador de união anônimo está fora do padrão",
  "o qualificador de união anônimo é ignorado",
  null,
  "__declspec(%s) ignorado (ele não tem significado para um struct C)",
  "os especificadores após a vírgula entre declarações estão fora do padrão",
  "especificador fora do padrão ignorado",
  "os atributos são ignorados em uma declaração de enumeração que não é também uma definição",
  "a declaração de uma referência com 'mutável' está fora do padrão",
  "uma declaração de condição para uma matriz é sempre verdadeira",
  "asserção estática falhou com %sq",
  "atributo de visibilidade ignorado porque entra em conflito com uma declaração anterior",
  "o nome do campo resolve para mais de uma compensação -- consulte %nod1 e %nod2",
  "%sq não é um nome de campo",
  "o valor do rótulo case já apareceu neste comutador %p",
  "uma função membro não pode ter um vínculo interno",
  "a declaração esconde um %n interno",
  "a declaração sobrecarrega o %n interno",
  "a opção de listar definições de macro pode não ser especificada quando se compila mais de uma unidade de tradução",
  "parêntese inesperado após a declaração de %n (lista de parâmetros mal formada ou inicializador inválido?)",
  "os parênteses ao redor de um inicializador de cadeia estão fora do padrão",
  "__interface",
  "uma variável declarada com um especificador de tipo automático não pode aparecer no seu próprio inicializador",
  "não é possível deduzir o tipo 'auto'",
  "a inicialização com '{...}' não é permitida para o tipo 'auto'",
  "o tipo 'auto' não pode aparecer em um tipo de matriz de nível superior",
  "o tipo 'auto' não pode aparecer em uma tipo de função de nível superior",
  "um membro de tipo %t não pode ter um inicializador na classe",
  "um membro com um inicializador na classe deve ser const",
  "não é possível deduzir o tipo 'auto' (é necessário um inicializador)",
  "o tipo 'auto' é %t1 para esta entidade, mas foi anteriormente sugerido como sendo %t2",
  "declaração de construtor inválida",
  "uso inválido de um qualificador de tipo",
  "uma união não pode ser abstrata nem selada",
  "'auto' não é permitido aqui",
  "definição do tipo de classe base ainda não completada",
  "o 'modelo externo' não pode se referir a uma especialização de %nd estático",
  "o 'modelo externo' não pode seguir a instanciação explícita de %n",
  "__declspec(restrict) exige uma função que retorne um tipo de ponteiro",
  "a opção 'report_gnu_extensions' somente é válida nos modos GNU C e GNU C++",
  "os tipos de matriz de comprimento variável estão fora do padrão",
  "os designadores estão fora do padrão",
  "esta sintaxe de designador é uma extensão GNU",
  "literais compostos estão fora do padrão",
  "as expressões da instrução são uma extensão GNU",
  "nome asm ignorado para a entidade anteriormente definida",
  "os atributos são uma extensão GNU",
  "a sintaxe asm estendida é um recurso GNU",
  "declarações asm voláteis são uma extensão GNU",
  "os especificadores do nome asm são uma extensão GNU",
  "o qualificador '__restrict' está fora do padrão",
  "'tipeof' é uma extensão GNU",
  "modificar o tamanho ou sinal de um typedef está fora do padrão",
  "matrizes com tamanho zero são uma extensão GNU",
  "membros da matriz flexível estão fora do padrão",
  "o atributo 'nonnull' faz referência a um parâmetro nonpointer",
  "o argumento para o atributo 'nonnull' é maior que o número de parâmetros",
  "nenhum parâmetro tem tipo de apontador",
  "argumento nulo fornecido para parâmetro marcado com atributo 'nonnull'",
  "o destruidor para %t1 foi suprimido porque o destruidor para %t2 está inacessível",
  "o destruidor para %t suprimido é necessário",
  "rotina é tanto \"em linha\" quanto \"não em linha\"",
  "rotina de limpeza inválida",
  "o atributo 'cleanup' exige duração de armazenamento automática",
  "o atributo 'cleanup' não se aplica aos parâmetros",
  "a rotina de limpeza tem um tipo inválido",
  "a chamada da rotina de limpeza exige uma conversão suspeita",
  "__sptr e __uptr devem seguir um '*'",
  "__sptr e __uptr não podem ser ambos especificados",
  "a conversão do apontador de alargamento de %t1 para %t2 aumenta o bit de sinal",
  "__sptr e __uptr não se aplicam a tipos ponteiro para membro",
  "a declaração do operador de atribuição de cópia para %t foi suprimida porque %n é const",
  "a declaração do operador de atribuição de cópia para %t foi suprimida porque %n tem um tipo de referência",
  "a declaração do operador de atribuição de cópia para %t1 foi suprimida porque a de %t2 foi suprimida",
  "a declaração do operador de atribuição de cópia para %t1 foi suprimida porque a de %t2 é ambígua",
  "a declaração do operador de atribuição de cópia para %t1 foi suprimida porque a de %t2 está inacessível",
  "a declaração do construtor de cópia para %t1 foi suprimida porque a de %t2 foi suprimida",
  "a declaração do construtor de cópia para %t1 foi suprimida porque a de %t2 é ambígua",
  "a declaração do construtor de cópia para %t1 foi suprimida porque a de %t2 está inacessível",
  "o destruidor para %t1 não será chamado porque está inacessível e o destruidor para %t2 foi suprimido",
  "definição no fim do arquivo não seguida por ponto e vírgula ou um declarador",
  "o primeiro argumento deve ser do tipo ponteiro para número inteiro ou enumeração",
  "as operações sincronizadas são válidas somente em objetos de tamanho 1, 2, 4 ou 8",
  "argumentos extras ignorados",
  "'=' presumido seguindo um nome de macro %sq na definição da linha de comando",
  "é necessário um espaço em branco entre o nome do macro %sq e o seu texto de substituição",
  "o resultado da chamada não é usado",
  "o atributo 'warn_unused_result' é ignorado para o tipo de retorno nulo",
  null,
  "dllimport/dllexport é ignorado na redeclaração usando um nome qualificado",
  "excesso de caracteres no literal de caracteres -- os caracteres iniciais em excesso serão ignorados",
  "%n não pode ser declarado de modo embutido após sua definição %p",
  null,
  null,
  "um argumento de modelo pode não fazer referência a um tipo sem vínculo de nome",
  "'virtual' é ignorado aqui",
  "um argumento de modelo pode não fazer referência a um tipo de matriz de tamanho variável",
  "um nome de caractere universal não pode designar um ponto de código alternativo",
  "#include_next não pode ser usado no arquivo de origem primário",
  "%no1 não pode ser especificado em uma definição de membro modelo – %no2 presumido no lugar",
  "o atributo %sq é ignorado na declaração da função local",
  "a concatenação com %sq em %n não cria um token válido",
  "%no é ambíguo (%n2 presumido)",
  "um qualificador de tipo não é permitido em uma função de membro estática",
  "um qualificador de tipo não é permitido em um construtor ou destruidor",
  "um qualificador de tipo não é permitido em operador new ou operador delete",
  "um qualificador de tipo não é permitido em uma função não membro",
  "o argumento para %s tem efeitos colaterais, mas não é avaliado",
  "tipo de origem de Unicode não reconhecido (deve ser UTF-8, UTF-16, UTF-16LE ou UTF-16BE): %s",
  "Caractere Unicode com valor hex %s não representável na saída de pré-processamento",
  "a prioridade solicitada do construtor/destruidor é reservada para uso interno",
  "pragma de GCC não reconhecido",
  "diretiva de pragma de visibilidade GCC não reconhecida",
  "tipo de visibilidade não reconhecido",
  "o pragma de visibilidade ainda está ativo",
  "sem push de visibilidade correspondente",
  "typeid de tipo incompleto",
  null,
  "presume-se que a matriz %n tenha um elemento",
  "o atributo vector_size exige um tipo aritmético ou de enumeração",
  "o tamanho do vetor é excessivamente grande",
  "o número de elementos em um vetor deve ser uma potência de dois",
  "o tamanho do vetor deve ser um múltiplo do tamanho do elemento",
  "operação escalar de vetor misturado não permitida",
  "a operação exige dois vetores do mesmo tamanho",
  "o tamanho de vetor dependente de modelo não é permitido",
  null,
  null,
  "o atributo vector_size não é permitido com um tipo de elemento complexo",
  null,
  "a operação do vetor exige tipos de elementos idênticos",
  "a operação do vetor não se aplica a vetores com tipo não integral",
  "não é possível abrir o arquivo %s %sq2",
  "não é possível abrir o arquivo %s %sq2: %s3",
  "cabeçalho pré-compilado",
  "macro predefinido",
  "C gerado",
  "C++ gerado",
  "fonte",
  "erro ao gravar o arquivo %s: %s2",
  "não é um arquivo regular",
  "é um diretório",
  "nome de arquivo inválido",
  "lista de definições",
  "solicitação de instanciação",
  "modelo exportado",
  "exportar informações",
  "informações de modelo",
  "saída de IL",
  "a conversão remove o qualificador '__restrict'",
  "não foi possível obter memória mapeada para %sq: %s2",
  "o qualificador restrito é ignorado",
  null,
  "a matriz de elementos contendo um membro de matriz flexível está fora do padrão",
  "um parâmetro de modelo pode não ter um tipo de vetor",
  "a inicialização de %n1 será feita antes da de %n2",
  null,
  "o tipo de herança é ignorado em um especificador de enumeração",
  null,
  "o modificador é ignorado em um especificador de enumeração",
  "o identificador de caracteres não pode ser representado em Unicode",
  "o nome do cabeçalho contém caracteres que não podem ser representados em Unicode",
  "%sq não é um nome de localização válido",
  "a declaração de uma lista de parâmetros nula com um parâmetro de modelo está fora do padrão",
  "a opção de lambdas pode ser utilizada somente quando se estiver compilando C++",
  "a captura explícita corresponde ao padrão",
  "%n não é uma variável",
  "uma variável com duração de armazenamento estática não pode ser capturada em um lambda",
  "'este' não pode ser capturado por referência",
  "'este' não pode ser usado dentro do corpo deste lambda",
  "um membro de uma união anônima de escopo externo não pode ser referenciado dentro do corpo de um lambda",
  "uma variável local com função de delimitação não pode ser referenciada em um corpo de lambda, a menos que esteja na lista de captura",
  "referência inválida para uma variável local fora do escopo em um corpo lambda",
  "uma variável local fora do escopo da função atual não pode ser capturada",
  "a função de delimitação 'este' não pode ser referenciada em um corpo lambda a menos que esteja na lista de captura",
  null,
  "A variável capturada por lambda de tipo %t1 não pode ser copiada para o campo de classe de fechamento de tipo %t2",
  "diretório de modelos inválido: %s",
  "erro",
  "erros",
  "erro catastrófico",
  "erros catastróficos",
  "e",
  "detectado na compilação de '%s'.",
  "detectado nessa compilação.",
  "o valor de enumeração está fora da faixa do seu tipo subjacente (%t)",
  "'\\' seguido de um espaço em branco não é uma união de linha",
  "este dynamic_cast não pode ser feito sem informações de tipo de tempo de execução, que estão desabilitadas",
  "a conversão para %t é ambígua; base direta selecionada",
  "um buffer interno seria excessivamente grande",
  "manipulador de exceção C++ foi utilizado, mas a semântica do tratamento de exceção não foi especificada",
  "qualificador de tipo ignorado no construtor",
  "uma variável capturada por um lambda não pode ter um tipo que envolva uma matriz de tamanho variável",
  "conversão entre tipos de vetores incompatíveis",
  "esperado um '{' introduzindo um corpo lambda",
  "opção de referências de rvalue pode ser utilizada somente quando se estiver compilando C++",
  "um qualificador de tipo não é permitido em um lambda",
  "um nome não pode aparecer mais de uma vez em uma lista de captura",
  "argumentos explícitos de modelo ignorados",
  "um lambda não é permitido em uma expressão constante",
  "%t não é um tipo de classe",
  "'delete' aplicado a um tipo ponteiro para matriz tratado como delete[]",
  "'delete' aplicado a um tipo ponteiro para matriz está fora do padrão; tratado como delete[]",
  "%n não pode ser chamado com a lista de argumentos dada",
  "uma referência de rvalue não pode ser limitada a um lvalue",
  "um parâmetro de modelo sem tipo não pode ter um tipo de referência rvalue",
  "qualificadores de tipo são ignorados (o tipo subjacente é uma referência)",
  "%n, declarado usando um tipo local, deve ser definido nesta unidade de tradução",
  "%n, declarado usando um tipo sem vínculo, deve ser definido nesta unidade de tradução",
  "o operando de uma referência rvalue dynamic_cast deve ter um tipo de classe completo",
  "'= default' somente pode aparecer em construtores padrão, construtores copy/move, operadores de atribuição copy/move e destruidores",
  "'= delete' somente pode aparecer na primeira declaração de uma função",
  "%npd não pode ser referenciado – é uma função excluída",
  "um lambda não é permitido em uma expressão não avaliada",
  "__builtin_va_arg_pack/__builtin_va_arg_pack_len somente pode aparecer em uma função embutida com um parâmetro de reticências",
  "'= default' não pode ser especificada em uma declaração de friend",
  "esperado uma palavra-chave C++",
  null,
  "deslocamento não é constante",
  "tipo de comentário #pragma não reconhecido %sq",
  "opção para controlar se 'auto' é um especificador de tipo pode ser utilizada somente quando estiver compilando em C++",
  "opção para controlar se 'auto' é uma classe de armazenamento pode ser utilizada somente quando estiver compilando em C++",
  "os significados de 'auto' como especificador de tipo e especificador de classe de armazenamento não podem ser ambos desabilitados",
  "cadeia de caracteres inválida no comentário de #pragma",
  "função excluída sobrescreve %n não excluída",
  "função não excluída sobscreve %n excluída",
  "o construtor padrão de %t não pode ser referenciado -- ele é uma função excluída",
  "uma referência rvalue não é permitida como tipo catch",
  "argumento padrão de %n é incompatível com uma declaração em outra unidade de tradução",
  "os argumentos padrão de %n estavam diferentes durante a compilação de %sq",
  null,
  "o inicializador para %n é diferente em outra unidade de tradução",
  "o inicializador para %n estava diferente durante a compilação de %sq",
  "não é permitido um designador em um tipo dependente de modelo",
  "tipo de conformação não reconhecido",
  "esperado 'on' ou 'off'",
  "A pilha de #pragma conform(forScope) está vazia",
  "nenhuma entrada de #pragma conform(forScope) corresponde a %sq",
  "o comportamento do forScope é não padrão",
  "o comportamento do forScope é padrão",
  "função 'main' não pode ser excluída",
  "qualificadores de tipo são sem sentido aqui",
  "tipo inválido para operador de atribuição padronizado",
  "modelos de funções não podem ser padronizados",
  "tipo inválido para construtor padronizado",
  "chamada da função requer um argumento",
  "chamada da função requer um argumento de ponto flutuante",
  "um construtor de cópia com um argumento padrão não pode ser padronizado",
  "uma função pré-declarada não pode ser excluída",
  "instrução dependente vazia em uma instrução if",
  "instrução dependente vazia em cláusula 'else' de uma instrução if",
  "%nfd, obrigatório para a cópia que foi excluída, não pode ser referenciado – ele é uma função excluída",
  "primeiro parâmetro %t de 'main' fora do padrão, esperado 'int'",
  "número de parâmetros para 'main' fora do padrão, esperado zero ou dois parâmetros",
  "segundo parâmetro %t de 'main' fora do padrão, esperado 'char *[]' ou 'char **'",
  "%sq foi especificado tanto como um diretório de inclusão do sistema quanto não do sistema – a entrada que não é do sistema será ignorada",
  "a opção para controlar construtores de movimento e operadores de atribuição de movimento pode ser utilizada somente quando se estiver compilando C++",
  null,
  null,
  "um tipo de retorno à frente exige o especificador de tipo 'auto'",
  "um tipo de retorno à frente pode não aparecer em um declarador aninhado",
  "um declarador de função com um tipo de retorno à frente deve ser precedido por um especificador simples de tipo \"auto\"",
  "função 'auto' requer um tipo de retorno à frente",
  "um modelo de membros não pode ter um especificador puro",
  "string literal muito longa - caracteres excedentes ignorados",
  "a opção para controle a palavra-chave nullptr pode ser utilizada somente quando se estiver compilando C++",
  "std::nullptr_t convertido para bool",
  null,
  null,
  "o atributo %sq não permite que a lista de argumentos esteja vazia",
  "o atributo aparece mais de uma vez",
  "o atributo %sq não é aplicável aqui",
  "o atributo %sq não se aplica campos de bits",
  "o atributo %sq requer um campo de bits",
  "o atributo %sq não se aplica a funções membro",
  "o atributo %sq requer uma função membro",
  "o atributo %sq não se aplica a funções virtuais",
  "o atributo %sq requer uma função virtual",
  "o atributo %sq não é aplicável a funções virtual puras",
  "o atributo %sq requer uma função virtual pura",
  "o atributo %sq não se aplica a variáveis register",
  "o atributo %sq requer uma variável register",
  "o atributo %sq não aparece na declaração original",
  "atributos não são permitidos aqui",
  "o atributo %sq deve aparecer em uma definição de classe",
  "final atribuído a uma função virtual pura",
  "não foi possível substituir \"final\" %nd",
  "static %n considerado externo por ter sido referenciado, mas não definido",
  "só é possível a opção de ativar indentação no estilo GNU-C89 ao compilar C",
  "função previamente declarada sem o atributo \"gnu_inline\"",
  "o atributo \"gnu_inline\" foi ignorado nas funções non-inline",
  "%n já foi declarado anteriormente sem o atributo carries_dependency",
  "inicializador inválido para a matriz %n",
  "é preciso especificar o modo C++11 ou C++14 ao compilar a biblioteca de tempo de execução",
  "o atributo %sq não se aplica a tipos de funções",
  "o atributo %sq requer um tipo de função",
  "o atributo %sq não se aplica a funções membro não static",
  "o atributo %sq não se aplica a variáveis automáticas",
  "o atributo %sq requer uma variável automáticas",
  "o atributo %sq não é aplicável a uma variável ou função com vínculo externo",
  "o atributo %sq requer uma variável local",
  "os atributos são ignorados aqui",
  "o atributo não se aplica a entidade alguma",
  "substituição de argumento de atributo incorreta",
  "o argumento do atributo \"tls_model\" deve ser \"global-dynamic\", \"local-dynamic\", \"initial-exec\" ou \"local-exec\"",
  "a declaração %p especificou um argumento \"tls_model\" diferente",
  "o atributo %sq não se aplica a funções em linha",
  "o atributo %sq requer uma função em linha",
  "ambos os nomes de arquivos em um pragma include_alias devem usar os mesmos caracters de delimitação",
  "comparação entre operadores com e sem assinatura",
  "atributo %sq ignorado em tipo não nomeado",
  "atributo %sq ignorado por falta de definição",
  "localização do thread não é compatível com uma declaração anterior de %nd",
  "esta variável local de função delimitadora não pode ser referenciada neste corpo lambda pois um lambda delimitador não permite capturas implícitas",
  "este argumento de atributo contém parênteses, colchetes ou chaves sem par",
  "um chamada a __builtin_fpclassify requer cinto argumentos inteiros seguidos de um argumento ponto-flutuante",
  "o último argumento de um chamada a __builtin_fpclassify deve ter tipo real ponto-flutuante",
  "o alinhamento não pode ser definido como menos que o alinhamento padrão",
  "atributos não são permitidos em instanciações explícitas",
  "o atributo %sq não se aplica uma definição",
  "o atributo %sq requer uma definição",
  "atributos padrão não aparecem em declarações de friend que não são definições",
  "o alinhamento especificado (%s1) é diferente do alinhamento (%s2) especificado por uma declaração anterior",
  "o atributo de alinhamento também deve aparecer na definição %p",
  "%n não pode ser usado como type-id de alias-declaration",
  "modelo de alias",
  "%t não pode ser transparente porque seu primeiro campo possui tipo ponto flutuante",
  "%t não pode ser transparente porque seu primeiro campo é um campo de bits",
  "a função de uma classe \"base_check\" substitui um membro de classe base mas não possui o atributo \"substituir\"",
  "atributo \"ocultar\" especificado em uma declaração que não oculta uma declaração de classe base",
  "atributo \"ocultar\" especificado por uma declaração à qual se refere a declaração using %p",
  "o atributo \"ocultar\" é necessário para uma declaração (em uma classe \"base_check\") que oculte %nd",
  "%n não está definido neste unidade de tradução, mas depende de um tipo local",
  "%n não está definido nesta unidade de tradução, mas depende de um tipo sem vínculo",
  "o atributo %sq está ausente em uma outra unidade de tradução",
  "o atributo %sq conflita com outra unidade de tradução",
  "a opção 'nonstd_gnu_keywords' só é válida nos modos GNU C e GNU C++",
  "o uso de variável const em uma expressão constante não é padrão em C",
  "não foi possível especificar um inicializado para um membro de matriz flexível com duração de armazenamento automática",
  null,
  "o tipo de classe 'final' não pode ser usado como classe base",
  "modelos exportados não estão mais na linguagem C++ padrão",
  "não são permitidos designadores dependentes do modelo",
  "o segundo operando de offsetof não pode ser um campo com tipo referência",
  "temporários de vida longa são incompatíveis com outros recursos mais recentes de linguagens que foram requisitados",
  "string de caracteres largos literal não será citada nos diagnósticos",
  "argumentos faltantes para o atributo %sq",
  "as opções \"c++11' e \" c++11_sfinae\" demandam uma configuração diferente do compilador",
  "pacote de modelos de parâmetros fora do final da lista de parâmetros",
  "não é permitida uma declaração de pacote genérica aqui",
  "pacotes de parâmetros não podem ter um default",
  "C++/ CLI podem ser ativados apenas no modo do Microsoft C++",
  "'value__' não pode ser usado como nome para uma constante de enumerador (é um nome reservado neste contexto)",
  "é necessário um valor explícito de enumerador em um tipo de enumerador com tipo subjacente booleano",
  null,
  "o pacote de parâmetros %sq foi citado, mas não expandido",
  "o pacote de expansão não utiliza nenhum dos pacotes de argumentos",
  "o pacote %sq não tem o mesmo número de elementos de %sq2",
  null,
  "o atributo vector_size não é permitido com um tipo de enumeração",
  "uma propriedade não pode ser ao mesmo tempo estática e virtual",
  "uma propriedade indexada não pode ser trivial",
  "esta declaração não pode aparecer em uma definição de propriedade",
  "não se pode usar um tipo qualificado de função para declarar uma função de acessador",
  "uma função de acessador não pode ter parâmetros de reticências",
  "já foi declarado um acessador 'get' para a propriedade %p",
  "já foi declarado um acessador \"set\" para esta propriedade %p",
  "um acessador \"get\" não pode ter parâmetros",
  "o tipo de retorno do acessador \"get\" não combina com o tipo da propriedade",
  "o tipo de saída do acessador \"set\" deve ser vazio",
  "uma propriedade não pode declarar uma lista vazia de índices",
  "um índice de uma propriedade não pode ter tipo vazio",
  "o tipo de índice não é o tipo do parâmetro correspondente no acessador \"set\"",
  "o tipo de índice não é o tipo do parâmetro correspondente no acessador \"get\"",
  "falta o tipo de índice no acessador \"set\"",
  "falta o tipo de índice no acessador \"get\"",
  "falta o parâmetro de valor no acessador \"set\"",
  "a função de acessador possui parâmetros demais",
  "o último parâmetro do acessador \"set\" não corresponde ao tipo de propriedade",
  "%sq requer modo C++/CLI",
  "erro na API do Win32 '%s': %s",
  "#using só pode ser usado no escopo global",
  "metadados",
  "o nome de membro %sq está reservado por %nd",
  "um ' [' é esperado",
  "modo %[C++/CLI] requer microsoft_version >=1600",
  "uma propriedade indexada por default não pode ser estática",
  "um acessador de propriedade não pode ser ao mesmo tempo estático e virtual",
  "especificadores de visibilidade de nível superior não podem aparecer em declarações de tipo aninhadas",
  "um especificador de visibilidade de nível superior requer uma definição de tipo",
  "uma propriedade trivial não pode possuir um tipo de referência",
  "uma propriedade trivial não pode ter um tipo const ou volátil",
  "%nd foi declarado anteriormente como um tipo diferente do tipo de enumeração",
  "uma variável capturada por um lambda não pode ter um tipo de classe %[managed]",
  "substituição de funções com tipos de saída covariantes não são permitidos em classes %[managed]",
  "matrizes de controladores não são permitidas",
  "identificadores de matrizes não são permitidos",
  "controladores para funções não são permitidos",
  "identificador para nulo não é permitido",
  "identificador para identificador, para ponteiro ou referência não é permitido",
  "não é permitido rastreamento de referências a funções",
  null,
  "um campo não pode ser uma referência de rastreamento",
  "uma referência de rastreamento não pode ser combinada dessa forma com uma referência comum",
  "uma variável com duração de armazenamento estática não pode ter tipo de classe ref",
  "uma classe %[managed] não pode ser sem nome",
  "uma classe %[managed] não pode ser local",
  "%nf foi declarado anteriormente como um tipo diferente de classe",
  "%nd foi declarado anteriormente como um tipo diferente de modelo de classe",
  "membros de dados literais só podem ser membros de classes %[managed]",
  "um membro de dados literais deve ser inicializado",
  "não são permitidos membros de dados literais do tipo %t",
  "const não tem efeito sobre membros de dados literais",
  "membros de dados initonly só podem ser membros de classes %[managed]",
  "const não tem efeito sobre membros de dados initonly",
  "%nd não possui nenhum acessador \"get\"",
  "%nd não possui nenhum acessador \"set\"",
  "construtores estáticos não podem ter parâmetros",
  "construtores estáticos não podem ser modelos de membros",
  "não é permitido um lvalue composto como um operando de saída asm",
  "propriedades só podem ser membros de classes %[managed]",
  "qualificadores de tipo não são permitidos em funções de membros de classes %[managed]",
  "apontadores ordinários para uma classe ref %[C++/CLI] ou classe de interface não são permitidos",
  "não são permitidas referências ordinárias para classes ref %[C++/CLI]",
  "o especificador de substituição não nomeia uma função de membro de classe base",
  "o especificador de substituição designa um membro não virtual %nd",
  "uma função membro substitui %nd1 que já é substituída por %nd2",
  "é permitido no máximo um especificador de visibilidade",
  "o tipo %t usado para definição de delegados não é um tipo de função",
  "membros de tipos delegados só podem ser membros de classes %[managed]",
  "referências de rastreamento para tipos delegados não são permitidas",
  "tipos delegados são permitidos aqui",
  "esta expansão de pacote produziu uma lista vazia de expressões, e é necessária ao menos uma expressão",
  "um evento não pode ser ao mesmo tempo estático e virtual",
  "eventos só podem ser membros de classes %[managed]",
  "esta declaração não pode aparecer em uma definição de evento",
  "tipo de evento deve ser um tipo handle-to-delegate",
  "já foi declarado um acessador \"add\" para este evento %p",
  "já foi declarado um acessador \"remover\" para este evento %p",
  "já foi declarado um acessador \"elevar\" para este evento %p",
  "um acessador do evento não pode ser ao mesmo tempo estático e virtual",
  "o tipo de retorno dos acessadores \"add\" e \"remove\" deve ser void",
  "um acessador de eventos está sem seu parâmetro de valor",
  "a função de acessador possui parâmetros demais",
  "o tipo %t1 do parâmetro do acessador de eventos não corresponde ao tipo de evento (%t2)",
  "o tipo do acessador \"raise\" não corresponde ao tipo de invocação do delegado do evento",
  "uma definição de evento deve incluir tanto acessadores \"add\" e \"remove\"",
  "uma função de conversão estática deve aceitar exatamente um argumento",
  "operador estático deve ter tipo de parâmetro T, T&, T%%, ou T^ com T = %t",
  "o operando de sizeof... deve ser um nome de parâmetro de pacote",
  "o operador de sizeof... pode ser usado somente em um modelo variadic",
  "o nome do evento não pode aparecer aqui",
  "não são permitidos identificadores para classes não %[managed]",
  "não permitidos identificadores para tipo de enumeração sem escopo",
  "o atributo 'property' não é permitido em uma classe %[managed]",
  "um especificador puro ('= 0') seguido de definição não é padrão",
  "o tipo %[managed] nullptr não pode ser usado aqui",
  "o operador \" não pode ser usado para tomar o endereço de um objeto com tipo de classe ref",
  "matrizes de classes %[managed] não são permitidas",
  "variáveis com duração estática de armazenamento não pode ter um identificador ou um tipo de rastreamento de referência",
  "variáveis capturadas por um lambda não podem ser identificadores nem rastreadores de referências",
  "matrizes de parâmetros %[C++/CLI] requerem identificadores de tipo %[cli::array] unidimensionais",
  "não foi possível importar metadados do arquivo %sq",
  "o namespace cli não pode ser estendido",
  "o tipo de elemento de %[cli::array] deve ser um tipo de identificador ou valor",
  "número inválido de dimensões para o tipo %[cli::array]",
  "um cli::interior_ptr/cli::pin_ptr deve apontar para uma classe padrão, uma classe de valor, um número inteiro, um identificador ou um ponteiro padrão",
  "%t não pode ser um membro de classe",
  "não é permitido um parâmetro do tipo cli::pin_ptr",
  "declaração de finalizador inválida",
  "um finalizador não pode ter parâmetros",
  "não é permitido qualificador de tipo em um finalizador",
  "não se pode especificar tipo de retorno em um finalizador",
  "declarações using não podem nomear finalizadores",
  "nomes de finalizadores devem ser qualificados",
  "o qualificador do nome de finalizador %t1 não corresponde ao tipo %t2",
  "%n não pode ser usado para nomear um finalizador (nome de tipo necessário)",
  "nome de finalizador inválido para o tipo %t",
  "a referência do finalizador é ambígua - %n1 e %n2 poderiam ambos ser usados",
  "um finalizador só pode ser um membro de uma classe ref",
  null,
  "tipo usado como nome de finalizador não corresponde ao tipo %t",
  "não existe um finalizador para este tipo",
  "o operador \"%%\" só pode ser usado em objetos com tipo de classe %[managed]",
  "não permitidos ponteiros, identificadores ou referências a cli::interior_ptr",
  "não permitidos ponteiros, identificadores ou referências a cli::pin_ptr",
  "não são permitidos ponteiros ou referências a matrizes %[C++/CLI]",
  "não é permitido o tipo de matriz %[C++/CLI]",
  "uma classe ref %[C++/CLI] só pode derivar de uma classe ref ou de classes de interface",
  "uma classe value %[C++/CLI] só pode derivar de classes de interfaces",
  "uma classe de interface %[C++/CLI] só pode derivar de classes de interface",
  "uma classe ref pode possuir no máximo uma classe ref base direta (%t já é esta base)",
  "uma classe padrão não pode derivar de uma classe %[managed]",
  "classes %[managed] não podem ter bases virtuais",
  "classes %[managed] não podem ter bases 'private' ou 'protected'",
  "o modificador \"override\" requer uma declaração de função virtual com uma palavra-chave \"virtual\" explícita",
  "o modificador \"abstract\" requer uma função virtual de declaração com uma palavra-chave \"virtual\" explícita",
  "o modificador \"sealed\" requer uma declaração de função vitual com palavra-chave \"virtual\" explícita",
  "especificadores de substituição nomeados requerem declarações de funções virtuais com palavra-chave \"virtual\" explícita",
  "não é permitido o tipo de saída cli::pin_ptr",
  "o atributo %sq é aplicável somente no modo %[C++/CLI]",
  "não é possível vincular referências simples (sem-rastreamento) a entidades no heap gerenciado",
  "assembly portátil",
  "'%s' não foi carregado a partir dos assemblies padrão",
  "listar sintaxe de inicialização é um recurso do C++11",
  "o operando de sizeof não pode ser uma classe de tipo ref ou de tipo interface",
  "número inválido de subscritos para esse tipo %[cli::array]",
  "um ponteiro para membro não é válido para uma classe %[managed]",
  "a função de membro virtual particular da classe %[managed] não é 'sealed'",
  "modificadores não são permitidos em um destruidor",
  "modificadores não são permitidos em um finalizador",
  "'virtual' não tem efeito sobre um destruidor de uma classe %[managed]",
  "new ou \"override\" é necessário porque esta declaração corresponde a %nd",
  "new ou \"virtual\" é necessário porque essa declaração corresponde a %nd",
  "new' ou 'override não é válido aqui porque o %nd correspondente é membro de uma interface",
  "modificador \"new\" sem um membro de classe ref base correspondente",
  "%nd substituído com acesso reduzido",
  "a referência do tipo %t1 não pode ser inicializada com um valor do tipo %t2",
  "um construtor de cópia não pode ser declarado em uma classe value",
  "um construtor padrão não pode ser declarado em uma classe value",
  "um destruidor não pode ser declarado em uma classe value",
  "um operador de atribuição não pode ser declarado em uma classe value",
  "classe sem valor %t não pode ser o tipo de um membro de uma classe value",
  "a opção 'cppcli' requer uma configuração diferente do compilador",
  "especificações de exceções não são permitidas em funções membros de classes %[managed]",
  "não é possível que uma classe %[managed] declare um amigo",
  null,
  null,
  "definições de classe locais não são permitidas em funções membros de classes %[managed]",
  "lambda local não é permitido em uma função membro de uma classe %[managed]",
  "uma função membro de um tipo de interface %[C++/CLI] não pode ter uma definição",
  "uma definição de propriedade deve incluir pelo menos um acessador (\"get\" ou \"set\")",
  "propriedade indexada por padrão conflita com %nd",
  "%n1 não pode ser usado porque segue um pacote de parâmetros e não pode ser deduzido dos parâmetros %n2",
  "Este pacote de expansão produziu mais de uma expressão e uma única expressão necessária aqui",
  "tipo deve corresponder a System::Boolean, System::Byte, System::SByte, System::Int16, System::UInt16, System::Int32, System::UInt32, System::Int64, or System::UInt64",
  "chamada de um objeto de um tipo de identificador sem operador () apropriado ou funções de conversão de tipo ponteiro para função",
  "uma declaração de pacote de parâmetros não pode ser entre parênteses",
  "modelos variadic só podem ser ativados ao compilar C++",
  "definição de propriedade conflita com %nd",
  "propriedade sobrecarregada",
  "propriedade",
  "um parâmetro genérico não pode ter um padrão",
  "um genérico só pode ter parâmetros de tipo",
  "para ser usado para instruções 'for each', o tipo %t deve fornecer uma função de membro não estática %sq",
  "for each não pode usar o membro %n porque é estático",
  "nesta instrução \"for each'\", nenhuma instância de %no pode ser chamada com uma lista de argumentos vazia",
  "for each não pode usar a função membro \"MoveNext\" porque o tipo de retorno é inválido",
  "uma instrução \"for each\" não pode operar em uma expressão do tipo %t",
  "para ser usado com instruções \"for_each\", o tipo %t deve fornecer uma propriedade não indexada %sq",
  null,
  "nesta instrução \"for each\" %t2 não é um enumerador válido (retornado por GetEnumerator de %t1)",
  "esperado 'in'",
  "a classe %t não tem nenhum operador de atribuição adequado] (após a síntese de operador)",
  "%sq não é um parâmetro genérico",
  "%sq não é um parâmetro genérico da lista mais interna de parâmetros genéricos",
  "Restrição genérica inválida",
  "Uso inválido do membro do evento (apenas inscrição, cancelamento de inscrição e chamada são permitidos)",
  "invocar um evento sem nenhum acessador \"raise\" é inválido",
  "somente \"+=\" e '-='' são válidos para eventos",
  "typeid de um tipo %[managed] não é permitido",
  "typeid de um tipo ponteiro %[managed] não é permitido",
  "nome seguido por \":: typeid\" deve ser um nome de tipo",
  "um membro %sq deste tipo é reservado em uma classe %[managed] -- a intenção é um destruidor?",
  "um membro %sq deste tipo é reservado em uma classe %[managed] -- a intenção é um finalizador?",
  "%[System]::IDisposable::Dispose está ausente ou inválido",
  "%[System]::Object::Finalize está ausente ou inválido",
  "%n não substitui %[System]::Object::Finalize",
  "o operando do identificador dynamic_cast deve ser um identificador para um tipo de classe completo",
  "o operando de um referência de rastreamento dynamic_cast deve ser lvalue de um tipo de classe completo",
  "o tipo de um identificador ou referência de rastreamento dynamic_castb deve se referir a uma classe completa",
  "um ponteiro interior não pode ser convertido para um ponteiro nativo",
  "Operadores de conversão explícita só podem ser declarados nos tipos de classe ref e value",
  "operadores de conversão explícitos não podem ser virtual",
  "expressão deve ser do tipo aritmético ou de enumeração sem escopo",
  "expressão deve ter o tipo aritmético, de enumeração sem escopo ou de ponteiro",
  "expressão deve ser do tipo de enumeração, integral ou sem escopo",
  "expressão deve ter tipo integral, de enumeração sem escopo ou de ponteiro fixo",
  "um operador binário interno aplicado a uma enumeração com escopo requer dois operandos do mesmo tipo",
  "%[gcnew] não pôde alocar uma entidade do tipo %t",
  "sintaxe de colocação não pode ser usada com %[gcnew]",
  "new só pode ser usado com tipos de valor simples",
  "new não pode ser usado em uma classe %[managed] (em vez disso usar %[gcnew])",
  "novo não pode ser usado em um tipo de identificador",
  "%[gcnew] para uma matriz %[C++/CLI] deve ter um inicializador new ou um inicializador de matriz",
  "inicializador de matriz só pode ser usado para inicializar um tipo de matriz %[C++/CLI]",
  "automático não permitido para %[gcnew]",
  "excesso de limites de matriz",
  "muito poucos limites de matriz",
  "muito poucos argumentos para %nf",
  "muitos argumentos para %nf",
  "classe genérica",
  "nenhuma declaração de %nf aceita o número de argumentos genéricos fornecido",
  "inicializador delegado inválido -- deve ser uma função",
  "inicializador delegado inválido - mais de uma função corresponde ao tipo delegate",
  "inicializador delegado inválido - a função não corresponde ao tipo delegate",
  "inicializador delegado inválido - um objeto é necessário, além de uma função",
  "inicializador delegado inválido -- função não é um membro de uma classe %[managed]",
  "inicializador delegado inválido - objeto não é necessário para a função especificada",
  "inicializador delegado inválido - objeto tem tipo %t1 mas é esperado tipo %t2",
  "não é permitido tomar o endereço de uma função de membro de uma classe %[managed]",
  "inicializador delegado inválido - esperado \" (<function-address>)\" (<object-handle>, <member-address>)\"",
  "classe não implemente o membro de interface %nd",
  "%[gcnew] não pode ser usado para alocar uma matriz nativa",
  "uma classe de interface %[C++/CLI] não pode declarar um operador de atribuição",
  "uma classe de interface %[C++/CLI] não pode ser selada",
  null,
  "uma declaração de destruidor ou finalizador não pode incluir um especificador de substituição nomeado",
  "um especificador de substituição não pode designar um destruidor ou finalizador",
  "especificadores de substituição nomeados só são permitidos em classes %[managed]",
  "nenhum membro designado pelo especificador de substituição nomeado corresponde ao tipo deste membro",
  "uma declaração de construtor estático não pode incluir um especificador de substituição nomeado",
  "tipos de enumeração com escopo deve ter um nome",
  "não permitida a transferência de controle para um bloco finally",
  "instrução return dentro de blocos finally não permitida",
  "o bloqueio de tentativa exige pelo menos um manipulador ou cláusula finalmente",
  "um objeto %[managed] deve ser lançado por um identificador",
  "objeto %[managed] deve ser detectado por identificadores",
  "uma instrução break não pode ser usada em um bloco finally",
  "uma instrução continue não pode ser usada em um bloco finally",
  "offsetof interno não pode ser usado quando subscripting está sobrecarregado",
  "restrição duplicada",
  "há mais de uma restrição de classe: %t1 e %t2",
  "há mais de uma cláusula de restrição para %n",
  "membros de dados estáticos InitOnly devem ter um inicializador ou ser inicializados em um construtor estático",
  "Atributos GNU em uma redeclaração de modelo não têm nenhum efeito",
  "Atributos GNU em uma redeclaração de modelo não têm nenhum efeito (em vez disso os atributos da declaração original %p se aplicam)",
  "parâmetro de matriz %[C++/CLI] deve ser o último parâmetro",
  "uma função com um parâmetro de matriz %[C++/CLI] não pode ter argumentos padrão",
  "uma matriz de parâmetros %[C++/CLI] não pode ser seguida de uma parâmetro de elipse",
  "parâmetros de matrizes %[C++/CLI] não são permitidos em listar de operadores de funções",
  "__inline e __forceinline não são permitidos aqui",
  "um membro de dados não pode ter tipo de classe de interface %[C++/CLI]",
  "uma variável não pode ter tipo de classe de interface %[C++/CLI]",
  "um parâmetro não pode ter tipo de classe de interface %[C++/CLI]",
  "um tipo de retorno de função não pode ser um tipo de classe de interface %[C++/CLI]",
  "o tipo de parâmetros de matriz genérico não é permitido",
  "não são permitidos ponteiros, identificadores ou referências a parâmetros genéricos",
  "campos initonly não podem ter tipo de classe ref",
  "uma referência não pode ser vinculada a um campo initonly",
  "não é permitido tomar o endereço de um campo initonly",
  "um campo initonly só pode ser modificado pelo construtor de instância da classe que o contém",
  "um campo estático initonly só pode ser modificado pelo construtor estático da classe que o contém",
  " a função de membros será invocada em uma cópia do campo initonly",
  "a expressão precisa ter um tipo de ponteiro ou de identificador, mas tem o tipo %t",
  "um construtor move ou um operador de atribuição de movimento é usado para copiar um lvalue aqui, o que pode destruir o objeto fonte",
  "a seleção de membros em uma entidade %[C++/CLI] genérica deve usar a sintaxe '->', e não '.'",
  "um tipo de classe ref não pode derivar de %t",
  "uma classe genérica deve ser %[managed] (isto é, uma classe ref, uma classe value ou uma classe de interface)",
  "uma classe sealed não pode ser usada como restrição",
  "o tipo em um dynamic_cast não pode ser um tipo genérico que possa ser um tipo value",
  "um nome de caractere universal deve designar um ponto de código válido",
  "restrições genéricas não correspondem às de %nd",
  "__underlying_type só se aplica a tipos de enumeração",
  "espera-se apenas uma expressão de operando para essa conversão",
  "caractere Unicode com valor hexadecimal %s não representável na página de código padrão do sistema",
  "conversão não padrão de ponteiro para membro acoplado um ponteiro de função",
  "o especificador de acesso %s1 está obsoleto -- use %s2",
  "um função de acessador estática não é permitida em uma propriedade não estática ou definição de evento",
  "%t possui tanto uma classe value quanto uma restrição de classe ref",
  "%t1 e %t2 envolvem restrições circulares do tipo naked",
  "%t não é uma restrição de tipo válida",
  "o arquivo de cabeçalho precompilado %sq não foi usado por estar incompleto",
  "%t não é um argumento genérico válido",
  "atributo assembly_info aplicado a um tipo inválido",
  "%t1 não satisfaz a restrição de classe ref do parâmetro genérico %t2",
  "%t1 não satisfaz restrição de classe de valor do parâmetro genérico %t2",
  "%t1 não satisfaz a restrição de parâmetro genérico %t2 %[gcnew] porque é abstract",
  "%t1 não satisfaz a restrição %[gcnew] do parâmetro genérico %t2 pois não possui um construtor público padrão",
  "o parâmetro genérico %t1 não satisfaz a restrição %[gcnew] do parâmetro genérico %t2 pois não possui restrição %[gcnew]",
  "%t1 não satisfaz a restrição de tipo %t3 do parâmetro genérico %t2",
  "a restrição de parâmetro genérico %t é diferente da declaração anterior (%p)",
  "um membro de uma classe %[managed] não pode ser uma matriz padrão",
  "um membro de uma classe não %[managed] não pode ser um identificador",
  "um membro de uma classe não %[managed] não pode ser uma referência de rastreamento",
  "reinterpret_cast do identificador não seguro",
  "modelos de argumentos não podem fazer referência a parâmetros de tipo genéricos",
  "listas de expressões não são permitidas nesta operação subscrita (use parênteses ao redor de um operador de vírgula de nível superior)",
  "a expressão precisa ter tipo de matriz ponteiro-para-objeto ou identificador-para-%[C++/CLI], mas tem tipo o %t",
  "atributo não reconhecido",
  "membros de classes %[managed] não podem ser de um tipo de classe não %[managed]",
  "membros de classes não %[managed] não podem ter tipo de classe de referência ou de interface",
  "em",
  "um delegado não pode ser declarado como um modelo",
  "um genérico não pode ser explicitamente especializado",
  "um genérico não pode ser declarado em um modelo de classe",
  "um modelo não pode ser declarado em uma classe genérica",
  "um campo literal não pode ser declarado 'static'",
  "'long float' é uma extensão não-padrão--use 'double' em vez disso",
  "uma classe padrão não pode ser aninhada em uma classe %[managed]",
  "__clrcall é válido somente no modo C++/CLI",
  "__clrcall não permitido em função com parâmetro de elipse",
  "%sq não é permitido aqui",
  "não se pode usar um evento ou uma propriedade trivial para substituir %nd",
  "esperado nome de variável do iterador",
  "o tipo de iterador nesta instrução 'for each' é %t, o que não é um tipo de ponteiro ou um tipo de classe tipo iterador",
  "o tipo de iterador nesta instrução 'for each' é %t, o que não é um tipo de ponteiro ou um tipo de classe tipo iterador",
  "o tipo de iterador nesta instrução 'for each' é %t, o que não é um tipo de ponteiro ou um tipo de classe tipo iterador",
  "o atributo de empacotamento no tipo pai é ignorado para este campo de tipo de classe %t que não é de layout padrão",
  "%nd não implementado porque essa declaração não é pública e não possui um especificador de substituição nomeado",
  "falta o atributo gnu_inline especificado na declaração anterior %p",
  "funções membros de classes %[managed] não podem ter parâmetros de elipses",
  "o %n previamente declarado como iterador da declaração \"for each\" é inválido",
  "convenção de chamada ignorada porque o tipo de função envolve um parâmetro genérico; foi usado em vez disso __clrcall",
  "tipos de funções que envolvam parâmetros genéricos não podem ter parâmetros de reticências",
  "'virtual' é necessário para substituir o %nd correspondente",
  "virtual é necessário para implementar o %nd correspondente",
  "um membro de dados initonly não pode ser volátil",
  "há um membro %sq deste tipo reservado em uma classe %[managed] -- operadores %[C++/CLI] devem ser declarados com a palavra-chave 'operator'",
  "uma referência de rastreamento para não-const não pode ser vinculada a uma constante",
  "atributos ignorados aqui porque não se aplicam a uma entidade declarada",
  "não são permitidas referências de rastreamento para %[System]::String",
  "uso inválido de uma classe genérica %t com restrições pendentes (provavelmente causado por um arquivo de metadados inválido)",
  "cláusulas constraint pendenten são permitidas somente para declarações de classe genéricas (mas não definições de classe genéricas)",
  "não é permitida uma lista vazia de inicializadores aqui",
  "modelos não podem ser declarados em classes %[managed]",
  "declarações genéricas não são permitidas aqui",
  "tipos de interface não podem ter genéricos de membros",
  "caracter Unicode diferente de Latin-1 truncado para byte de ordem inferior",
  "o tipo %t deve prover a função %sq para ser usado em declarações \"for\" com base em intervalos",
  "o tipo de iterador nesta instrução baseada em intervalo 'for' é %t, o que não é um tipo de ponteiro ou um tipo de classe tipo iterador",
  "o tipo de iterador nesta instrução baseada em intervalo 'for' é %t, o que não é um tipo de ponteiro ou um tipo de classe tipo iterador",
  "o tipo de iterador nesta instrução baseada em intervalo 'for' é %t, o que não é um tipo de ponteiro ou um tipo de classe tipo iterador",
  "declarações \"for\" com base em intervalos não podem operar em matrizes de tamanho desconhecido ou de tipo incompleto %t",
  "os tipos de retorno para as funções \"begin\" e \"end\" usados em declarações \"for\" com base em intervalos devem ser os mesmos (o tipo de retorno de \"begin\" é %t1, o de \"end\" é %t2)",
  "o %nfd, necessário para destruir o temporário que foi eliminado não está acessível",
  "nenhuma instância de %no corresponde à lista de argumentos nesta declaração \"for\" com base em intervalos",
  "este intervalo com declaração \"for\" baseada em intervalos requer uma função %sq adequada, mas nenhuma foi encontrada",
  "esta instrução 'for each' requer uma função %sq adequada, mas nenhuma foi encontrada",
  "%t tem uma representação de metadados não representável com %[C++/CLI]",
  "esperado '...'",
  "%t na lista __implements não é uma interface",
  "uma lista __implements deve preceder declarações de funções virtuais",
  "%t especificou '__implements ...' na lista de bases, mas a lista __implements correspondente está ausente",
  "o resultado do cancelamento da referência de um identificador de uma classe ref ou de interface deve ser usado",
  null,
  "')' esperado, pragma ignorado",
  "uma declaração 'using' ou uma declaração de acesso não pode aparecer em uma classe gerenciada",
  "Nota: %nd pode ter sido chamado, mas não foi considerado porque é inacessível",
  "um membro abstrato de uma classe gerenciada C++/CLI não pode ter uma definição",
  "a declaração deste unário 'operator*' pode mudar o significado de desreferenciar um identificador (use operadores membro estáticos para indicar tipos aplicáveis explicitamente)",
  "gerenciado",
  "C++/CX",
  "C++/CLI",
  "mapeamento C++/CX",
  "padrão",
  "mapeamento cli",
  "cli::array",
  "Platform::Array",
  "Matriz C++/CLI",
  "Matriz C++/CX",
  "Sistema",
  "Plataforma",
  "gcnew",
  "ref new",
  "uma classe de interface não pode conter um membro de dados não estático",
  "#pragma GCC system_header não pode ser usado no arquivo fonte primário",
  "%n é muito grande para ser embutido",
  " (declarado implicitamente)",
  "a opção para controlar operações de movimentação podem ser usadas apenas ao compilar C++",
  "operações de movimentação não podem ser geradas quando os construtores de rvalue são construtores de cópia",
  "a opção para controlar operações de movimentação não podem ser usadas quando as referências de rvalue estão desabilitadas",
  "'final' não pode ser usado para classes gerenciadas (use 'sealed')",
  "uma conversão em classe %t da interface CLI não é permitida -- converter no identificador pretendido?",
  "não é possível criar um objeto de uma classe de interface CLI",
  "esta declaração oculta a declaração não padrão de %nd porque os tipos subjacentes são incompatíveis",
  "o resultado da comparação de ponteiro é constante porque o operando nunca pode ser nulo",
  "um objeto do tipo incompleto %t não pode ser inicializado por valor",
  "uma referência não pode ser inicializada por valor",
  "esperado um '(' ou um '{'",
  "copy-list-initialization não pode usar um construtor marcado como 'explicit'",
  "ponteiro para membro do tipo void não é permitido",
  "ponteiro para membro do tipo reference não é permitido",
  "ponteiro para membro do tipo handle não é permitido",
  "uma lista delimitada por chaves não é permitida aqui",
  "um membro operator->* não é permitido em uma classe gerenciada",
  "os metadados do assembly se referem a um assembly não existente",
  "o atributo %sq2 está em conflito com o atributo anterior %sq1",
  "%nd foi declarado anteriormente com um tipo base diferente",
  "'enum class' e 'enum struct' não podem ser usados aqui (use 'enum' simples)",
  "somente um nível de chave é permitido em um inicializador para um objeto do tipo %t",
  "%nd não pode ser usado como um nome de tipo de enumeração",
  null,
  "um inicializador entre chaves não pode ser usado com 'new auto'",
  "a definição de std::initializer_list não contém o construtor esperado",
  "a declaração oculta %nd",
  "lista de parâmetros de modelo inválida para std::initializer_list (deveria ser um parâmetro de tipo ordinário sem padrão)",
  "uma lista delimitada por chaves não pode ser passada para um parâmetro de reticências",
  "um #include <lista_de_inicializadores> é necessário antes do uso de um std::initializer_list, incluindo um uso implícito",
  "a palavra-chave 'inline' não pode ser usada na declaração de um alias de namespace",
  "a declaração anterior de %n não foi declarada em linha",
  "O %n foi declarado embutido anteriormente",
  "o primeiro argumento deve ser uma constante inteira",
  "um designador não pode ser usado com um tipo de não agregação %t",
  "um designador para um membro de união anônima só pode aparecer entre chaves correspondentes àquela união anônima",
  "marcas de protótipos de função só podem ser habilitadas ao compilar C",
  "não é possível omitir chaves para o inicializador deste subobjeto",
  "conversão de restrição inválida de %t1 para %t2",
  "conversão de restrição inválida de %t1 para %t2: o valor da constante não se encaixa no tipo de destino",
  "a conversão para tipo de matriz incompleto %t não é permitida",
  "conversão de restrição inválida de %t1 para %t2: o valor da constante não pode ser representado de forma exata no tipo de destino",
  "um inicializador entre parênteses para uma entidade não classe deve ser uma expressão, e não uma lista delimitada por chaves",
  "uma lista delimitada por chaves não fornece um tipo de retorno para este lambda",
  "a especificação da exceção declarada é incompatível com a gerada",
  "os tipos de enumeração com escopo são um recurso do C++11",
  "um tipo de função não pode ser inicializado por valor",
  "a inicialização de lista de um tipo de objeto %t não é permitida porque o tipo está incompleto",
  "std::initializer_list possui um destruidor, mas não deveria -- a biblioteca está configurada incorretamente",
  "os tipos base de enumeração explícita são um recurso do C++11",
  "esta expressão constante tem o tipo %t1 em vez do tipo necessário %t2",
  "um 'new' de um objeto std::initializer_list é improvável de funcionar como o esperado porque a matriz subjacente será destruída no final da expressão completa",
  "No arquivo de macro predefinida",
  null,
  "'defined' é sempre falso em uma expansão de macro no modo Microsoft",
  "%t não pode ser o tipo de elemento de uma lista de inicializador porque não é um tipo de objeto completo",
  "delimitadores inconsistentes em expressão de argumento padrão",
  "conversão não padrão de ponteiro para membro para um ponteiro de função",
  "as especificações de exceções dinâmicas estão preteridas",
  "%n não pode ser parcialmente especializado no escopo atual",
  "%nd foi declarado anteriormente como constexpr",
  "%nd não foi declarado anteriormente como constexpr",
  "inicializador ausente para variável constexpr",
  "'constexpr' não é válido aqui",
  "uma função constexpr deve conter exatamente uma instrução return",
  "a instrução não pode aparecer em uma função constexpr",
  "a instrução não pode aparecer em um constructor constexpr",
  "uma função não pode ser tanto constexpr quanto virtual neste modo",
  "uma função constexpr não pode ter um tipo de retorno não literal %t",
  "uma função constexpr não pode ter um parâmetro de tipo não literal %t",
  "usos de %n não sequenciados em expressão pode gerar resultados indefinidos",
  "o terceiro argumento opcional de um chamada a __builtin_assumed_aligned deve ser do tipo integral",
  "um destruidor não pode ser constexpr",
  "o endereço fornecido para mmap deve estar alinhado em um limite de página: %s",
  "o corpo de um construtor constexpr não pode ser uma função de bloco try",
  "o constexpr %nf não fornece um inicializador para:",
  "%n",
  "chamar o construtor padrão de %t não produz um valor constante",
  "o construtor padrão de %t não é constexpr",
  "uma variável constexpr deve ter um tipo literal ou um tipo de referência",
  "um construtor para uma classe com bases virtuais não pode ser constexpr",
  "a chamada de função deve ter um valor constante em uma expressão constante",
  "a função 'main' não pode ser declarada como constexpr",
  null,
  "uma definição de tipo de enumeração ou classe não pode aparecer em um corpo de construtor ou função constexpr",
  "somente atributos GNU-style são permitidos aqui",
  "uso não padrão de 'auto' para deduzir o tipo a partir de um inicializador e para anunciar um tipo de retorno à direita",
  "a declaração de uma lista de parâmetros void com um tipo void qualificado não é padrão",
  "o qualificador nesta declaração local é ignorado",
  "esta expressão constante tem o tipo %t em vez do tipo necessário %s",
  "a instanciação de __bases ou __direct_bases requer um tipo de classe",
  "o argumento de __bases e __direct_bases deve ser um parâmetro de modelo de tipo",
  "%s só pode ser usado em contextos de modelo",
  "o retorno da função constexpr é não constante",
  "o construtor constexpr chama %n não constexpr",
  "o construtor não pode ser constexpr porque o inicializador de %n não é uma expressão constante",
  "inicializador não constante para construtor constexpr",
  "o construtor padrão gerado para %t não pode ser usado em um inicializador para seu próprio membro de dados",
  "a instanciação do inicializador de %n depende de seu próprio valor",
  "o construtor padrão usado como padrão não pode ser constexpr porque o construtor padrão correspondente declarado implicitamente não seria constexpr",
  null,
  "número binário inválido",
  "uma união pode ter no máximo um inicializador de campo -- %nd também tem um inicializador",
  null,
  "o construtor constexpr de uma união deve inicializar um de seus campos",
  "falha do construtor constexpr em inicializar uma união anônima (%p definido)",
  "uma declaração de membro de dados estáticos constexpr requer um inicializador na classe",
  "só é possível usar o máximo de opções de profundidade/contagem de constexpr ao compilar C++",
  "expressão não dobrada em uma constante devido a complexidade excessiva de chamada da função constexpr",
  "só é possível usar opções de união irrestrita ao compilar C++",
  "o construtor constexpr deve inicializar a classe base direta %t",
  "é improvável que a criação de um objeto std::initializer_list em um inicializador de campo funcione como esperado porque a matriz subjacente será destruída ao final da expressão completa",
  "'this' não pode ser usado em uma expressão constante",
  null,
  "'constexpr' não é permitido em uma diretiva explícita de instanciação",
  "não é possível determinar a especificação de exceção do construtor padrão devido a uma dependência circular",
  "%p definido por união anônima",
  "este construtor usa o inicializador de %nd, o que resultaria em recursão ilimitada",
  null,
  "um inicializador não é permitido em uma declaração local de uma variável externa",
  "um inicializador não é permitido em uma declaração local de uma variável de registro nomeado",
  null,
  "uniões irrestritas não podem ser habilitadas no modo Microsoft",
  "o construtor delega a si mesmo, direta ou indiretamente",
  "um construtor de delegação não pode ter outros inicializadores de memória",
  "um qualificador de referência não é permitido aqui",
  "sobrecarregar duas funções de membro com os mesmos tipos de parâmetro exige que ambas tenham ou que nenhuma tenha qualificadores de referência",
  "caractere inválido no delimitador de cadeia de caracteres bruta",
  "parêntese que termina o delimitador de cadeia de caracteres bruta não encontrado após 16 caracteres – indicador de cadeia de caracteres bruta ignorado",
  "delimitador de término não encontrado para cadeia de caracteres bruta",
  "um pacote de parâmetros deve ser o argumento de modelo final em uma especialização parcial",
  "uma função de ponteiro para membro com o tipo %t só pode ser usada com um objeto lvalue",
  "uma função de ponteiro para membro com o tipo %t só pode ser usada com um objeto rvalue",
  "o parâmetro deste construtor de cópia definido como padrão não pode ser constante porque um parâmetro de construtor de cópia base ou membro é não constante",
  "o parâmetro deste operador de atribuição definido como padrão não pode ser constante porque um parâmetro de atribuição de cópia base ou membro é não constante",
  "uma união anônima deve conter pelo menos um membro de dados não estáticos",
  "a opção 'delegating_constructors' requer uma configuração diferente de compilador",
  "uma redução no alinhamento é ignorada",
  "o operando de um const_cast para um tipo de referência rvalue não pode ser uma classe não prvalue",
  "a expressão deve ser um lvalue ou xvalue",
  "a conversão pode alterar o valor",
  "a conversão de um literal de cadeia de caracteres em 'char *' está obsoleta",
  "a conversão de um literal de cadeia de caracteres em pointer-to-character (non-const) está obsoleta",
  "'override' e 'final' são recursos do C++11",
  "referências a rvalue não são permitidas como tipos de especificação de exceção",
  "o atributo %sq não se aplica a parâmetros de manipulador",
  "o atributo %sq exige um parâmetro de manipulador",
  "alignas não se aplica aqui",
  "o operador 'alignof' padrão não aceita um argumento de expressão (use um tipo)",
  "qualificador inválido para %t (uma classe derivada não é permitida aqui)",
  "o atributo 'always_inline' é ignorado em funções não embutidas",
  "construtores de herança devem ser herdados de uma classe base direta",
  null,
  "espera-se um rótulo",
  "espera-se um número de operando depois de '%%l'",
  "o número de operando para '%%l' não se refere a um argumento de rótulo válido",
  "uma cadeia ampla é inválida em uma instrução 'asm'",
  "o atributo não é padrão",
  "não é uma classe base da classe %t",
  "caráter não identificador no sufixo literal definido pelo usuário",
  "um literal de caractere múltiplo não pode fazer parte de um literal definido pelo usuário",
  "o sufixo literal definido pelo usuário não corresponde ao %sq anterior",
  "nome de operador literal inválido",
  "operador literal definido pelo usuário não encontrado",
  "operadores literais ambíguos e/ou modelo de operador literal:",
  "um operador literal não pode ser membro de uma classe",
  "um operador literal não pode ter um vínculo de nome de 'C' externo",
  "pelo menos um parâmetro esperado para um operador literal",
  "parâmetros em excesso para este operador literal",
  "tipo de parâmetro %t inválido para o operador literal",
  "tipo de parâmetro inteiro (%t) inválido para o operador literal; era esperado um tipo de caractere ou um unsigned long long",
  "tipo de parâmetro de ponto flutuante (%t) inválido para o operador literal; esperava-se um longo duplo",
  "primeiro tipo de parâmetro (%t) inválido para o operador literal; um ponteiro para um tipo não constante não é permitido",
  "tipo de segundo parâmetro (%t) inválido para o operador literal; deve ser size_t",
  "tipo de parâmetro de ponteiro (%t) inválido para o operador literal; era esperado um ponteiro para um tipo de caractere",
  "um operador literal não pode ter um parâmetro de reticências",
  "um modelo de operador literal não pode ter parâmetros",
  "um modelo de operador literal precisa ter uma lista de parâmetros de modelo equivalente a '<char ...>'",
  "a classe de armazenamento local de thread não é válida aqui",
  "a declaração local de thread segue a declaração local sem thread (declarada %p)",
  "a declaração local sem thread segue a declaração local com thread (declarada %p)",
  "um operador literal não pode ter argumentos padrão",
  "atributo é ignorado para variáveis locais com thread",
  "um sufixo literal fornecido pelo usuário precisa começar com '_'",
  "referências a rvalue são um recurso do C++11",
  "expressões lambda são um recurso do C++11",
  "a sintaxe de atributo padrão é um recurso do C++11",
  "construtores de delegação são um recurso do C++11",
  "herdar construtores é um recurso do C++11",
  "inicializadores de campo são um recurso do C++11",
  "funções excluídas são um recurso do C++11",
  "funções padrão são um recurso do C++11",
  "uma classe de armazenamento não é permitida em uma especialização explícita",
  null,
  "uma enumeração sem escopo definido deve ser opaco para ser especializada",
  "uma declaração de modelo enumeração deve fazer referência a um membro anteriormente declarado de um modelo de classe",
  "espera-se um operando de vetor",
  "operandos de origem de ordem aleatória têm tipos incompatíveis %t1 e %t2",
  "máscara de ordem aleatória (tipo %t) não é um vetor de inteiros",
  "máscara de ordem aleatória (tipo %t1) tem um comprimento diferente do operando de origem (tipo %t2).",
  "inicialização estática com um valor de endereço requer um destino do mesmo tamanho que o endereço",
  "o argumento para uma macro de teste de recurso deve ser um identificador simples",
  "__has_include_next não pode ser usado no arquivo de origem primário",
  "nome de arquivo absoluto usado em __has_include_next",
  "o atributo %sq precisa ser aplicado a um tipo de função",
  null,
  "_Noreturn não é permitido aqui",
  "espera-se um operando do tipo de ponto flutuante real (não %t)",
  "__builtin_complex requer operandos de tipos compatíveis (ao contrário de %t1 e %t2)",
  "uma associação padrão já apareceu nesta seleção _Generic",
  "um tipo que envolve uma matriz de comprimento variável não é permitido aqui",
  "tipo de associação duplicado (%t) na seleção _Generic",
  "nenhuma associação corresponde ao tipo de seletor %t",
  "o tipo de %n (%t) não é compatível com um tipo de resolvedor ifunc",
  "uma função não pode ter ambos os atributos ifunc e alias",
  "uma função não pode ter ambos os atributos ifunc e weak",
  "a chamada exige um operando literal de cadeia de caracteres",
  "duplicata herdando declaração de construtor (anterior %p)",
  "\"decltype(auto)\" deve ser um espaço reservado para o tipo completo da variável (não para um componente desse tipo)",
  "decltype(auto) não é permitido aqui",
  "não é possível deduzir 'decltype(auto)' (inicializador necessário)",
  "não é possível deduzir o tipo 'decltype(auto)'",
  "uma declaração de local de thread de escopo de bloco deve incluir estático ou externo",
  "tipo de retorno deduzido %t1 está em conflito com tipo deduzido anteriormente %t2",
  "não é possível deduzir o tipo de retorno de %nd; não foi definido",
  "uma função virtual não pode ter um tipo de retorno deduzido",
  "%n será tratado como uma palavra-chave contextual a partir deste ponto",
  "o namespace global não tem membro real %sq",
  "comparação entre dois tipos diferentes de enumeração (%t1 e %t2)",
  "atributo de destino não reconhecido",
  "função de destino \"padrão' ausente",
  "apenas um arco = destino pode ser especificado",
  "uma classe genérica não pode ser um atributo personalizado",
  "destino de atributo inválido %sq",
  "atributo ambíguo -- ambos %t1 e %t2 poderiam ser usado",
  "um argumento de atributo nomeado somente pode fazer referência a um campo de leitura/gravação público não estático ou propriedade escalar",
  "um argumento de atributo nomeado somente pode fazer referência a um campo não estático ou propriedade escalar de um tipo de parâmetro de atributo",
  "argumento de atributo inválido -- expressão deve ser uma constante de um tipo de parâmetro de atributo",
  "um argumento de atributo não pode usar parâmetros de tipo genérico",
  "%t somente pode ser usado como um atributo autônomo",
  "o destino do atributo \"campo\" não pode ser usado em um propriedade/evento não trivial",
  "destino de atributo inválido para um atributo autônomo",
  "destino de atributo inválido para este contexto",
  "o atributo %t não pode ser usado aqui",
  "%t está preterido; use '...' para especificar uma matriz de parâmetros",
  "o namespace padrão não pode ser estendido",
  "o tipo na caixa deve ser uma classe value ou enum",
  "a referência de rastreamento para a classe de valor não é permitida",
  "o identificador para classe de valor não é permitido",
  "a referência de rastreamento para enumeração não é permitida",
  "o identificador para enumeração não é permitido",
  "um tipo nativo público não é permitido",
  "um tipo público aninhado não é permitido",
  "tipos genéricos não são permitidos em C++/CX",
  "métodos genéricos não são permitidos em C++/CX",
  "não são permitidas restrições genéricas",
  "membros de dados não públicos não são permitidos em tipos de valores públicos C++/CX",
  "membros sem dados públicos não são permitidos em tipos de valores públicos C++/CX",
  "construtores não são permitidos em tipos de valores públicos C++/CX",
  "o tipo de retorno do acessador \"adicionar\" deve ser Windows::Foundation::EventRegistrationToken",
  "o tipo de retorno do acessador \"remover\" deve ser void",
  "o tipo de parâmetro do acessador \"remover\" deve ser Windows::Foundation::EventRegistrationToken",
  "não são permitidos identificadores ou referências a um tipo de parâmetro genérico",
  "os membros de dados públicos não são permitidos em tipos de não valor",
  "C++/CX pode ser habilitado somente no modo Microsoft C++",
  "Os modos C++/CLI e C++/CX não podem ser combinados",
  "%sq exige o modo C++/CX",
  "O modo C++/CX exige microsoft_version >= 1600",
  "Campos literais não são permitidos em C++/CX",
  "uma referência padrão não pode ser vinculada a um tipo C++/CX",
  "tipo deve corresponder a Platform::Boolean, default::uint8, default::int8, default::int16, default::uint16, default::int32, default::uint32, default::int64 ou default::uint64",
  "um tipo de valor C++/CX não pode ter eventos",
  "um dynamic_cast a um tipo de identificador deve se referir a um tipo de classe completa",
  "Platform::Array só pode ser unidimensional",
  "a referência de rastreamento para o tipo de classe padrão não é permitida",
  "um tipo de valor C++/CX não pode herdar de uma interface",
  "um tipo de valor C++/CX não pode conter funções virtuais",
  "'partial' só pode ser aplicado a 'ref class' ou 'ref struct' no escopo global ou escopo de namespace",
  "o parâmetro do acessador \"definir\" deve ser do tipo 'const Platform::Array<T>^'",
  "a definição de um tipo público C++/CX não é permitida no escopo global",
  "uma propriedade indexada com um acessador \"obter\" ou \"definir\" a público não é permitida",
  "um tipo de representante aninhado público não é permitido",
  "inicializador de representante inválido -- esperado '(<function-address ou functor-object> [, Platform::CallbackContext])' ou '(<object handle>, <member-address> [, Platform::CallbackContext [, bool]])'",
  "inicializador de representante inválido -- o objeto deve ser um identificador para uma classe %[managed]",
  "C++/CX não suporta matrizes \"in/out\" -- use \"const Platform::Array<T>^\" para \"in\" e \"Platform::WriteOnlyArray<T>^\" ou \"Platform::Array<T>^*\" para \"out\" em APIs públicas",
  "atributo 'destino' ausente para %nd",
  "nenhuma função de membro declarado corresponde aos atributos de 'destino' para %n",
  "Atributos do Microsoft neste local são permitidos somente para tipos de interface",
  "A rotina do resolvedor multiversões da função do GNU é necessária",
  "um tipo de enumeração declarado em uma classe gerenciada deve incluir uma definição",
  "um nome qualificado para decltype está fora do padrão neste contexto de declaração",
  "a função não virtual não pode ser declarada com o modificador 'final'",
  "Não há suporte para o atributo 'target' na função especial",
  "precisa ser um literal de cadeia de caracteres estreito",
  "parênteses sem correspondência",
  "sem 'push_options' correspondentes",
  "este pragma não é permitido dentro de uma função",
  "declarar um operador novo ou excluído como 'incorporado' está fora do padrão",
  "um inicializador de memória de um membro de dados não pode ser uma expansão de pacote",
  "expressões lambda genéricas não podem ter padrões de captura neste modo",
  "um argumento de modelo padrão em uma declaração de friend somente pode ser especificada em uma definição",
  "uma declaração de modelo friend com argumento de modelo padrão deve ser a única declaração (primeiro %p declarado)",
  "uma declaração de enumeração opaca não pode fazer parte de outra declaração",
  "uma declaração de enumeração opaca está fora do padrão neste contexto",
  "a sintaxe extensa de amigo é um recurso do C++11",
  "separadores de dígitos não habilitados, o apóstrofo inicia um literal de caractere",
  "o separador de dígito não pode aparecer aqui",
  "'constexpr' é ignorado aqui no modo Microsoft",
  "expressão inválida para o resultado da expressão da instrução",
  "o identificador é uma macro e não um sufixo literal",
  "%nd não pode ser chamado em um lvalue",
  "%nd não pode ser chamado em um rvalue",
  "a função de membro não pode ser chamada em um lvalue",
  "a função de membro não pode ser chamada em um rvalue",
  "a lista de parâmetros de modelo é muito longa",
  "O tipo de modelo de alias %t1 é incompatível com o tipo anterior de %t2 na redeclaração de %nfd",
  "o inicializador de campo de %nd não é uma expressão constante",
  "o número de restrições de operando deve ser o mesmo em cada cadeia de caracteres de restrição",
  "a cadeia de caracteres de restrição contém muitas restrições alternativas; nem todas as restrições foram verificadas",
  "chamar a classe incompleta %t sempre produzirá um erro quando instanciado",
  "o decltype(auto) não pode ter qualificadores de tipo adicionados",
  "init-capture %nod não pode ser capturado aqui",
  "argumento de modelo sem tipo inválido de tipo %t",
  "o atributo abi_tag é ignorado (não tem significado no modo C)",
  "a redeclaração adiciona o atributo abi_tag '%s'",
  "o atributo abi_tag é ignorado (substituído pelo atributo abi_tag posterior)",
  "a declaração anterior de %nd não tinha nenhum atributo abi_tag",
  "(consulte a declaração anterior %p)",
  "o atributo abi_tag é ignorado na especialização",
  "decltype(Auto) não pode aparecer em ponteiro, referência ou constructo ponteiro para membro",
  "espera-se 'classe' ou 'typename'",
  "a expressão de posicionamento 'new' refere-se a %nd que não é de posicionamento",
  "precisa especificar o modo C++14 ao criar a biblioteca de tempo de execução",
  "%s",
  "aviso de linha de comando",
  "Aviso de linha de comando",
  "função de membro não estático constexpr não estará implicitamente 'const' no C++14",
  "o tipo de variável %t na função constexpr não é um tipo literal",
  "a variável na função constexpr não tem duração de armazenamento automático",
  "a variável na função constexpr não foi inicializada",
  "inicialização entre chaves de uma variável declarada com um tipo de espaço reservado, mas sem '=', requer exatamente um elemento entre chaves",
  "nenhuma --configuração de destino '%s' existente",
  "o atributo não tem suporte em configurações x86 de 64 bits",
  "'%s' exige um argumento",
  "um construtor ou destruidor não pode ser uma corrotina",
  "%n não pode ser um corrotina",
  "as expressões co_yield não são permitidas em uma cláusula catch",
  null,
  null,
  null,
  null,
  "modelo de classe %sq não encontrado",
  "use a palavra-chave 'typename' para tratar %n como um tipo em um contexto dependente",
  "o valor do argumento deve ser menor do que a soma dos elementos do vetor",
  "%t não tem membro %sq",
  "uma lista delimitada por chaves não fornece um tipo de retorno",
  "uma expressão co_await precisa aparecer em um escopo de função",
  "uma expressão co_await não é permitida dentro de uma cláusula catch",
  "uma corrotina não pode conter um parâmetro de reticências",
  "habilitar o constexpr estilo C++14 exige suporte para 'bool'",
  "o constexpr %nd não está definido",
  "esta chamada não pode ser avaliada porque a função de destino %nd não é constexpr ou ainda não está completamente definida",
  "observação",
  "Observação",
  "união anônima inválida -- modelo do membro do alias não permitido",
  "um valor literal de caractere UTF-8 não pode ocupar mais de uma unidade de código",
  "o valor de %nd não pode ser usado como uma constante",
  "um ponteiro ou referência para %nd não pode ser usado como uma constante",
  "subscrito diferente de zero para objeto não matriz",
  "não é possível acessar a posição %d1 na matriz de %d2 elementos",
  "chamado de:",
  "acesso inválido para desativar o %n1 da união (%n2 está ativo)",
  "não é possível executar 'goto' em contextos constexpr",
  "valor retornado ausente",
  "o receptor é nulo",
  "tentativa de desreferenciar um ponteiro nulo",
  "tentativa de acessar o armazenamento uma posição além do fim de uma matriz de %d elementos",
  "tentativa de acessar armazenamento expirado",
  "tentativa de acessar armazenamento de tempo de execução",
  null,
  "não é possível chamar %nd não constexpr",
  "não é possível usar matriz de comprimento variável durante avaliação de constexpr",
  "não é possível realizar um deslocamento negativo",
  "quantidade de deslocamento (%d) grande demais",
  "o valor excede o intervalo de %t",
  "erro de ponto flutuante",
  "tentativa de desreferenciar um ponteiro para membro nulo (membro de dados)",
  "comparar um ponteiro para nulo e um ponteiro para uma função não é padrão",
  "falha na inicialização de metadados",
  "conversão de base para derivado inválida (o tipo de classe completo é %t)",
  "acesso inválido a %n no objeto do tipo %t completo",
  "'__auto_type' não é permitido aqui",
  "'__auto_type' não permite vários declaradores",
  "a inicialização com '{...}' não é permitida para '__auto_type'",
  "\"__auto_type\" deve ser um espaço reservado para o tipo de variável completo (não para um componente desse tipo)",
  "uma variável declarada com '__auto_type' exige um inicializador",
  "o constante inteiro deve ser maior ou igual a zero",
  "o tipo deve ser um tipo integral",
  "não é possível interpretar a expressão",
  "não é possível interpretar a instrução",
  "uso inválido de endereço de armazenamento do interpretador",
  "variante de constante inválida para expressão de constante",
  "o tipo %t é grande demais para a avaliação da expressão de constante",
  "tipo %t inválido para a avaliação da expressão de constante",
  "a conversão de %t1 para %t2 é inválida na avaliação da expressão de constante",
  "falha na conversão de ponto flutuante",
  null,
  "tipos de retorno deduzidos são um recurso do C++14",
  "não é possível avaliar um construtor com um destruidor associado",
  "%n não inicializado durante a avaliação de constexpr",
  "diferença de ponteiro inválida na avaliação de constexpr",
  "aritmética inválida no ponteiro não matriz",
  "não é possível definir um ponteiro antes do primeiro elemento da matriz",
  "uma corrotina com um tipo de retorno deduzido é inválida",
  "expressão não permitida em contexto não avaliado",
  null,
  null,
  "'return' não é permitido em uma corrotina (em vez disso, use 'co_return')",
  "'co_return' só é permitido em corrotinas",
  "os valores de ponto flutuante não podem ser comparados",
  "os valores de ponteiro não podem ser comparados porque eles não apontam para o mesmo objeto completo ou apontam para subobjetos com acessibilidade diferente",
  "ignorando o atributo abi_tag no namespace não embutido",
  "ignorando o atributo abi_tag no namespace anônimo",
  "o tipo de parâmetro do modelo complexo ou imaginário não é padrão",
  "a expressão co_yield não é permitida fora do escopo de uma função",
  "ignorando a indicação de local de thread na união anônima",
  null,
  "modelo de variável",
  "acesso a objeto não inicializado",
  "tentativa de leitura do armazenamento volátil",
  "acesso inválido para o %n1 inativo da união (nenhum campo está ativo)",
  "as definições de rótulo não podem aparecer nas funções constexpr",
  "não é possível comparar um ponteiro após o final de uma matriz com um ponteiro para outro objeto completo",
  "o tipo de função %t é um tipo inválido para uma instanciação de modelo variável",
  "a variável não pode ter um %t de tipo incompleto",
  "acesso a subobjeto não inicializado (%n)",
  "acesso a subobjeto não inicializado (classe base %t)",
  "uma chamada de pseudodestruidor não é permitida em uma expressão de constante",
  "tentativa de modificar o armazenamento const",
  null,
  null,
  "tentativa de acessar o armazenamento uma posição depois de um objeto tratado como uma matriz de um elemento",
  "não é possível usar reinterpret_cast na avaliação da expressão de constante",
  "operação não permitida no ponteiro nulo",
  "o valor de *this não pode ser usado como uma constante",
  "a palavra-chave 'embutida' não pode ser usada em uma declaração de namespace aninhada",
  "o atributo 'carries_dependency' foi ignorado",
  "uma '__event __interface' não pode ter uma definição aqui",
  "um manipulador de eventos deve ter um tipo de retorno nulo ou integral",
  "uma '__event __interface' precisa ter sido definida anteriormente",
  "argumentos de modelo em excesso para %n",
  "enumerador já declarado (consulte %nd)",
  "a versão da Microsoft sendo emulado deve ser pelo menos 1903 para usar '--ms_c++14'",
  "a versão da Microsoft sendo emulado deve ser pelo menos 1903 para usar '--ms_c++latest'",
  "o tipo %t não pode ser _Atomic porque é uma matriz ou um tipo de função",
  "o especificador _Atomic(...) não pode ser aplicado ao tipo qualificado %t",
  "acesso ao membro do objeto _Atomic",
  "um campo de bit não pode ter um tipo _Atomic",
  "Os tipos de classe _Atomic estão desabilitados",
  "o construtor constexpr chama o construtor não constexpr para inicialização do subobjeto",
  "esperada uma vírgula (a versão de um argumento de static_assert não está habilitada nesse modo)",
  "falha na asserção estática",
  "no máximo um dos qualificadores _Nullable, _Nonnull e _Null_unspecified pode modificar um tipo",
  "os qualificadores de nulidade só são permitidos em ponteiros e nos tipos de ponteiro para membro",
  "o comprimento do vetor é muito grande",
  "o tipo de elemento do vetor deve ser integral, de enumeração ou do tipo de ponto flutuante real",
  "a função interna não está disponível porque não há suporte para 128 bits inteiros",
  "a função interna não está disponível porque não há suporte para os tipos de vetores",
  "dois colchetes à esquerda consecutivos sempre introduzem uma lista de atributos, mas uma lista de atributos não pode aparecer aqui",
  "o atributo 'de destino' não reconhecido desqualifica essa rotina de ser usada pela rotina do resolvedor",
  "%t não é um tipo de vetor",
  "os tipos de vetor %t1 e %t2 devem ter o mesmo comprimento",
  "os argumentos padrão adicionados não podem resultar em uma declaração de construtor padrão ou de cópia",
  "um argumento de modelo sem tipo do tipo de referência deve ser ssociado a uma função ou um objeto completo",
  "%t não é permitido aqui",
  "o uso do especificador de classe de armazenamento 'registrar' não é permitido",
  "o uso do especificador de classe de armazenamento 'registrar' está preterido",
  "não é permitido incrementar um valor booleano",
  "%sq, declarado como iterador da declaração \" for\" com base em intervalos, pode não ser declarado novamente neste escopo",
  "um espaço namespace de atributo não pode ser usado aqui (porque um prefixo de 'uso' foi especificado)",
  "o namespace de atributo %sq não é reconhecido",
  "um inicializador de membro padrão não é permitido em uma classe de valor",
  "'--implicit_noexcept' exige um modo que habilite noexcept",
  "não é possível realizar o desdobramento da operação envolvendo a classe base virtual (%t)",
  "a inicialização não é constante",
  "não é possível avaliar o valor de %t incompleto",
  "ignorando o valor retornado da rotina declarada com o atributo 'nodiscard'",
  "ignorando o tipo de valor retornado com o atributo 'nodiscard'",
  "o atributo 'nodiscard' não se aplica aos destruidores ou rotinas com o tipo de retorno nulo",
  "o atributo 'fallthrough' se aplica somente a instruções nulas",
  "o atributo 'fallthrough' pode aparecer somente em uma instrução switch da delimitação",
  "a instrução fallthrough deve preceder o rótulo de caso ou padrão de switch",
  "referência ou ponteiro para temporário com tempo de vida limitado",
  "não é possível obter o endereço de uma função com um atributo 'enable_if' cuja condição não é incondicionalmente verdadeira",
  "no momento, não há suporte para atributos 'enable_if' com condições que não são valores constantes",
  "o atributo foi declarado aqui",
  "__has_include não pode aparecer fora de #if",
  "não é possível adicionar a classe base CComCoClass",
  "não é uma cadeia de caracteres com terminação nula",
  "o tipo não escalar %t não pode ser usado em uma chamada de pseudodestruidor",
  "o endereço de 'weak' %n não é constante",
  "substituições recursivas em excesso de assinaturas de modelo de função",
  "especificador inválido para a declaração de associação estruturada",
  "sintaxe de associação estruturada inválida",
  "inicializador ausente",
  "o tipo %t não tem nenhum componente ao qual se associar",
  "identificadores em excesso",
  "há mais elementos do que nomes de associação",
  "'std::tuple_element' não definido",
  "não é possível criar uma instância de 'std::tuple_element' para <%s, %t>",
  "não é possível chamar a função de membro 'get<%s>()' para o tipo %t",
  "nenhuma instância de %no corresponde à lista de argumentos",
  "esta associação estruturada exige uma função adequada %sq e nenhuma foi encontrada",
  "uma associação estruturada não pode ser declarada 'inline'",
  "uma associação estruturada não pode ser declarada 'constexpr'",
  "uma associação estruturada não pode declarar uma classe de armazenamento explícita",
  "std::tuple_size<%t>::value não é uma expressão de constante integral válida",
  "uma declaração de condição precisa declarar uma variável",
  "uma declaração de condição precisa incluir um inicializador",
  "um inicializador entre parênteses não é permitido para uma declaração de condição",
  "uma declaração de condição só pode declarar uma variável",
  "a associação estruturada não pode se associar ao tipo de fechamento",
  "não é possível associar-se ao %n não público",
  "não é possível associar-se ao tipo incompleto %t",
  "esta declaração não é válida aqui",
  "o corpo de uma função constexpr não pode ser uma função do bloco try",
  "a transferência de controle para um bloco if constexpr não é permitida",
  "a associação estruturada não pode ser capturada",
  "para usar '--ms_c++17', a versão da Microsoft sendo emulada deve ser no mínimo 1911",
  "a tentativa de leitura ultrapassou o fim do objeto",
  "lambdas de constexpr não estão habilitados neste modo",
  "uma expressão de constante não pode conter uma expressão lambda",
  "o valor excede o número de argumentos de modelo",
  "o segundo operador na expressão de dobra binária não corresponde ao primeiro",
  "operador de expressão de dobra inválido",
  "uma expressão de dobra binária não pode ser aplicada em dois pacotes de parâmetro",
  "a expansão vazia não é válida para esta expressão de dobra",
  "um membro de dados não estático não pode ser declarado como embutido",
  "a expressão de dobra não faz referência a um pacote de parâmetros",
  "duas funções com os mesmos tipos de parâmetro, mas com especificações de exceção diferentes, não podem ser sobrecarregadas",
  "especificações de exceções dinâmicas não são permitidas neste modo",
  null,
  "operando inválido para o especificador noexcept",
  "a expressão lambda não pode aparecer no especificador noexcept de um modelo",
  "%nfd está inacessível",
  "especificador inválido em declaração de modelo de enumeração",
  "Não há suporte para tipos de ponto flutuante de 80 bits nesta configuração",
  "Não há suporte para tipos de ponto flutuante de 128 bits nesta configuração",
  "valor do enumerador inválido",
  "precisa ser um tipo qualificado _Atomic",
  "o tipo de elemento de matriz deve estar completo",
  "o atributo always_inline foi suprimido para esta função",
  "um valor negativo não é permitido aqui",
  "um elemento de pacote inteiro não pode corresponder a %n",
  "um elemento de pacote inteiro não pode corresponder a %n",
  "designador inesperado",
  "não é possível avaliar __builtin_offsetof",
  "a guia de dedução %t não pode ser definida",
  "a guia de dedução deve ser declarada no mesmo escopo que %n",
  "especificador inválido para a declaração da guia de dedução (somente 'explicit' é permitido)",
  "mutável %n de uma constante não pode ser acessado em uma expressão constante",
  "o modificador de função não se aplica à declaração de membro estático",
  "o atributo 'overloadable' exige uma declaração de função prototipada",
  "não é possível deduzir o tipo de parâmetro de modelo 'auto' %t1 de %t2",
  "o nome do modelo de classe deve ser um espaço reservado para o tipo completo que está sendo inicializado (não para um componente desse tipo)",
  "as declarações de alias são um recurso do C++11",
  "os modelos de alias são um recurso do C++11",
  "o tipo de retorno precisa designar diretamente uma especialização do modelo de classe associado",
  "copy-list-initialization não pode usar %n 'explicit'",
  "guia de dedução",
  "Valor inválido para o operador literal definido pelo usuário",
  "__has_cpp_attribute não pode aparecer fora de #if ou #elif",
  "a guia de dedução deve ser declarada com a mesma acessibilidade que %n",
  "um lambda não é permitido neste contexto",
  "o alinhamento especificado não é equivalente à declaração anterior",
  "nenhum alinhamento especificado na definição; a declaração anterior havia especificado um alinhamento",
  "a função interna não está disponível porque não há suporte para tipos de ponto flutuante de 128 bits",
  "o deslocamento para a esquerda de um valor negativo tem comportamento indefinido",
  "os designadores de matriz estão fora do padrão do C++",
  "os designadores encadeados estão fora do padrão do C++",
  "misturar inicializadores designados e não designados está fora do padrão em C++",
  "inicializadores com problema estão fora do padrão do C++",
  "um modelo de operador literal de cadeia de caracteres precisa ter uma lista de parâmetros de modelo equivalente a '<typename T, T ...>'",
  "não são permitidos designadores duplicados",
  "o atributo está em conflito com os atributos likely/unlikely anteriores",
  "a captura por cópia implícita de 'this' foi preterida",
  "uma lista de parâmetros de modelo vazia não é permitida em uma expressão lambda",
  "a versão da Microsoft que está sendo emulada precisa ser pelo menos a 1920 para usar '--ms_c++20'",
  "Argumento pragma STDC não aceito neste modo",
  "constexpr se as instruções forem um recurso do C++17",
  "a expansão de pacote não é permitida em uma lista de inicializadores designados",
  "o designador de campo não tem nenhum valor",
  "uma união pode ter no máximo um inicializador de campo",
  "não foi encontrado nenhum tipo std::%s válido (<compare> precisa ser incluído)",
  "tipos inválidos (%t1 e %t2) para o operador interno<=>",
  "As expressões fold estão fora do padrão neste modo",
  "o diretório especificado por meio da opção --current_directory não é um diretório: %s",
  "Aviso de PCH",
  "a parada de cabeçalho precisa estar no escopo global. Não foi gerado um arquivo PCH do IntelliSense.",
  "invocação de macro em andamento. Não foi gerado um arquivo PCH do IntelliSense.",
  "a parada de cabeçalho não está no escopo do arquivo. Não foi gerado um arquivo PCH do IntelliSense.",
  "a parada de cabeçalho não pode ser um bloco #if nem uma macro. Não foi gerado um arquivo PCH do IntelliSense.",
  "a parada de cabeçalho não pode ser um bloco de vínculo. Não foi gerado um arquivo PCH do IntelliSense.",
  "não é possível localizar um local de parada de cabeçalho adequado. Não foi gerado um arquivo PCH do IntelliSense.",
  "as diretrizes de linha não podem ser usadas em um PCH. Não foi gerado um arquivo PCH do IntelliSense.",
  "especificador restrito inválido",
  "a função restrita por amp %nfd deve ser chamada por uma função restrita por amp",
  "a função %nfd1 tem especificadores de restrição que são incompatíveis com a função de chamada %nfd2",
  "nenhum candidato a sobrecarga tem especificadores restritos corretos",
  "%t não é permitido na função restrita por amp %nfd",
  "tipo ilegal %t neste ponteiro para a função membro restrita por amp %nfd",
  "tipo de retorno %t ilícito para a função restrita por amp %nfd",
  "tipo de parâmetro %t ilícito para a função restrita por amp %nfd",
  null,
  "classe de armazenamento %s ilícito na função restrita por amp %nfd",
  "%s não é permitido na função restrita por amp %nfd",
  "conversão ilícita na função restrita por amp",
  "especificação de exceção não permitida na função restrita por amp",
  "indireção ilícita na função restrita por amp %nfd",
  "as chamadas de função virtuais são ilícitas na função restrita por amp %nfd",
  "as chamadas de função indiretas são ilícitas na função restrita por amp %nfd",
  "a classe de armazenamento tile_static não é permitida aqui",
  "rótulo ilícito na função restrita por amp %nfd",
  "campo de bits ilícito para a função restrita por amp %nfd",
  "reticências ilícitas para a função restrita por amp %nfd",
  "base virtual ilícita para o tipo compatível com amp %nfd",
  "referência externa ilícita na função restrita por amp %nfd",
  "o valor constante está fora do intervalo com suporte para a função restrita por amp %nfd",
  "valor do pacote pragma %s ilícito para a função restrita por amp",
  "não é permitido sobrepor especificadores restritos",
  "os especificadores restritos do destruidor devem conter a união dos especificadores restritos em todos os construtores",
  null,
  "o nostdlib exige pelo menos um uso forçado",
  null,
  null,
  null,
  null,
  "não há suporte para especificadores de múltiplas restrições em funções \"C\" externas",
  "as funções de ponteiro para membro, os ponteiros de função e as referências a funções com especificadores de restrições por 'amp' não são permitidos",
  "a classe base, o membro de dados ou o elemento da matriz devem estar alinhados em pelo menos 4 bytes para a função restrita por amp %nfd",
  "um deslocamento de um membro de dados deve ser um múltiplo de seu alinhamento natural para a função restrita por amp %nfd",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "as variáveis de tile_static não podem ter um inicializador",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "/clr:nostdlib exige que mscorlib.dll esteja na lista de usos forçados",
  "O /clr:netcore com o /clr:nostdimport exige que o System.Runtime.dll, o System.Runtime.Extensions.dll, o System.Runtime.InteropServices.dll e o System.Runtime.CompilerServices.VisualC.dll estejam na lista de usos forçados",
  null,
  null,
  null,
  null,
  null,
  "<falha de emissão de diagnóstico>",
  "Há erros demais para o mecanismo IntelliSense para funcionar de forma adequada, alguns dos quais podem não estar visíveis no editor.",
  "a atribuição ao anacronismo 'this' não é compatível com o modo C++11",
  "erro desconhecido. Não foi gerado um arquivo PCH do IntelliSense.",
  "Um ou mais caminhos remotos não podem ser mapeados para os caminhos locais existentes. A experiência do IntelliSense pode ser degradada.",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "esperado um '>>>'",
  "não é possível localizar a declaração de __cudaPushCallConfiguration. A instalação do kit de ferramentas CUDA pode estar corrompida.",
  "O inicializador de estilo C++17 está fora do padrão neste modo",
  "a captura de *this está fora do padrão neste modo",
  "O atributo 'using' de estilo C++17 está fora do padrão neste modo",
  "Os namespaces aninhados de estilo C++17 estão fora do padrão neste modo",
  "somente uma das opções: 'constexpr', 'consteval' e 'constinit' pode aparecer em uma declaração",
  "uma função não pode ser tanto consteval quanto virtual neste modo",
  "'consteval' não é permitido em uma diretiva explícita de instanciação",
  "'consteval' não é válido aqui",
  "um destruidor não pode ser consteval",
  "um construtor para uma classe com bases virtuais não pode ser consteval",
  "'consteval' não é permitido na declaração de um membro de dados estático ou variável",
  "%nd já foi declarado como consteval",
  "%nd ainda não foi declarado como consteval",
  "a função 'main' pode não ser declarada como consteval",
  "a chamada para o consteval %n não produziu uma expressão constante válida",
  "o endereço de consteval %n no resultado da expressão constante",
  "o membro consteval não pode substituir o %n que não é consteval",
  "um membro que não seja consteval não pode substituir o consteval %n",
  "associação estruturada",
  "O dynamic_cast para o subobjeto do tipo %t1 é inválido (o tipo mais derivado é %t2)",
  "o identificador __VA_OPT__ somente pode ser exibido nas listas de substituição das macros variadic",
  "__VA_OPT__ não pode aparecer em um operando __VA_OPT__",
  "parêntese de fechamento ausente em __VA_OPT__",
  "__VA_OPT__ precisa ser seguido por '('",
  "'##' pode não estar em primeiro no operando __VA_OPT__",
  "'##' pode não estar por último no operando __VA_OPT__",
  "Os namespaces embutidos aninhados de estilo C++20 estão fora do padrão neste modo",
  "não é possível converter o ponteiro que aponta para a classe base %t2 para apontar para a classe derivada %t1 – tentativa de apontar além do objeto mais derivado",
  null,
  "'main' não pode ser usado como um nome de variável global nem receber vínculo de linguagem C",
  "a função 'main' não pode ser declarada em uma especificação de vínculo",
  "a associação estruturada não é permitida em uma condição",
  "é necessário um identificador de namespace de atributo antes de '::'",
  "somente um namespace de atributo é permitido",
  "'return' não é permitido aqui",
  "uma associação estruturada não pode ser combinada com outros declaradores",
  "não é possível ramificar um contexto de avaliação constante",
  "modelos de associação estruturada não são permitidos",
  "um inicializador entre parênteses precisa ser uma expressão, e não uma lista delimitada por chaves",
  "não é possível deduzir os argumentos de modelo de classe",
  "um operador new ou delete não pode ser declarado como 'consteval'",
  "o endereço de uma função consteval não pode ser usado aqui",
  "o alinhamento de um tipo de função (%t) não é padrão",
  "o alinhamento de uma matriz de limite não especificado não é padrão em C",
  "uma variável não pode ter os atributos 'common' e ' internal_linkage'",
  "o atributo 'internal_linkage' não apareceu em uma declaração anterior",
  "não foi encontrado nenhum candidato viável à dedução de argumento de modelo para %n",
  "uma chamada de construtor totalmente qualificada não é permitida",
  "um operador de comparação usado como padrão precisa ser um membro ou um friend da classe à qual se aplica",
  "tipo incorreto %t para o parâmetro do operador de comparação usado como padrão (precisa ser 'referência à const X', em que X é o tipo de classe delimitadora)",
  "o tipo de retorno do operador de comparação usado como padrão precisa ser 'bool'",
  "um operador de comparação de membros usado como padrão precisa ser 'const'",
  null,
  "o tipo de promessa de corrotina %t não pode ter 'return_void' e 'return_value' definidos",
  "%p declarado de 'return_value'",
  "'return_void' declarou %p",
  "instrução co_return ausente enquanto %t não tem 'return_void' no final de %n",
  "não foi encontrada nenhuma variante nothrow do 'operador new' global para a alocação de estado da corrotina",
  "não foi encontrado nenhum 'operador delete' viável para a desalocação de estado da corrotina",
  "uma função constexpr não pode ser uma corrotina",
  "o operando desta expressão %s é resolvido para a não classe %t",
  "uma expressão co_await não é permitida em um inicializador estático",
  "a expressão co_await que chama %n não pode ser de geração",
  "muitas operações de regravação de comparação recursivas",
  "um tipo de retorno deduzível para um operador padrão <=> precisa ser 'auto'",
  "cópia implícita de uma fonte não constante",
  "uma associação estruturada não pode declarar uma classe de armazenamento explícita que não seja static ou thread_local",
  "os operadores de comparação usados como padrão não são compatíveis com os campos de propriedade da Microsoft não triviais",
  "o tipo de comparação padrão (%t) precisa ser um tipo de classe com um único membro de dados não estáticos do tipo integral",
  "não foi encontrado nenhum membro de dados estáticos de constexpr %sq em %t",
  "número de elementos (%d) muito grande para alocação dinâmica",
  "a solicitação de alocação dinâmica constexpr é muito grande",
  "desalocação de armazenamento que não foi alocado dinamicamente",
  "o tamanho da desalocação (%d1) não corresponde ao tamanho alocado (%d2)",
  "alocação ocorrida aqui",
  "o tipo de desalocação (%t1) não corresponde ao tipo de alocação (%t2)",
  "algumas alocações dinâmicas (número total = %d) não foram desalocadas",
  "%n intrínseco declarado com assinatura inesperada (tipo %t)",
  ">> saída de std:: __report_constexpr_value",
  ">> encerrar saída de std::__report_constexpr_value",
  "não é possível usar a matriz com tamanho de matriz dependente na avaliação constexpr",
  "ignorando o valor retornado da rotina declarada com o atributo 'nodiscard' (%sq)",
  "ignorando o tipo de valor retornado com atributo 'nodiscard' (%sq)",
  "o construtor usado para criar o objeto descartado tem o atributo 'nodiscard'",
  "o construtor usado para criar o objeto descartado tem o atributo 'nodiscard' (%sq)",
  "o tipo de objeto descartado tem o atributo 'nodiscard'",
  "o tipo de objeto descartado tem o atributo 'nodiscard' (%sq)",
  "uma referência de pseudodestruidor pode ser usada somente para uma chamada pseudodestruidor",
  "uma chamada de destruidor explícita não é permitida em uma expressão constante",
  "um operador de vírgula que não está entre parênteses em uma expressão de subscrito de matriz está preterido",
  "número de elementos alocados dinamicamente (%d) muito pequeno para o inicializador",
  "um operando volátil da expressão %s está preterido",
  "o uso do resultado de uma atribuição para um objeto volátil escalar está preterido",
  "um tipo de destino volátil para uma expressão de atribuição composta foi preterido",
  "um parâmetro de função volátil está preterido",
  "um tipo de retorno volátil está preterido",
  "o uso de um qualificador volátil em uma associação estruturada está preterido",
  "o argumento 'ext_vector_type' deve estar entre 1 e 2047",
  "o atributo 'ext_vector_type' pode aparecer somente em um typedef",
  "o atributo 'ext_vector_type' se aplica somente a tipos inteiro ou de ponto flutuante",
  "esta macro de teste de recurso é ignorado (e retorna 0) no modo de compilação atual",
  "não é possível avaliar um inicializador agregado com vários elementos para uma união",
  "O %nd selecionado para a regravação do operador não retorna o tipo bool",
  "uma nova expressão que chama uma função de alocação específica da classe não pode ser avaliada como constante",
  "uma nova expressão de posicionamento não pode ser avaliada como constante",
  "excluir por meio de um ponteiro de subobjeto exige um destruidor virtual",
  "%npTd, com argumentos revertidos",
  "o operando de __INTADDR__ precisa ser deslocado do ponteiro nulo",
  "O constructo _genérico corresponde a vários tipos",
  "a outra correspondência é %t",
  "o atributo 'availability' usado aqui é ignorado",
  "A instrução inicializadora no estilo C++20 em uma instrução 'for' com base em intervalos não é padrão neste modo",
  "co_await pode ser aplicado somente a uma instrução 'for' baseada em intervalos",
  "não é possível deduzir o tipo de intervalo no loop 'for' com base em intervalos",
  "as variáveis embutidas são um recurso do C++17",
  "a destruição do operador de exclusão exige %t como primeiro parâmetro",
  "a destruição de um operador de exclusão não pode ter parâmetros diferentes de std::size_t e std::align_val_t",
  "opções de classe abstrata reduzidas podem ser usadas somente ao compilar C++",
  "início de expressão inválido na cláusula requires",
  "uma expressão de conversão em uma cláusula requires precisa estar entre parênteses",
  "este operador não pode aparecer no nível superior (sem parênteses) em uma cláusula requires",
  "a restrição atômica precisa ter o tipo bool",
  "falha na substituição de restrição atômica",
  "restrição atômica não constante",
  "a restrição atômica é avaliada como false",
  "restrição de modelo não satisfeita",
  "a definição do conceito não pode aparecer neste escopo",
  "redeclaração inválida de %nd",
  "falha na substituição de argumentos %T da ID do conceito",
  "o conceito é falso para argumentos %T",
  "uma cláusula requires não é permitida aqui (não é uma função de modelo)",
  "modelo de conceito",
  "cláusula requires incompatível com %nfd",
  "um atributo é esperado",
  null,
  "um nome de tipo é esperado",
  "um parâmetro de reticências não é permitido em uma expressão requires",
  "o parâmetro sem nome na expressão requires não tem efeito",
  "um nome de conceito é esperado",
  "a chamada para %s que aparece em uma expressão de constante sempre produz 'true'",
  "a chamada para %s que aparece em um contexto consteval sempre produz 'true'",
  "a chamada para %s que aparece em uma função não constexpr sempre produz 'false'",
  "falha na restrição de tipo para %t",
  "a opção 'export' não pode ser usada em modos em que os módulos C++ estão habilitados",
  "uma declaração de fragmento de módulo global precisa preceder qualquer outra declaração",
  "uma declaração de módulo só pode ser precedida por um fragmento de módulo global",
  "um fragmento de módulo privado precisa ser precedido por uma declaração de módulo",
  "não é possível exportar um fragmento de módulo %s",
  "não é possível declarar mais de um módulo",
  "não é possível declarar mais de um fragmento de módulo %s",
  "um módulo precisa ser declarado com um nome não vazio",
  "%sq não é um cabeçalho importável",
  "não é possível importar um módulo sem nome",
  "um módulo não pode ter uma dependência de interface em si mesmo",
  "o módulo %sq já foi importado",
  "arquivo de módulo",
  "não foi possível localizar o arquivo de módulo para o módulo %sq",
  "não foi possível importar o arquivo de módulo %sq",
  "era esperado %s1, foi encontrado %s2",
  "ao abrir o arquivo de módulo %sq",
  "nome de partição desconhecido %sq",
  "um arquivo de módulo desconhecido",
  "um arquivo de módulo de cabeçalho importável",
  "um arquivo de módulo EDG",
  "um arquivo de módulo IFC",
  "um arquivo de módulo inesperado",
  "o tipo do segundo operando %t2 precisa ter o mesmo tamanho que %t1",
  "o tipo precisa ser fácil de ser copiado",
  "no momento, não há suporte para o tipo %t para a avaliação constexpr de __builtin_bit_cast",
  "no momento, não há suporte para os tipos de classe com bitfields %t na avaliação constexpr de __builtin_bit_cast",
  "o membro de dados não estático do tipo de referência %t impede a avaliação constexpr de __builtin_bit_cast",
  "um tipo volátil %t impede a avaliação constexpr de __builtin_bit_cast",
  "um tipo de união, ponteiro ou ponteiro para membro %t impede a avaliação constexpr de __builtin_bit_cast",
  "%npTd, herdado por meio do uso de decl %p",
  "a construção de subobjeto de %t para construtores herdados não pode ser executada. O construtor padrão implícito foi excluído",
  "%n precisa retornar nulo",
  "declaração de início de membro inválida",
  "'auto' era esperado",
  "este operador não é permitido neste ponto; coloque parênteses na nova expressão anterior",
  "uso inválido do conceito",
  "um operador de comparação de membros usado como padrão não pode ser qualificado por '&&'",
  "a função de comparação constexpr padrão chama a função não constexpr %nd",
  "Só há suporte para a comparação de memória constexpr para os objetos inteiros ou matriz de inteiro",
  "um modelo de conceito não pode ter restrições associadas",
  "'export' não é permitido",
  "a exportação de membros de classe individuais não é permitida",
  "uma declaração exportada precisa introduzir um nome",
  "uma declaração export não pode conter uma declaração export (declaração anterior %p)",
  "uma declaração de exportação não pode conter uma declaração de importação de módulo",
  "uma declaração export só pode aparecer em uma unidade de interface de módulo",
  "uma declaração export não pode exportar um nome com vínculo interno",
  "a declaração using inclui %nfd",
  "a função interna não está disponível porque não há suporte para tipos de ponto flutuante __fp16",
  "uma expressão requires precisa especificar pelo menos um requisito",
  "'constinit' não é válido aqui",
  "'constinit' só é válido para declarações de variáveis com duração de armazenamento estática ou de thread",
  "a variável constinit requer uma inicialização dinâmica",
  "a variável foi declarada anteriormente com 'constinit' %p",
  "uso de declarador de função sem protótipo",
  "o argumento não pode ter um tipo qualificado como const",
  "um ponteiro para membro de um tipo incompleto %t não é permitido",
  "a expansão de pacote em init-capture não está habilitada neste modo",
  "a expansão de pacote em init-capture é um recurso do C++20",
  "um operador de comparação usado como padrão em uma definição de classe precisa ser a primeira declaração desse operador de comparação (%nd)",
  "uma expansão de pacote em um init-capture pode ser usada somente em um modelo variádico",
  "a restrição de tipo usa %nd, que não é um conceito de tipo (ou seja, um modelo de conceito cujo primeiro parâmetro é um parâmetro de tipo)",
  "falha do tipo de espaço reservado deduzido %t na restrição de tipo",
  "o construtor padrão de %t não é qualificado",
  "o destruidor de %t é ambíguo devido a restrições não ordenadas",
  "o destruidor de %t é inelegível devido a falhas de restrições",
  "candidato a destruidor ambíguo",
  "uma função virtual não pode ter uma cláusula requires à direita",
  "%nd não satisfaz as respectivas restrições",
  "o resultado do qualificador decltype %t não é uma classe nem uma enumeração",
  "a comparação é ambígua no padrão de C++20 porque o operador de comparação implícito com parâmetros invertidos é uma correspondência igualmente boa. Isso geralmente é causado por um qualificador 'const' ausente no operador de comparação. Confira %nod",
  "ID do conceito inválida",
  "falha na substituição de argumentos %T da cláusula requires",
  "as restrições de %nd não estão satisfeitas",
  "o tipo de variável %t na função constexpr tem classes base virtuais",
  "uma expressão de constante não pode alocar um subobjeto base virtual (para o tipo %t)",
  "um parâmetro de modelo de tipo de classe precisa ser do tipo de classe estrutural",
  "o suporte para literais UTF-8 exige o suporte para o literal u.",
  "o mapeamento de arquivo de módulo de '%s' foi especificado mais de uma vez",
  "o mapeamento de unidade de cabeçalho de '%s' foi especificado mais de uma vez",
  "não foi especificado nenhum mapeamento para '%s'",
  "o mapeamento de arquivo de módulo de '%s' é inválido",
  "não é possível localizar o cabeçalho '%s' a ser importado",
  "mais de um arquivo na lista de arquivos de módulo corresponde a '%s'",
  "o arquivo de módulo encontrado para '%s' é de um módulo diferente",
  "qualquer tipo de arquivo de módulo",
  "não é possível ler o arquivo de módulo",
  "a função interna não está disponível porque não há suporte para o tipo char8_t com as opções atuais",
  "a opção da linha de comando --ms_await não poderá ser especificada se as corrotinas do C++20 estiverem habilitadas",
  "o uso não padrão do construtor explícito %nod para inicialização do elemento de agregação padrão",
  "a origem ou o destino do intrínseco similar a memcpy não aponta para um objeto",
  "tentativas intrínsecas similares a memcpy de copiar tipos representacionalmente distintos %t1 e %t2",
  "tentativas intrínsecas similares a memcpy de copiar o tipo não trivialmente copiável %t",
  "tentativas intrínsecas similares a memcpy de copiar objetos parciais",
  "tentativas intrínsecas similares a memcpy de copiar o limite de matriz passado",
  "tentativas intrínsecas similares a memcpy de copiar intervalos de bytes sobrepostos (usando a operação de memmove correspondente, em vez disso)",
  "uma declaração de friend com uma cláusula requires à direita precisa ser uma definição",
  "a expressão precisa ter tipo aritmético ou de ponteiro, mas tem o tipo %t",
  "a expressão precisa ter tipo aritmético, de enumeração ou de ponteiro, mas tem o tipo %t",
  "expressão precisa ter o tipo aritmético, de enumeração sem escopo ou de ponteiro, mas tem o tipo %t",
  "a expressão precisa ter um tipo de ponteiro, mas tem o tipo %t",
  "operador -> ou ->* aplicado a %t em vez de a um tipo de ponteiro",
  "o tipo de classe incompleta %t não é permitido",
  "não é possível interpretar o layout de bit para este destino de compilação",
  "nenhum operador correspondente para o operador IFC %sq",
  "não há convenção de chamada correspondente para a convenção de chamada IFC %sq",
  "o módulo %sq contém constructos sem suporte",
  "constructo IFC sem suporte: %sq",
  "__is_signed não é mais uma palavra-chave deste ponto",
  "uma dimensão de matriz precisa ter um valor inteiro sem sinal constante",
  "O arquivo IFC %sq tem uma versão sem suporte %d1.%d2",
  "os módulos não estão habilitados neste modo",
  "'import' não é permitido em um nome de módulo",
  "'module' não é permitido em um nome de módulo",
  null,
  null,
  "O %n não é um tipo de enumeração",
  "o enumerador %no2 entra em conflito com %n1",
  "o enumerador %no já foi declarado neste escopo %p",
  "a especificação 'throw()' não faz parte de C++ 20 e posteriores",
  "mais de uma entrada no mapa de unidades de cabeçalho corresponde a '%s'",
  "diagnóstico #pragma deve ter argumento 'push' ou 'pop'",
  "nenhum 'diagnóstico push #pragma' foi encontrado para corresponder a esae 'pop de diagnóstico'",
  "o %sq não pode ser uma macro quando for usado em uma diretiva de importação ou módulo",
  "essa diretiva só pode aparecer no escopo de namespace global",
  "uma declaração 'exportar' só pode aparecer no escopo global ou de namespace",
  "%sq é analisado como um identificador em vez de uma palavra-chave porque os tokens que o seguem não correspondem aos de uma diretiva de pré-processador",
  "parece que esse é o início de uma diretiva de pré-processador, mas a falta de um '; ' seguido imediatamente por uma nova linha evita que",
  "parece ser uma diretiva de pré-processamento de módulos, mas essas diretivas não podem aparecer dentro de uma expansão de macro",
  "uma diretriz 'módulo' não pode aparecer dentro do escopo de inclusão condicional (por exemplo, #se, #outro, #outrose, etc.)",
  "a importação de %sq foi ignorada",
  "tipo promise %t deve declarar get_return_object_on_allocation_failure como uma função membro estática que não requer argumentos",
  "um modelo de alias não pode ser explicitamente especializado",
  "para corresponder a este '{'",
  "nesta invocação de macro",
  "a chamada requer uma conversão de argumento ambígua",
  "declaração pertencente ao módulo %s está em conflito com %nd",
  "a declaração de propriedade do módulo global está em conflito %nd pertencente a um módulo nomeado",
  "o primeiro argumento para um atributo 'malloc' deve ser uma função",
  "não é possível capturar %nod",
  "não é possível capturar 'this'",
  "já no contexto consteval",
  "'if consteval' e 'if not consteval' exigem instruções dependentes entre chaves",
  "'if consteval' e 'if not consteval' são sem sentido em uma função não constexpr",
  "a transferência de controle para uma instrução 'if consteval' ou 'if not consteval' não é permitida",
  "a avaliação constante não pode passar pela declaração de uma variável com duração estática ou de armazenamento de thread",
  "o qualificador mutável não é permitido em um lambda com um parâmetro 'this' explícito",
  "uma função membro declarada com 'static' não pode ter um parâmetro 'this' explícito",
  "um parâmetro 'this' explícito deve ser o primeiro parâmetro declarado",
  "'this' não é permitido aqui",
  "uma função de comparação com 'this' explícito não pode ser padrão",
  "uma função 'this' explícita requer um operando de seletor",
  "'if consteval' e 'if not consteval' não são padrão neste modo",
  "omitir '()' em um declarador lambda não é padrão neste modo",
  "uma cláusula-requer à direita não é permitida quando a lista de parâmetros lambda é omitida",
  "módulo %sq partição inválida solicitada",
  "módulo %sq1 partição indefinida (acredita-se que seja %sq2) solicitada",
  "módulo %sq1 posição de arquivo %d1 (posição relativa %d2) solicitada para a partição %sq2 - que está vazia",
  "módulo %sq1 posição de arquivo %d1 (posição relativa %d2) solicitada para a partição %sq2 - que impede o início da partição",
  "módulo %sq1 posição de arquivo %d1 (posição relativa %d2) solicitada para a partição %sq2 - que estoura o final de sua partição",
  "módulo %sq1 posição de arquivo %d1 (posição relativa %d2) solicitada para a partição %sq2 - que está desalinhada com seus elementos de partições",
  "do subcampo %sq (posição relativa ao nó %d)",
  "da partição %sq elemento %d1 (posição do arquivo %d2, posição relativa %d3)",
  "os atributos lambda não são padrão aqui",
  "O identificador %sq pode ser confundido com um visualmente semelhante ao que aparece %p",
  "este comentário contém caracteres de controle de formatação Unicode suspeitos",
  "essa cadeia de caracteres contém caracteres de controle de formatação Unicode que podem resultar em comportamento de runtime inesperado",
  "%d1 aviso suprimido encontrado durante o processamento do módulo %sq1",
  "%d1 avisos suprimidos foram encontrados durante o processamento do módulo %sq1",
  "%d1 erro suprimido encontrado ao processar o módulo %sq1",
  "%d1 erros suprimidos foram encontrados durante o processamento do módulo %sq1",
  "incluindo",
  "suprimida",
  "uma função membro virtual não pode ter um parâmetro 'this' explícito",
  "usar o endereço de uma função explícita 'this' requer um nome qualificado",
  "formar o endereço de uma função 'this' explícita requer o operador '&'",
  "um literal de cadeia de caracteres não pode ser usado para inicializar um membro de matriz flexível",
  "A representação IFC da definição da função %sq é inválida",
  "foi feita uma correção para descartar um parâmetro 'this' implícito",
  "um gráfico UNILevel IFC não foi usado para especificar parâmetros",
  "%d1 parâmetros foram especificados pelo gráfico de definição de parâmetro IFC, enquanto %d2 parâmetros foram especificados pela declaração IFC",
  "O parâmetro %d1 foi especificado pelo gráfico de definição de parâmetro IFC, enquanto %d2 parâmetros foram especificados pela declaração IFC",
  "%d1 parâmetros foram especificados pelo gráfico de definição de parâmetro IFC, enquanto o parâmetro %d2 foi especificado pela declaração IFC",
  "A representação IFC da definição da função %sq está ausente",
  "o modificador de função não se aplica à declaração de modelo do membro",
  "a seleção de membro envolve muitos tipos anônimos aninhados",
  "não há nenhum tipo comum entre os operandos",
  "esperava-se um ponteiro para membro",
  "um membro da matriz flexível não pode ser declarado em um tipo de outro modo vazio",
  "esperado que 'std::source_location::__impl' seja definido para uma classe com apenas os membros de dados '_M_function_name', '_M_file_name', '_M_column', '_M_line'",
  "durante a inicialização de 'std::source_location::__impl', o número da coluna estoura o membro '_M_column' do tipo %t",
  "durante a inicialização de 'std::source_location::__impl', o número da linha estoura o membro '_M_line' do tipo %t",
  "uma constante de caractere UTF-16 não pode ocupar mais de uma unidade de código; valor truncado",
  "ambos os argumentos devem ter o mesmo tipo",
  "o tipo %téinválido como argumento para este builtin",
  "chamado de %nd:",
  "um tipo qualificado não é padrão para campos de bits anônimos",
  "o tipo de elemento da condição de vetor (%t1) deve ter o mesmo tamanho que o tipo de elemento do resultado (%t2)",
  "o tipo de operando vetorial de ponto flutuante (%t) não tem nenhum tipo de vetor inteiro correspondente",
  "a estruturação para expressões 'requires' ainda não foi implementada",
  "devido a um atributo 'indisponível'",
  "tentou construir um elemento da partição IFC %sq usando um índice na partição IFC %sq",
  "a partição %sq especificou seu tamanho de entrada como %d1 quando %d2 era esperado",
  "um requisito IFC inesperado foi encontrado durante o processamento do módulo %sq1",
  "condição falhou na linha %d em %s1: %sq2",
  "restrição atômica depende de si mesma",
  "A função 'noreturn' tem um tipo de retorno não nulo",
  "foi feita uma correção eliminando o parâmetro %sq (no índice relativo %d)",
  "nome de identificador IFC inválido %sq encontrado durante a reconstrução da entidade",
  "identificador IFC inválido chamado %sq ignorado durante a reconstrução da entidade",
  "valor de classificação inválido do módulo %sq",
  "um modelo de função carregado de um módulo IFC foi analisado incorretamente como %nd",
  "falha ao carregar uma referência de entidade IFC no módulo %sq",
  "Classificação do índice IFC = %d1, valor = %d2"
]