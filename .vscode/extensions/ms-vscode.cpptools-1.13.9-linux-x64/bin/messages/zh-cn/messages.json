[
  "未知错误",
  "文件的最后一行结束，没有新行",
  "文件的最后一行以反斜杠结束",
  "#include 文件 %sq 包含自身",
  "内存不足",
  null,
  "文件结尾的注释未闭合",
  "无法识别的标记",
  "缺少右引号",
  "不允许使用嵌套注释",
  "此处不需要“#”",
  "无法识别的预处理指令",
  "出现前面的语法错误之后，在此处重新开始分析",
  "应输入文件名",
  "预处理指令的预期结尾后有多余文本",
  null,
  null,
  "应输入“]”",
  "应输入“)”",
  "编号的预期结尾后有多余文本",
  "未定义标识符 %sq",
  "此声明中的类型限定符毫无意义",
  "无效的十六进制数",
  "整数常量太大",
  "无效的八进制数字",
  "带引号的字符串应至少包含一个字符",
  "字符常量中的字符过多",
  "字符值超出范围",
  "表达式必须含有常量值",
  "应输入表达式",
  "浮点常量超出范围",
  "表达式必须包含整型",
  "表达式必须包含算术类型",
  "应输入行号",
  "行号无效",
  "#error 指令:  %s",
  "缺少该指令的 #if",
  "缺少该指令的 #endif",
  "不允许指令 - 已出现 #else",
  "除数为零",
  "应输入标识符",
  "表达式必须包含算术或指针类型",
  "操作数类型不兼容(%t1 和 %t2)",
  null,
  "表达式必须包含指针类型",
  "#undef 不能在该预定义名称上使用",
  "%no 已预定义；已忽略重定义尝试",
  "宏 %nod 的重定义不兼容",
  null,
  "重复的宏参数名",
  "“##”不能为宏定义中的第一项",
  "“##”不能为宏定义中的最后一项",
  "应输入宏参数名",
  "应输入“:”",
  "%n 调用中的参数太少",
  "%n 调用中的参数太多",
  "sizeof 的操作数不能是函数",
  "常量表达式中不允许该运算符",
  "预处理表达式中不允许该运算符",
  "常量表达式中不允许函数调用",
  "整型常量表达式中不允许该运算符",
  "整数运算结果超出范围",
  "Shift 计数为负",
  "Shift 计数过大",
  "声明未声明任何内容",
  "应输入“;”",
  "枚举值超出“int”范围",
  "应输入“}”",
  "整数转换导致符号更改",
  "整数转换导致截断",
  "不允许使用不完整的类型",
  "sizeof 的操作数不能是位域",
  null,
  null,
  null,
  "\"*\" 的操作数必须是指针，但它具有类型 %t",
  "宏参数为空",
  "此声明没有存储类或类型说明符",
  "参数声明不能包含初始值设定项",
  "应输入类型说明符",
  "此处不能指定存储类",
  "不能指定多个存储类",
  "存储类不是第一个",
  "多次指定类型限定符",
  "类型说明符的组合无效",
  "参数的存储类无效",
  "函数的存储类无效",
  "此处不能使用类型说明符",
  "不允许使用函数数组",
  "不允许使用 void 数组",
  "不允许使用返回函数的函数",
  "不允许使用返回数组的函数",
  "标识符列表参数只能在函数定义中使用",
  "函数类型不能来自 typedef",
  "数组的大小必须大于零",
  "数组太大",
  "翻译单元必须至少包含一个声明",
  "函数不能返回此类型的值",
  "数组不能包含此类型的元素",
  "此处的声明必须声明参数",
  "重复的参数名",
  "已在当前范围内声明 %sq",
  "枚举类型的前向声明不标准",
  "类太大",
  "结构或联合太大",
  "位域的大小无效",
  "位域的类型无效",
  "零长度位域必须未命名",
  "长度为 1 的有符号位域",
  "明显调用的表达式前的括号必须具有(指针)函数类型",
  "应输入定义或标记名",
  "语句无法访问",
  "应输入“while”",
  null,
  "引用了 %n 但未对其进行定义",
  "continue 语句只能在循环中使用",
  "break 语句只能在循环或开关中使用",
  "非 void %n 应返回值",
  "void 函数不能返回值",
  "不允许强制转换到类型 %t",
  "返回值类型与函数类型不匹配",
  "case 标签只能在开关内使用",
  "默认标签只能在开关内使用",
  null,
  "默认标签已出现在此开关中",
  "应输入“(”",
  "表达式必须是左值",
  "应输入一个语句",
  "循环无法访问",
  "block-scope 函数只能包含外部存储类",
  "应输入“{”",
  "表达式必须包含指向类的指针类型，但它具有类型 %t",
  "表达式必须包含指向结构或联合的指针类型，但它具有类型 %t",
  "应输入成员名",
  "应输入字段名",
  "%n 没有成员 %sq",
  "%n 没有字段 %sq",
  "表达式必须是可修改的左值",
  "不允许采用寄存器变量的地址",
  "不允许采用位域的地址",
  "函数调用中的参数太多",
  "存在正文时不允许未命名的原型参数",
  "表达式必须包含指向对象的指针类型，但它具有类型 %t",
  "程序过大或过于复杂，无法编译",
  "%t1 类型的值不能用于初始化 %t2 类型的实体",
  "未能初始化 %n",
  "初始值设定项值太多",
  "声明与 %nfd 不兼容",
  "%n 已初始化",
  "全局范围的声明不能包含此存储类",
  "类型名称不能重新声明为参数",
  "typedef 名称不能重新声明为参数",
  "非零整数到指针的转换",
  "表达式必须具有类类型，但它具有类型 %t",
  "表达式必须具有结构或联合类型，但它具有类型 %t",
  "旧式的赋值运算符",
  "旧式的初始值设定项",
  "表达式必须为整型常量表达式",
  "表达式必须为左值或函数指示符",
  "声明与前面的 %nod 不兼容",
  "外部名称与 %nd 的外部名称相冲突",
  "无法识别的 #pragma",
  null,
  "未能打开临时文件 %sq:  %s2",
  "临时文件的目录名称太长(%sq)",
  "函数调用中的参数太少",
  "浮点常量无效",
  "%t1 类型的实参与 %t2 类型的形参不兼容",
  "此处不允许函数类型",
  "应输入声明",
  "指针指向基础对象之外",
  "类型转换无效",
  "外部/内部链接与之前的声明 %p 冲突",
  "浮点值不适合于所需的整型",
  "表达式不起任何作用",
  "下标超出范围",
  null,
  "%n 已声明但从未引用",
  "应用于数组的“&”不起任何作用",
  "“%%”的右操作数为零",
  "实参与形参不兼容",
  "参数与对应的格式字符串转换不兼容",
  "未能打开源文件 %sq (搜索列表中没有目录)",
  "强制转换的类型必须为整型",
  "强制转换的类型必须为算术或指针",
  "动态初始化的代码无法访问",
  "无符号整数与零的比较没有意义",
  "使用“=”但可能误认为是“==”",
  "枚举类型与另一种类型混合",
  "写入 %s 文件时出错",
  "中间语言文件无效",
  "强制转换类型上的类型限定符毫无意义",
  "不可识别的字符转义序列",
  "零用于未定义的预处理标识符 %sq",
  "应输入 asm 字符串",
  "asm 函数必须为原型",
  "asm 函数不能包含省略号",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "删除文件 %sq 时出错:  %s2",
  "整数值不适合于所需的浮点类型",
  "浮点值不适合于所需的浮点类型",
  "浮点运算结果超出范围",
  "函数 %sq 已隐式声明",
  "格式字符串需要其他参数",
  "格式字符串在此参数之前结束",
  "格式字符串转换无效",
  "宏递归",
  "尾随逗号不标准",
  "位域不能包含所有枚举类型值",
  "位域的非标准类型",
  "声明在函数外部不可见",
  "已忽略“void”的旧式 typedef",
  "左操作数不是包含此字段的结构或联合",
  "指针未指向包含此字段的结构或联合",
  "变量 %sq 是使用从未完成的类型声明的",
  "控制表达式是常量",
  "选择器表达式是常量",
  "参数的说明符无效",
  "类声明外部的说明符无效",
  "声明中的说明符重复",
  "联合不可以包含基类",
  "不允许使用多个访问控制说明符",
  "缺少类或结构定义",
  "限定名不是类 %t 或其基类的成员",
  "非静态成员引用必须与特定对象相对",
  "非静态数据成员不能在其类的外部定义",
  "%n 已定义",
  "不允许使用指向引用的指针",
  "不允许使用对引用的引用",
  "不允许使用对 void 的引用",
  "不允许使用引用的数组",
  "引用 %n 需要初始值设定项",
  "应输入“,”",
  "不允许使用类型名",
  "不允许使用类型定义",
  "类型名 %nod 的重新声明无效",
  "常量 %n 需要初始值设定项",
  "“this”只能用于非静态成员函数内部",
  "常量值未知",
  "缺少显式类型(假定“int”)",
  "未指定访问控制(默认为 %sq)",
  "不是类名或结构名",
  "基类名重复",
  "基类无效",
  "%nd 不可访问",
  "%no 不明确",
  "旧式参数列表(记时错误)",
  "声明不能出现在块中可执行语句之后",
  "不允许对不可访问的基类 %t 进行转换",
  null,
  null,
  null,
  null,
  "错误地终止了宏调用",
  null,
  "后面有“::”的名称一定是类名或命名空间名",
  "友元声明无效",
  "构造函数或析构函数不能返回值",
  "析构函数声明无效",
  "成员的声明与其类具有相同名称",
  "不允许使用全局范围限定符(前导符为“::”)",
  "全局范围没有 %sq",
  "不允许使用限定名",
  "不允许使用 null 引用",
  "不允许使用“{...}”对 %t 类型的对象进行初始化",
  "基类 %t 不明确",
  "派生类 %t1 包含类 %t2 的多个实例",
  "无法将指向基类 %t2 的指针转换为指向派生类 %t1 的指针 -- 基类是虚拟的",
  "没有与参数列表匹配的构造函数 %no 实例",
  "类 %t 的复制构造函数不明确",
  "类 %t 不存在默认构造函数",
  "%sq 不是类 %t 的非静态数据成员或基类",
  "不允许使用间接非虚拟基类",
  "联合成员无效 -- 类 %t 包含不允许的成员函数",
  null,
  "使用的非左值数组无效",
  "应输入运算符",
  "不允许使用继承成员",
  "无法确定需要哪个 %n 实例",
  "指向绑定函数的指针只能用于调用函数",
  "已声明 typedef 名称(使用相同类型)",
  "%n 已定义",
  null,
  "没有与参数列表匹配的 %n 实例",
  "函数返回类型声明中不允许类型定义",
  "默认实参不在形参列表的结尾",
  "重新定义默认参数",
  "有多个 %n 实例与参数列表匹配:",
  "有多个构造函数 %no 的实例与参数列表匹配:",
  "%t1 类型的默认实参与 %t2 类型的形参不匹配",
  "无法重载仅按返回类型区分的函数",
  "不存在用户定义的从 %t1 到 %t2 的适当转换",
  null,
  "仅非静态成员函数可以是虚拟的",
  "对象包含与成员函数不兼容的类型限定符",
  "程序太大，无法编译(虚拟函数过多)",
  "返回类型与重写虚拟函数 %no 的返回类型 %t 既不相同，也不协变",
  "虚拟函数 %n 的重写不明确",
  "仅虚拟函数允许纯说明符(“= 0”)",
  "纯说明符格式错误(仅允许“= 0”)",
  "不允许使用数据成员初始值设定项",
  "不允许使用抽象类类型 %t 的对象:",
  "不允许使用返回抽象类 %t 的函数:",
  "重复的友元声明",
  "仅函数声明中允许内联说明符",
  "不允许使用“内联”",
  "内联函数的存储类无效",
  "类成员的存储类无效",
  "局部类成员 %n 需要定义",
  "%nfd 不可访问",
  null,
  "类 %t 没有复制构造函数，无法复制常量对象",
  "不允许定义隐式声明的成员函数",
  "类 %t 没有适当的复制构造函数",
  "不允许使用链接规范",
  "未知外部链接规范",
  "链接规范与前面的 %nod 不兼容",
  "重载函数 %no 的多个实例包含“C”链接",
  "类 %t 包含多个默认构造函数",
  "值已复制到临时目录，使用了到临时目录的引用",
  "“operator%s”必须是成员函数",
  "运算符不能是静态成员函数",
  "用户定义的转换中不允许使用参数",
  "此运算符函数的参数太多",
  "此运算符函数的参数太少",
  "非成员运算符需要具有类类型的参数",
  "不允许使用默认参数",
  "应用多个用户定义的从 %t1 到 %t2 的转换:",
  "没有与这些操作数匹配的 %sq 运算符",
  "有多个运算符 %sq 与这些操作数匹配:",
  "分配函数的第一个参数必须是“size_t”类型",
  "分配函数需要“void *”返回类型",
  "解除分配函数需要“void”返回类型",
  "解除分配函数的第一个参数必须是“void *”类型",
  null,
  "类型必须是对象类型",
  "基类 %t 已初始化",
  "需要基类名 -- 假定 %t (记时错误)",
  "%n 已初始化",
  "缺少成员名或基类名",
  "分配到“this”(记时错误)",
  "使用了“overload”关键字(记时错误)",
  "匿名联合无效 -- 不允许使用非公共成员",
  "匿名联合无效 -- 不允许使用成员函数",
  "必须静态声明全局或命名空间范围的匿名联合",
  "%nf 未提供初始值设定项:",
  "无法初始化为类 %t 隐式生成的构造函数:",
  "%n 未定义用于初始化下列内容的构造函数:",
  "%n 包含未经初始化的常量或引用成员",
  "%n 包含未经初始化的常量字段",
  "类 %t 没有用于复制常量对象的赋值运算符",
  "类 %t 没有适当的赋值运算符",
  "类 %t 的赋值运算符不明确",
  null,
  "声明需要 typedef 名称",
  null,
  "不允许使用“virtual”",
  "不允许使用“static”",
  "绑定函数强制转换到正常函数指针(计时错误)",
  "表达式必须包含指向成员的指针类型",
  "已忽略额外的“;”",
  "非静态成员的 in-class initializer 是非标准的",
  null,
  "没有与参数列表匹配的重载 %no 实例",
  null,
  "没有与所需类型匹配的 %n 实例",
  "所用 delete array size 表达式(计时错误)",
  null,
  "不允许强制转换到抽象类 %t:",
  "不能调用函数“main”或提取其地址",
  "不能为数组指定新的初始值设定项",
  "不能在成员函数 %no 的类外部重新声明该函数",
  "不允许指针指向不完整的类类型 %t",
  "不允许引用封闭函数的局部变量",
  "对后缀 %sq 使用了单参数函数(计时错误)",
  null,
  "无法复制隐式生成的赋值运算符:",
  "强制转换为数组类型是非标准的(视为强制转换为 %t)",
  "%n 具有运算符 new%s() 但没有默认运算符 delete%s()",
  "%n 具有默认运算符 delete%s() 但没有运算符 new%s()",
  "基类 %nod 的析构函数不是虚拟的",
  null,
  "成员 %npd 的重新声明无效",
  "函数“main”不能以内联方式声明",
  "与其类具有相同名称的成员函数一定是构造函数",
  "正在使用嵌套 %n (计时错误)",
  "析构函数不能带有参数",
  "类 %t 的复制构造函数不能带有 %t 类型的参数",
  "%n 返回不完整的类型 %t",
  "受保护的 %nd 不能通过 %t 指针或对象访问",
  "不允许使用参数",
  "此处不允许使用“asm”声明",
  "不存在从 %t1 到 %t2 的适当转换函数",
  "删除指向不完整类的指针",
  "不存在从 %t1 转换到 %t2 的适当构造函数",
  "多个构造函数应用于从 %t1 到 %t2 的转换: ",
  "应用了多个从 %t1 到 %t2 的转换函数: ",
  "应用了多个从 %t 到内置类型的转换函数:",
  "常量 %n",
  "引用 %n",
  "%npTd",
  "内置运算符 %sq",
  "%nod，通过继承但含义不明确",
  "构造函数或析构函数不能提取其自身的地址",
  null,
  "临时用于非常量引用的初始值(计时错误)",
  "成员声明中不允许限定名",
  "枚举类型与另一个种类型混用(计时错误)",
  "“new”中数组的大小必须为非负值",
  "返回对本地临时内存的引用",
  null,
  "不允许“enum”声明",
  "将 %t1 类型的引用绑定到 %t2 类型的初始值设定项时，限定符被丢弃",
  "无法用 %t2 类型的值初始化 %t1 类型的引用(非常量限定)",
  "不能删除指向函数的指针",
  "转换函数必须是非静态成员函数",
  "此处不允许模板声明",
  "应输入“<”",
  "应输入“>”",
  "缺少模板参数声明",
  "缺少 %nf 的参数列表",
  "%nf 的参数太少",
  "%nf 的参数太多",
  null,
  "%n1 未用于声明 %n2 的参数类型",
  "两种嵌套类型具有相同名称:  %no1 和 %nod2 (cfront 兼容性)",
  "全局 %no1 在嵌套 %nod2 之后声明(cfront 兼容性)",
  null,
  "有多个 %n 实例与所需类型匹配",
  "类型“long long”是非标准的",
  "%sq 的省略是非标准的",
  "不能对转换函数指定返回类型",
  "检测时间:",
  "%nt %p 的实例化",
  "%nt %p 的隐式生成",
  "%n 实例化时过渡递归",
  "%sq 不是函数或静态数据成员",
  "%t1 类型的实参与 %t2 类型的模板形参不兼容",
  "不允许需要临时类型或转换的初始化",
  "%sq 的声明隐藏了函数参数",
  "非常量引用的初始值必须为左值",
  "%nt %p 的隐式定义",
  "不允许使用“template”",
  "%t 不是类模板",
  null,
  "“main”不是函数模板的有效名称",
  "%n 的无效引用(联合/非联合不匹配)",
  "模板参数不能引用局部类型",
  "%s 的标记种类与 %nfd 的声明不兼容",
  "全局范围没有名为 %sq 的标记",
  "%n 没有名为 %sq 的标记成员",
  "成员函数 typedef (允许 cfront 兼容性)",
  "%n 只能在指向成员的指针声明中使用",
  null,
  "模板参数不能封引用非外部实体",
  "后面紧跟“::~”的名称必须是类名或类型名",
  null,
  "用作析构函数名称的类型与类型 %t 不匹配",
  "%n 在调用“inline”之后对其进行重新声明",
  null,
  "模板声明的存储类无效",
  "%nd 是不可访问的类型(允许 cfront 兼容性)",
  null,
  "显式实例化声明无效",
  "%nf 不是可实例化的实体",
  "无法显式实例化生成 %n 的编译器",
  "无法显式实例化内联 %n",
  null,
  "无法实例化 %n -- 未提供模板定义",
  "无法实例化 %n -- 已显示专用化",
  null,
  null,
  "没有与指定类型匹配的 %n 实例",
  "使用 typedef 声明 void 参数列表是非标准的",
  "使用了全局 %n1 而未使用 %n2 (cfront 兼容性)",
  "不能在此范围内重新声明模板参数 %sq",
  "%sq 的声明隐藏了模板参数",
  "模板实参列表必须与形参列表匹配",
  null,
  "后缀“operator%s”的额外参数必须是“int”类型",
  "运算符名称必须声明为函数",
  "不允许使用运算符名称",
  "%n 无法在当前范围内专用化",
  "用于提取成员函数地址的非标准形式",
  "模板参数太少 -- 与前面的声明(声明了 %p)不匹配",
  "模板参数太多 -- 与前面的声明(声明了 %p)不匹配",
  "不允许使用运算符 delete(void *) 的函数模板",
  "类模板和模板参数不能具有相同名称",
  null,
  "模板参数不能引用未命名类型",
  "枚举类型上的此操作需要适用于用户定义的运算符函数",
  "不允许引用类型上的类型限定符",
  "不能将 %t1 类型的值分配到 %t2 类型的实体",
  "无符号整数和负常量的比较毫无意义",
  "无法转换到不完整的类 %t",
  "常量对象需要初始值设定项",
  "对象包含未经初始化的常量或引用成员",
  "非标准的预处理指令",
  "%n 不能包含模板参数列表",
  "应使用“{...}”初始化聚合对象",
  "指向成员的指针选择类类型是不兼容的(%t1 和 %t2)",
  "毫无意义的友元声明",
  "使用“.”代替“::”构成限定名",
  "对常量对象调用非常量函数(计时错误)",
  "从属语句不能是声明",
  "参数不能为 void 类型",
  "%na %p 的实例化",
  "正在处理 %na %p 的模板参数列表",
  "模板参数表达式中不允许使用此运算符",
  "try 块至少需要一个处理程序",
  "处理程序需要异常声明",
  "处理程序由默认处理程序屏蔽",
  "处理程序由类型 %t 的前一个处理程序潜在屏蔽",
  "使用局部类型指定异常",
  "异常规范中的冗余类型",
  "异常规范与前面 %nd%s 的异常规范不兼容",
  "之前已指定:  不会引发异常",
  "之前已省略:  %t",
  "之前已指定但此处省略:  %t",
  "禁用对异常处理的支持",
  "允许所有异常与以前的 %nd 不兼容",
  "未能创建实例化请求文件 %sq",
  "非类型模板参数中不允许执行非算术运算",
  "使用局部类型声明非局部变量",
  "使用局部类型声明函数",
  "控制传输跳过的实例化:",
  "%nd",
  "控制传输到异常处理程序",
  "在设置 %n 值之前使用了它",
  "设置了 %n 但从未使用",
  "当前范围内无法定义 %n",
  "不允许使用异常规范",
  "%nfd 的外部/内部链接冲突",
  "不会调用 %nf 进行隐式或显式转换",
  "%s 的标记种类与 %t 类型的模板参数不兼容",
  "不允许使用运算符 new(size_t) 的函数模板",
  null,
  "不允许使用指向 %t 类型成员的指针",
  "运算符函数参数列表中不允许使用省略号",
  "已保留 %no 供将来用作关键字",
  "宏定义无效: %s",
  "取消宏定义无效: %s",
  null,
  null,
  "必须指定 IL 文件名，如果输入为 ",
  null,
  null,
  null,
  null,
  "调试选项参数出现错误",
  "选项无效: %s",
  "后端需要 IL 文件名",
  "无法打开 IL 文件 %s",
  "数值无效: %s",
  "主机 CPU ID 不正确",
  "实例化模式无效: %s",
  null,
  "错误限制无效: %s",
  null,
  null,
  null,
  null,
  null,
  null,
  "虚拟函数表只能在编译 C++ 时取消",
  "计时错误选项只能在编译 C++ 时使用",
  "实例化模式选项只能在编译 C++ 时使用",
  "自动实例化模式只能在编译 C++ 时使用",
  "隐式模板包含模式只能在编译 C++ 时使用",
  "异常处理选项只能在编译 C++ 时使用",
  "严格模式与 KR 模式不兼容(&R)",
  "严格模式与 cfront 模式不兼容",
  "缺少源文件名",
  "编译多个输入文件时不能指定输出文件",
  "命令行中的参数太多",
  "已指定输出文件，但不需要",
  "IL 显示需要 IL 文件名",
  "模板参数不能为 void 类型",
  "由于 instantiate-all 模式导致过渡递归 %n 的实例化",
  "严格模式与允许的计时错误不兼容",
  "throw 表达式不能为 void 类型",
  "本地实例化模式与自动实例化不兼容",
  "不允许使用抽象类类型 %t 的参数:",
  "不允许使用抽象类 %t 数组:",
  "浮点模板参数是非标准的",
  "此 pragma 前面必须紧跟声明",
  "此 pragma 前面必须紧跟语句",
  "此 pragma 前面必须紧跟声明或语句",
  "此处不能使用该种类的 pragma",
  null,
  "重载虚拟函数 %no1 仅在 %n2 中部分重写",
  "必须在首次使用之前对内联模板函数进行特定定义",
  "诊断控制选项中的错误标记无效: %s",
  "诊断控制选项中的错误号无效: %s",
  null,
  null,
  "指向成员函数的指针强制转换到指向函数的指针",
  "结构或联合未声明已命名成员",
  "非标准未命名字段",
  "非标准未命名成员",
  null,
  null,
  null,
  "%sq 不是类型名",
  "无法打开预编译的标头输入文件 %sq:  %s2",
  "预编译标头文件 %sq 无效或不是由此版本编译器生成的",
  "预编译标头文件 %sq 不是在此目录中生成的",
  "用于生成预编译标题文件 %sq 的标头文件已更改",
  "命令行选项与创建预编译标头文件 %sq 时使用的选项不匹配",
  "预处理目录的初始序列与预编译标头文件 %sq 的初始序列不匹配",
  "无法获取映射的内存",
  "“%s”:  正在使用预编译的标头文件“%s”",
  "“%s”:  正在创建预编译的标头文件“%s”",
  "内存使用率与预编译标头文件 %sq 冲突",
  "PCH 内存大小无效: %s ",
  "PCH 选项必须出现在命令行的首位",
  "内存不足，无法分配 PCH 内存",
  "编译多个输入文件时不能使用预编译的标头文件",
  "预分配内存不足，无法生成预编译标头文件(需要 %s 个字节)",
  "程序中的实体太大，阻止了预编译头文件的生成",
  "%sq 不是有效目录",
  "无法生成临时文件名",
  "不允许使用“restrict”",
  "函数类型的指针或引用不能由“restrict”限定",
  null,
  "此处不能指定调用约定修饰符",
  "冲突的调用约定修饰符",
  "严格模式与 Microsoft 模式不兼容",
  "cfront 模式与 Microsoft 模式不兼容",
  "已忽略此处指定的调用约定",
  "调用约定后面不能是嵌套声明符",
  "已忽略此类型的调用约定",
  null,
  "声明修饰符与前面的声明不兼容",
  "此声明中不允许使用 %sq 修饰符",
  "将控制传输到 try 块",
  "内联规范与前面的 %nod 不兼容",
  "未找到模板定义的右大括号",
  "wchar_t 关键字选项只能在编译 C++ 时使用",
  "封装对齐值无效",
  "应输入整数常量",
  "纯虚拟函数调用",
  "源文件标识符字符串无效",
  "友元声明中不能定义类模板",
  "不允许使用“asm”",
  "“asm”必须与函数定义一起使用",
  "“asm”函数是非标准的",
  "没有显式参数的省略号是非标准的",
  "“&...”是非标准的",
  "“&...”使用无效",
  null,
  "临时用于 const volatile 引用的初始值(计时错误)",
  "%t1 类型的引用无法使用 %t2 类型的值初始化",
  "const volatile 引用的初始值必须为左值",
  "SVR4 C 兼容性选项只能在编译 ANSI C 时使用",
  "使用超出范围的 %nd 声明",
  "严格模式与 SVR4 C 模式不兼容",
  "无法内联 %nd 的调用",
  "%n 无法进行内联",
  "PCH 目录无效: %s",
  "应输入 __except 或 __finally",
  "__leave 语句只能在 __try 中使用",
  "在 %nt %p 实例化期间检测",
  "在 %nt %p 隐式生成期间检测",
  "在 %na %p 实例化期间检测",
  "在处理 %na %p 的模板参数列表期间检测",
  "在 %nt %p 隐式定义期间检测",
  "程序包对齐堆栈上未找到 %sq",
  "空程序包对齐堆栈",
  "RTTI 选项只能在编译 C++ 时使用",
  "复制已消除内容的 %nfd 不可访问",
  "复制已消除内容的 %nf 不可调用，因为无法将引用参数绑定到右值",
  "使用 typeid 之前必须包含 <typeinfo>",
  "%s 无法丢掉常量或其他类型限定符",
  "dynamic_cast 中的类型必须是指向完整类类型或 void * 的指针或引用",
  "指针 dynamic_cast 的操作数必须是指向完整类类型的指针",
  "引用 dynamic_cast 的操作数必须是完整类类型的左值",
  "运行时 dynamic_cast 的操作数必须包含多态类类型",
  "bool 选项只能在编译 C++ 时使用",
  null,
  "此处不允许使用数组类型",
  "应输入“=”",
  null,
  "在条件中声明的 %sq 不能在此范围内重新声明",
  "函数模板不允许使用默认的模板参数",
  "应输入“,”或“>”",
  "应提供模板参数列表",
  "递增 bool 值已否决",
  "不允许使用 bool 类型",
  "类 %no2 内的基类 %no1 的偏移量太大",
  "表达式必须包含 bool 类型(或可转换为 bool)",
  "数组新建和删除选项只能在编译 C++ 时使用",
  "%n 不是变量名",
  "此处不允许使用 __based 修饰符",
  "__based 不在指针运算符之前，已忽略 __based",
  "in __based 修饰符中的变量必须包含指针类型",
  "const_cast 中的类型必须是指针、引用或指向对象类型成员的指针",
  "const_cast 只能调节类型限定符；不能更改基础类型",
  "不允许可变",
  "不允许重新声明 %n 来改变其访问",
  null,
  "无意使用了替代标记“<:”",
  "无意使用了替代标记“%%:”",
  "不允许进行命名空间定义",
  "名称必须是命名空间名",
  "不允许进行命名空间别名定义",
  "需要限定的命名空间名",
  "不允许使用命名空间名",
  "DLL 特性组合无效",
  "%n 不是类模板",
  "具有不完整元素类型的数组是非标准的",
  "不能在命名空间中声明分配运算符",
  "不能在命名空间中声明解除分配运算符",
  "%np1 与 %np2 的 using 声明冲突",
  "%np1 的 using 声明与 %npd2 冲突",
  "namespaces 选项只能在编译 C++ 时使用",
  "已忽略 using 声明 -- 它指的是当前命名空间",
  "需要类限定名",
  "参数类型为:  (%s)",
  "操作数类型为:  %s",
  null,
  "%n 没有实际成员 %sq",
  null,
  "指定了不兼容的内存特性",
  "已忽略内存特性",
  "内存特性后面不能是嵌套声明符",
  "内存特性指定了多次",
  "调用约定指定了多次",
  "不允许使用类型限定符",
  "使用 %npd1 时尚未声明其模板",
  "不能重载具有相同参数类型的静态和非静态成员函数",
  "之前为声明 %np",
  "不允许使用模板 ID",
  "不允许使用类限定名",
  "不能在当前范围内重新声明 %n",
  "命名空间成员声明中不允许使用限定名",
  "%n 不是类型名",
  "当前范围内不允许显式实例化",
  "%n 不能在当前范围内显式实例化",
  "多次显式实例化了 %n",
  "类型名称只能自模板内使用",
  "special_subscript_cost 选项只能在编译 C++ 时使用",
  "typename 选项只能在编译 C++ 时使用",
  "隐式 typename 选项只能在编译 C++ 时使用",
  "非标准符号位于类似对象的宏定义开头",
  "虚拟 %n1 的异常规范与重写 %n2 的异常规范不兼容",
  "从指向较小整数的指针转换",
  "隐式声明的虚拟 %n1 的异常规范与重写 %n2 的异常规范不兼容",
  "从 %np2 隐式调用的 %no1 不明确",
  "选项“explicit”只能在编译 C++ 时使用",
  "不允许使用“explicit”",
  "声明与 %sq 冲突(已保留类名)",
  "仅允许“()”用作数组 %n 的初始值设定项",
  "函数模板声明中不允许使用“virtual”",
  "匿名联合无效 -- 不允许使用类成员模板",
  "模板嵌套深度与前面的 %n 声明不匹配",
  "此声明不能含有多个“template <...>”子句",
  "用于控制 for-init 范围的选项只能在编译 C++ 时使用",
  "在 for-loop 实例化中声明的 %sq 不能在此范围内重新声明",
  "引用是对 %nd1 的引用 -- 根据旧的 for-init 范围规则，它应该引用 %nd2",
  "用于控制有关 for-init 差异的警告的选项只能在编译 C++ 时使用",
  "此处需要虚拟 %n 的定义",
  "空注释解释为 token-pasting 运算符“##”",
  "友元声明中不允许使用存储类",
  "此声明中不允许使用 %no 的模板参数列表",
  "%n 不是有效的类成员模板",
  "不是有效的成员类或函数模板声明",
  "包含模板参数列表的模板声明不能后跟显式专用化声明",
  "%n1 的显式专用化必须在首次使用 %n2 之前",
  "当前范围内不允许显式专用化",
  "不允许 %n 的部分专用化",
  "%nf 不是可显式专用化的实体",
  "%n 的显式专用化必须在其首次使用之前",
  "模板参数 %sq 不能在详细说明的类型说明符中使用",
  "专用化 %n 需要“template<>”语法",
  null,
  null,
  "选项“old_specializations”只能在编译 C++ 时使用",
  "不使用“template<>”语法专用化 %n 是非标准的",
  "此声明不能包含外部“C”链接",
  "%sq 不是当前范围内的类或函数模板名称",
  "重新声明未引用的函数模板时指定默认参数是非标准的",
  "不允许在重新声明已引用的函数模板时指定默认参数",
  "无法将指向基类 %t2 的成员的指针转换为指向派生类 %t1 的成员的指针 -- 基类是虚拟的",
  "异常规范与 %nd%s 的异常规范不兼容",
  "允许所有异常与 %nd 不兼容",
  "默认参数表达式意外结束",
  "不允许引用的默认初始化",
  "未初始化的 %n 包含常量成员",
  "未初始化的基类 %t 包含常量成员",
  "常量 %n 需要初始值设定项 -- 类 %t 没有用户提供的默认构造函数",
  "常量对象需要初始值设定项 -- 类 %t 没有用户提供的默认构造函数",
  "选项“implicit_extern_c_type_conversion”只能在编译 C++ 时使用",
  "严格模式与 long 保留规则不兼容",
  "返回类型上的类型限定符毫无意义",
  "函数定义中不允许“void”返回类型上的类型限定符",
  "此类中不允许静态数据成员声明",
  "模板实例化导致函数声明无效",
  "不允许使用“...”",
  "选项“extern_inline”只能在编译 C++ 时使用",
  "已引用外部内联 %n 但未对其进行定义",
  "类型 %t 的析构函数名无效",
  null,
  "析构函数引用不明确 -- %n1 和 %n2 都可以使用",
  "从未定义虚拟内联 %n",
  "%n 从未引用",
  "只能在构造函数初始值设定项列表中指定联合的一个成员",
  "已禁用对“new[]”和“delete[]”的支持",
  "“double”用于生成的 C 代码中的“long double”",
  "%n 没有对应的运算符 delete%s (在已分配对象的初始化过程中丢弃异常时将被调用)",
  "已禁用对位置删除的支持",
  "看不到适当的运算符删除",
  "不允许使用指向不完整类型的指针或引用",
  "部分专用化无效 -- %n 已完全专用化",
  "不兼容的异常规范",
  "正在返回对局部变量的引用",
  "显式类型的省略是非标准的(假定“int”)",
  "有多个部分专用化与 %n 的模板参数列表匹配",
  "%nod",
  "主模板的声明中不允许使用模板参数列表",
  "部分专用化不能带有默认模板参数",
  "%n1 未在 %n2 的模板参数列表中使用或无法从中推导",
  null,
  "部分专用化的模板实参列表包含类型取决于模板形参的非类型实参",
  "此部分专用化将用于实例化 %n",
  "此部分专用化会使 %n 的实例化不明确",
  "表达式必须包含整数或枚举类型",
  "表达式必须包含算法或枚举类型",
  "表达式必须包含算法、枚举或指针类型",
  "强制转换的类型必须是整数或枚举",
  "强制转换的类型必须是算法、枚举或指针",
  "表达式必须是指向完整对象类型的指针",
  null,
  "部分专用化非类型实参必须是非类型形参的名称或常量",
  "返回类型与重写虚拟函数 %no 的返回类型 %t 不相同",
  "选项“guiding_decls”只能在编译 C++ 时使用",
  "类模板的部分专用化必须在其成员命名空间中声明",
  "%n 是纯虚拟函数",
  "纯虚拟 %n 没有强制替代项",
  "已忽略 __declspec 特性",
  "输入行中存在无效字符",
  "函数返回不完整的类型 %t",
  "此“#pragma pack”指令的效果是本地到 %n",
  "%s 不是模板",
  "友元声明不能声明部分专用化",
  "已忽略异常规范",
  "“size_t”的声明与所需类型 %t 不匹配",
  "嵌套模板参数列表的相邻“>”分隔符之间需要空格(“>>”是右移运算符)",
  "未能将区域设置 %sq 设置为允许处理多字节字符",
  "多字节字符序列无效",
  "模板实例化导致意外的函数类型 %t1 (名称的含义可能自模板声明后已更改 -- 模板的类型是 %t2)",
  "不明确的导向声明 -- 多个函数模板 %no 与类型 %t 匹配",
  "非类型模板参数中不允许执行非整数运算",
  "选项“embedded_c++”只能在编译 C++ 时使用",
  "Embedded C++ 不支持模板",
  "Embedded C++ 不支持异常处理",
  "Embedded C++ 不支持命名空间",
  "Embedded C++ 不支持运行时类型信息",
  "Embedded C++ 不支持新的 cast 语法",
  "Embedded C++ 不支持使用声明",
  "Embedded C++ 不支持“mutable”",
  "Embedded C++ 不支持多个或虚拟继承",
  "Microsoft 版本号无效: %s",
  "已设置指向成员的指针表示形式 %sq (对 %n )",
  "%t1 无法用于为 %t2 指定构造函数",
  "整数常量上存在无效后缀",
  "__uuidof 的操作数必须包含已指定 __declspec(uuid('...')) 的类或枚举类型",
  "__declspec(uuid('...')) 中的 GUID 字符串无效",
  "选项“vla”只能在编译 C 时使用",
  "不允许使用带有未指定绑定的变长数组",
  "此声明中不允许使用显式模板参数列表",
  "带有链接的实体不能包含涉及变长数组的类型",
  "变长数组不能包含静态存储持续时间",
  "%n 不是模板",
  "变长数组维度(已声明 %p)",
  "应指定模板参数",
  null,
  "非成员运算符要求类类型或枚举类型的参数",
  "选项“enum_overloading”只能在编译 C++ 时使用",
  null,
  "析构函数名称 %t1 的限定符与类型 %t2 不匹配",
  "已忽略类型限定符",
  "选项 \"nonstd_qualifier_deduction\" 只能在编译 C++ 时使用",
  "不能定义声明“dllimport”的函数",
  "属性规范不正确；正确的格式为 __declspec(property(get=名称 1,put=名称 2))",
  "属性已指定",
  "此声明中不允许使用 __declspec(property)",
  "成员已使用 __declspec(property) 声明，但未指定“get”函数",
  "缺少 __declspec(property)“get”函数 %sq",
  "成员已使用 __declspec(property) 声明，但未指定“put”函数",
  "缺少 __declspec(property)“put”函数 %sq",
  "不明确的类成员引用 -- 在对 %nd2 的引用中使用的 %nd1",
  null,
  null,
  null,
  "无法将指向派生类 %t1 的成员的指针转换到指向基类 %t2 的成员的指针 -- 基类是虚拟的",
  "实例化文件的目录无效: %s",
  "选项 \"one_instantiation_per_object\" 只能在编译 C++ 时使用",
  null,
  null,
  "编译多个输入文件时不能指定实例化信息文件名",
  "选项 \"one_instantiation_per_object\" 不能在编译多个输入文件时使用",
  "多个命令行选项与缩写词“--%s”匹配:",
  "--%s",
  "已忽略函数类型上的类型限定符",
  null,
  "late/early tiebreaker 选项只能在编译 C++ 时使用",
  "va_start 用法不正确",
  "va_arg 用法不正确",
  "va_end 用法不正确",
  "挂起的实例化选项只能在编译 C++ 时使用",
  "#import 文件的目录无效: %s",
  "导入目录只能在 Microsoft 模式中指定",
  "联合中不允许使用带有引用类型的成员",
  "此处不能指定“typedef”",
  "%n 的重新声明更改了其访问方式",
  "需要类或命名空间限定名",
  "返回类型“int”在函数“main”的声明中已省略",
  "指向成员的指针表示方法 %sq 对于 %n 而言限制性太大",
  "非 void %n 结尾缺少 return 语句",
  "已忽略 %no 的重复 using 声明",
  "枚举位域始终不带符号，但是枚举 %t 包含负的枚举数",
  "选项“class_name_injection”只能在编译 C++ 时使用",
  "选项“arg_dep_lookup”只能在编译 C++ 时使用",
  "选项“friend_injection”只能在编译 C++ 时使用",
  "“template”后面的名称必须是模板",
  null,
  "非标准局部类友元声明 -- 封闭范围中没有上一个声明",
  "在此声明上指定默认参数是非标准的",
  "选项“nonstd_using_decl”只能在编译 C++ 时使用",
  "函数“main”的返回类型必须是“int”",
  "非类型模板参数不能为类类型",
  "不能在类外部的类模板成员声明上指定默认模板参数",
  "构造函数的函数 try 块的处理程序中不允许使用 return 语句",
  "初始值设定项指定中不能组合一般或扩展指示符",
  "第二个下标一定不能比第一个下标小",
  null,
  "选项 \"extended_designators\" 只能在编译 C 时使用",
  "位域的声明大小大于位域类型的大小；截断为 %s 位",
  "用作构造函数名的类型与类型 %t 不匹配",
  "使用没有链接的类型声明带有链接的变量",
  "使用没有链接的类型声明函数",
  "不能在构造函数上指定返回类型",
  "不能在析构函数上指定返回类型",
  "通用字符名的格式不正确",
  "通用字符名指定的字符无效",
  "通用字符名不能指定基本字符集中的字符",
  "标识符中不允许使用此通用字符",
  "标识符 __VA_ARGS__ 只能出现在可变参数宏中的替换列表中",
  "已忽略此友元声明上的限定符",
  "无法将数组范围指示符应用到动态初始值设定项",
  "此处不能出现属性名",
  "已忽略用作函数限定符的“inline”",
  "选项“compound_literals”只能在编译 C 时使用",
  "不允许使用变长数组类型",
  "整型常量表达式中不允许使用复合文字",
  "不允许使用 %t 类型的复合文字",
  "无法在局部类中声明模板友元声明",
  "不明确的“?”操作: 无法将 %t1 类型的第二个操作数转换为第三个操作数类型 %t2，反之亦然",
  "在没有适当 operator() 的情况下调用类类型的对象或将函数转换到指向函数的类型",
  "从转换 %np 代理函数",
  "有多种方法可以为参数列表调用 %t 类型的对象:",
  "typedef 名称已声明(使用类似类型)",
  "运算符 new 和运算符 delete 无法提供内部链接",
  "匿名联合不允许存储类“mutable”",
  "预编译标头文件无效",
  "不允许将抽象类类型 %t 作为 catch 类型:",
  "无法使用限定函数类型声明非成员函数或静态成员函数",
  "无法使用限定函数类型声明参数",
  "无法创建指向限定函数类型的指针或引用",
  "多余大括号是非标准的",
  "宏定义无效: %s",
  "指针类型 %t1 和 %t2 的减法是非标准的",
  "模板 template 参数声明中不允许使用空模板参数列表",
  "应输入“class”",
  "声明模板 template 参数时不能使用 \"struct\" 关键字",
  "%np2 由 %no1 隐藏 -- 重写虚拟函数?",
  "作为函数定义的友元声明不允许限定名",
  "%n1 与 %n2 不兼容",
  "此处不能指定存储类",
  "由 using 声明指定的类成员必须在直接基类中可见",
  null,
  "Sun 模式与 cfront 模式不兼容",
  "严格模式与 Sun 模式不兼容",
  "仅编译 C++ 时允许使用 Sun 模式",
  "模板 template 参数不能与其模板参数之一具有相同名称",
  "默认参数的递归实例化",
  null,
  "%n 不是可定义的实体",
  "析构函数名必须是限定的",
  "友元类名不能使用“typename”引入",
  "using 声明不能命名构造函数或析构函数",
  "限定的友元模板声明必须指代具体的前面已经声明的模板",
  "类模板声明中的说明符无效",
  "实参与形参不兼容",
  "选项“dep_name”只能在编译 C++ 时使用",
  "“operator->”函数序列中的循环以类 %t1 开始",
  "%n 没有成员类 %sq",
  "全局范围没有名为 %sq 的类",
  "模板默认参数的递归实例化",
  "访问声明和 using 声明不能出现在联合中",
  "%no 不是类成员",
  "不允许非标准成员常量声明",
  "选项“ignore_std”只能在编译 C++ 时使用",
  "选项“parse_templates”只能在编译 C++ 时使用",
  "选项“dep_name”无能与“no_parse_templates”一起使用",
  "指定的语言模式不兼容",
  "嵌套类重新声明无效",
  "不允许使用包含未知大小数组的类型",
  "不能在内联函数中定义具有静态存储持续时间的变量",
  "具有外部链接的内联函数中不能引用具有内部链接的实体",
  "参数类型 %t 与此常规类型的函数宏不匹配",
  "变长数组 %nod",
  "友元声明无法向以前的声明添加默认参数",
  "无法在此范围内声明 %n",
  "保留的标识符 %sq 只能在函数内部使用",
  "此通用字符无法开始标识符",
  "应输入字符串文本",
  "无法识别的 STDC pragma",
  "应为“ON”、“OFF”或“DEFAULT”",
  "STDC pragma 只能出现在全局范围声明之间或块范围内的任意语句或声明之前",
  "va_copy 用法不正确",
  "%s 只能与浮点类型一起使用",
  "不允许使用复杂类型",
  "指示符种类无效",
  "无法确切表示浮点值",
  "复杂浮点运算结果超出范围",
  "实部和虚部之间的转换生成零",
  "无法为可变数组成员指定初始值设定项",
  "imaginary *= imaginary 将左操作数设置为零",
  "标准要求后续声明(假定“int”)为 %n 提供一种类型",
  "内联 %n 需要定义",
  "从整数转换到较小指针",
  "浮点类型必须包含在 _Complex 或 _Imaginary 类型的类型说明符中",
  "匿名联合中无法声明类型",
  "返回指向局部变量的指针",
  "返回指向本地临时目录的指针",
  "选项“export”只能在编译 C++ 时使用",
  "选项“export”不能与“no_dep_name”一起使用",
  "选项“export”不能与“implicit_include”一起使用",
  "%n 的声明与其他翻译单元中的声明不兼容",
  "其他声明是 %p",
  "在编译辅助翻译单元 %sq 期间检测",
  "编译辅助翻译单元 %sq",
  "字段声明不能包含涉及变长数组的类型",
  "%n 的声明具有不同的含义(在编译 %sq 期间)",
  "应输入“template”",
  "“export”不能在显式实例化中使用",
  "“export”不能在此声明上使用",
  "不能将未命名命名空间成员声明为“export”",
  "定义模板后不能将其声明为“export”",
  "声明不能包含标签",
  "禁用对导出模板的支持",
  null,
  "%n 已在编译 %sq 期间定义",
  "%n 已在其他翻译单元中定义",
  "非静态局部变量不能在 __based 规范中使用",
  "用于列出生成文件依赖项的选项不能在编译多个翻译单元时指定",
  null,
  "用于生成预处理输出的选项不能在编译多个翻译单元时指定",
  "与其类型具有相同名称的字段不能在包含用户声明的构造函数的类中声明",
  "不能在编译多个翻译单元时使用“implicit_include”",
  "导出的模板文件 %sq 已损坏",
  "无法实例化 %n -- 已经在包含导出定义的翻译单元中对其进行显式专用化",
  "对象类型是:  %s",
  "对象含有与成员 %n 不兼容的类型限定符",
  "没有与参数列表和对象匹配的 %n 实例(对象包含阻止匹配的类型限定符)",
  "某种特性指定了与 %t 不兼容的模式",
  "没有指定宽度的类型",
  "特性指定的对齐值无效",
  "%t 的特性无效",
  null,
  null,
  "特性 %sq 未采用参数",
  null,
  "应输入特性名",
  "未知特性 %sq",
  "此处不能出现特性",
  "特性 %sq 的参数无效",
  null,
  "在“goto *expr”中，expr 必须包含类型“void *”",
  "“goto *expr”是非标准的",
  "提取标签的地址是非标准的",
  "文件名指定不止一次: %s",
  "#warning 指令:  %s",
  null,
  "“transparent_union”特性仅适用于联合，%t 不是联合",
  "已忽略不完整类型的“transparent_union”特性",
  "%t 不能是透明的，因为 %n 与第一个字段大小不相同",
  "%t1 不能是透明的，因为它含有与第一个字段大小不相同的 %t2 类型的字段",
  null,
  "特性 %sq 不适用于局部变量",
  "函数定义中不允许特性",
  null,
  "大小比较范围中的第二个常量必须大于第一个常量",
  "函数定义中不允许使用 asm 名称",
  "已忽略 typedef 中的 asm 名称",
  "未知的寄存器名“%s”",
  null,
  "未知的 asm 约束修饰符“%s”",
  "未知的 asm 约束字母“%s”",
  "asm 操作数没有约束字母",
  "asm 输出操作数必须包含“=”或“+”修饰符之一",
  "asm 输入操作数不能包含“=”或“+”修饰符",
  null,
  null,
  "寄存器“%s”使用了多次",
  "寄存器“%s”已使用且强制改写",
  "寄存器“%s”强制改写了多次",
  "寄存器“%s”具有固定用途，不能在 asm 语句中使用",
  "寄存器“%s”具有固定用途，不能在 asm 语句中强制改写",
  "必须完全省略空的强制改写列表",
  "应指定 asm 操作数",
  "应指定要强制改写的寄存器",
  "“format”特性需要省略号参数",
  "第一个替换参数不是第一个可变参数",
  "格式实参索引大于形参数目",
  "格式参数不是字符串类型",
  "用于语法歧义的“template”关键只能在模板中使用",
  "调试选项必须在要使用的 db_opt pragma 的命令行中指定",
  null,
  "特性 %sq 不适用于非函数类型 %t",
  "指向 void 或函数类型的指针的算法",
  "存储类必须是 auto 或 register",
  "传递省略号参数时 %t1 将提升到 %t2；请使用后一种类型",
  "%sq 不是基类成员",
  "__super 不能出现在“::”后面",
  "__super 只能在类范围内使用",
  "__super 后面必须是“::”",
  "[ %d 实例化上下文未显示]",
  "损坏的名称太长",
  "声明别名为未定义的实体 %sq",
  "声明与其别名 %n 不匹配",
  "声明为别名的实体不能包含定义",
  "变长数组字段类型将被视为零长度数组字段类型",
  "已忽略对左值的非标准强制转换",
  "无法识别的标志名称: %s",
  "无法限定 void 返回类型",
  "已忽略此处的 auto 说明符(在标准 C/C++ 中无效)",
  "已忽略未指定“packed”特性时的缩减对齐",
  "与 %no 对应的成员模板声明为其他翻译单元中不同种类的模板",
  "已忽略多余初始值设定项",
  "va_start 只能出现在带有省略号参数的函数中",
  "“short_enums”选项仅在 GNU C 和 GNU C++ 模式中有效",
  "行号 %s2 处的导出信息文件 %sq1 无效",
  "仅块范围内允许语句表达式",
  "来自翻译单元 ",
  "已忽略非寄存器自动变量的 asm 名称",
  null,
  "无法识别的 UPC pragma",
  "共享块大小与前面指定的块大小不匹配",
  "加括号的表达式假定为块大小规范而非数组维度",
  "共享数组的块大小必须大于零",
  "不允许多个块大小",
  "严格或宽松需要共享",
  "此上下文中不允许使用 THREADS",
  "指定的块大小超过 %s 的最大值",
  "不允许使用返回共享类型的函数",
  null,
  "线程数为非常量时，共享类型的一个数组维度必须是多个 THREADS",
  "结构或联合内部不允许共享类型",
  "参数不能为共享类型",
  "动态 THREADS 维度需要有限的块大小",
  "共享变量必须为静态或外部的",
  "upc_blocksizeof 的参数是指向共享类型的指针(不是共享类型本身)",
  "已忽略嵌套 upc_forall 中的关联表达式",
  "不允许分支到 upc_forall 循环或从中分支出来",
  "关联表达式必须为共享类型或指向共享类型",
  "关联包含共享类型(而非指向共享的指针)",
  "只能比较共享的 void* 类型是否相等",
  "UPC 模式与 C++ 和 KR 模式不兼容(&R)",
  "已忽略输入行中的 null (零)字符",
  "字符串或字符常量中的字符为 null (零)",
  "标头名称中的字符为 null (零)",
  "for-initializer 中的声明隐藏了周边范围中的声明",
  "隐藏声明是 %p",
  "进行此非原型重新声明之后，将忽略 %nfd 的原型声明",
  null,
  "%npd 必须含有外部 C 链接",
  "变量声明隐藏了 for-initializer 中的声明",
  "typedef %sq 不能在详细类型说明符中使用",
  "已忽略零常量调用",
  "不能在函数 try 块的 catch 语句中重新声明参数 %sq",
  "%n 的初始显式专用化必须在包含模板的命名空间中声明",
  "已忽略“cc”强制改写",
  "“template”后面必须为标识符",
  "此上下文中不允许使用 MYTHREAD",
  "布局限定符不能限定指向共享类型的指针",
  "布局限定符不能限定不完整的数组",
  "%sq 的声明隐藏了处理程序参数",
  "已忽略到数组类型非标准强制转换",
  "此 pragma 不能在 _Pragma 运算符中使用(必须使用 #pragma 指令)",
  "字段使用基类的末尾填充",
  "GNU C++ 编译器可以使用位域填充",
  "%nd 声明为已否决",
  "非静态成员声明中不允许使用 asm 名称",
  "已忽略无法识别格式的函数类型 %sq",
  "基类 %no1 使用基类 %no2 的尾部填充",
  "“init_priority”特性只能用于静态数据成员和类类型的命名空间范围变量的定义",
  "已将请求的初始化优先级保留为供内部使用",
  "此匿名联合/结构字段由 %nd 隐藏",
  "错误号无效",
  "错误标记无效",
  "应输入错误号或错误标记",
  "类的大小受尾部填充影响",
  "只能在函数定义中引用标签",
  "不允许将控制传输到语句表达式",
  null,
  "语句表达式内部不允许使用此语句",
  "无法在语句表达式内部定义完全无法复制的类",
  null,
  "语句表达式内部不允许使用动态初始化的局部静态变量",
  "语句表达式内部不允许使用变长数组",
  "默认参数内部不允许使用语句表达式",
  "指向函数的指针和指向数据的指针之间的非标准转换",
  "接口类型不能包含虚拟基类",
  "接口类型不能指定“private”或“protected”",
  "接口类型只能从其他接口类型派生",
  "%t 是接口类型",
  "接口类型不能包含 typedef 成员",
  "接口类型不能包含用户声明的构造函数或析构函数",
  "接口类型不能包含用户声明的成员运算符",
  "接口类型不能在函数中声明",
  null,
  "接口类型不能包含数据成员",
  "接口类型不能包含友元声明",
  null,
  "接口类型不能为嵌套类类型",
  "接口类型不能包含成员模板",
  "接口类型不能包含静态成员函数",
  "此 pragma 不能在 __pragma 运算符中使用(必须使用 #pragma 指令)",
  "限定符必须是 %t 的基类",
  "声明必须对应于指示基类中的纯虚拟成员",
  "由于 %t 的大小或复杂性内部计算中整数溢出",
  "内部计算中整数溢出",
  "__w64 只能在 int、long 和指针类型上指定",
  "在 int、long 或指针类型宽度为 64 位的环境中进行编译时，存在指针类型潜在收缩转换",
  "pragma 堆栈的当前值是 %s",
  "已忽略 pragma pack(show) 的参数",
  null,
  null,
  "已忽略以前的 __declspec(align(...))",
  "应为 %sq 特性形参提供实参值",
  "%sq 特性形参的实参值无效",
  "%sq 特性参数应为布尔值",
  "位置参数不能位于特性中的命名参数之后",
  "特性 %sq1 没有名为 %sq2 的参数",
  "应提供 %sq 特性的参数列表",
  "应输入“,”或“]”",
  "已经为特性参数 %sq 赋值",
  "无法将值分配到 %sq 特性",
  "throw 表达式不能包含指向不完整类型的指针",
  "向不完整类型应用了运算符对齐",
  "%sq 只能用作独立的特性",
  "此处不能使用 %sq 特性",
  null,
  "此处不允许使用特性",
  "%sq 特性形参的实参值无效",
  "特性参数太多",
  "不允许从无法访问的基类 %t 转换",
  "选项“export”需要不同的模板签名",
  "无法连接带有不同字符种类的字符串",
  "未模拟 GNU 布局 Bug，因为它将虚拟基 %no1 置于 %no2 对象边界之外",
  "虚拟基 %no1 置于 %no2 对象边界之外",
  "命名空间成员声明中存在非标准限定名",
  "已忽略缩减对齐",
  "已忽略常量限定符",
  null,
  "GNU asm 限定符无效",
  "已通过省略号传递完全无法复制的类类型",
  "无法通过 va_arg 提取完全无法复制的类类型",
  "定点文字中“u”或“U”后缀必须出现在“l”或“L”之前",
  "选项“fixed_point”只能在编译 C 时使用",
  "整数操作数可能造成定点溢出",
  "定点常量超出范围",
  "无法确切表示定点值",
  "long long 的常量太大；提供无符号 long long 类型(非标准)",
  "布局限定符不能限定指向共享类型 void 的指针",
  "多维数组类型中的重复 THREADS",
  "强 using 指令只能出现在命名空间范围中",
  "%nf 声明了非模板函数 -- 添加 <> 以指代模板实例",
  "操作可能造成定点溢出",
  "表达式必须包含整数、枚举或定点类型",
  "表达式必须包含整数或定点类型",
  "使用“noreturn”声明的函数未返回",
  "已忽略 asm 名称，因为它与前面的声明冲突",
  "不能重新声明类成员 typedef",
  "提取临时地址",
  "已忽略还未定义的类声明上的特性",
  "定点值隐式转换为浮点类型",
  "定点类型没有分类",
  "模板参数不能为定点类型",
  "不允许使用十六进制浮点常量",
  "选项“named_address_spaces”只能在编译 C 时使用",
  "浮点值不适合于所需的定点类型",
  "无法准确地将值转换为定点值",
  "定点转换导致符号更改",
  "整数值不适合于所需的定点类型",
  "定点操作结果超出范围",
  "多个命名地址空间",
  "带有自动存储持续时间的变量不能存储在命名地址空间中",
  "无法使用命名地址空间限定类型",
  "无法使用命名地址空间限定函数类型",
  "无法使用命名地址空间限定字段类型",
  "定点值不适合于所需的浮点类型",
  "定点值不适合于所需的整型",
  "值不适合于所需的定点类型",
  "选项“named_registers”只能在编译 C 时使用",
  "此处不允许使用已在寄存器中命名的存储类",
  "重新声明 %nd 时，使用了不兼容的已在寄存器中命名的存储类",
  "不能为使用别名的变量指定已在寄存器中命名的存储类",
  "已命名的寄存器存储说明符已在使用中",
  "选项“embedded_c”不能与用于控制单个 Embedded C 功能的选项组合",
  "EDG_BASE 目录无效: %s",
  null,
  "行 %s 中的预定义宏条目无效:  %s2",
  "宏模式名称 %sq 无效",
  "预定义宏 %sq 的不兼容重新定义",
  "%nd 的重新声明缺少已在寄存器中命名的存储类",
  "已命名的寄存器对于变量类型太小",
  "不能使用已在寄存器中命名的存储类来声明数组",
  "const_cast 到枚举类型不标准",
  "选项“embedded_c”只能在编译 C 时使用",
  "此处不允许使用命名地址空间限定符",
  "空初始值设定项对于带有未指定绑定的数组无效",
  "函数返回不完整类类型 %t",
  "%n 已初始化；将忽略类之外的初始值设定项",
  "声明隐藏了 %nd",
  "不能在命名地址空间中分配参数",
  "定点或浮点常量上的无效后缀",
  "不能在命名地址空间中分配寄存器变量",
  "应为“SAT”或“DEFAULT”",
  "%n 没有对应的成员运算符 delete%s (将在已分配对象初始化期间抛出异常时调用)",
  "无法使用“dllimport”或“dllexport”声明局部线程变量",
  "无法使用命名地址空间限定函数返回类型",
  "无法为其元素包含不常用析构函数的可变数组成员指定初始值设定项",
  "无法为间接可变数组成员指定初始值设定项",
  "GNU 版本号无效: %s",
  "已忽略出现在带圆括号的初始值设定项之后的变量特性",
  "此强制转换的结构不能用作左值",
  "求反无符号定点值",
  null,
  null,
  "寄存器名只能用于寄存器变量",
  "已命名的寄存器变量不能包含 void 类型",
  null,
  "参数不能包含链接范围说明符",
  "多个链接范围说明符",
  "链接范围说明符只能出现在带有外部链接的函数和变量中",
  "重新声明无法缩小链接范围",
  "此声明中不允许使用链接范围说明符",
  "全局范围声明中存在非标准限定名",
  "64 位整型到更小整型的隐式转换(潜在的可移植性问题)",
  "64 位整型到更小整型的显式转换(潜在的可移植性问题)",
  "从指向大小相同的整型的指针转换(潜在的可移植性问题)",
  null,
  "类定义中不允许使用友元说明符；已忽略友元说明符",
  "只有静态和外部变量可以使用线程本地存储",
  "多个线程本地存储说明符",
  "虚拟 %n 未定义(且无法在任意位置定义，因为它是未命名命名空间的成员)",
  "来源行中的回车符位于注释或字符/字符串文本之外",
  "表达式必须包含定点类型",
  "已忽略对访问说明符的无效使用",
  "转换为 bool 的指针",
  "转换为 bool 的指向成员的指针",
  "已忽略存储说明符",
  "已忽略类模板上的 dllexport 和 dllimport",
  "基类 dllexport/dllimport 规范与派生类的此规范不同",
  "重新声明无法将 dllexport/dllimport 添加到 %nod",
  "dllexport/dllimport 与 %nod; 冲突；假定 dllexport",
  "无法定义 dllimport 实体",
  "dllexport/dllimport 需要外部链接",
  "使用 dllexport/dllimport 声明的类成员无法使用此类说明符对其自身进行声明",
  "在具有 DLL 接口的类中使用了没有 DLL 接口的类类型的字段",
  "带圆括号的成员声明是非标准的",
  "已忽略行接合中反斜杠和新行之间的空白",
  "dllexport/dllimport 与 %nod; 冲突；已丢弃 dllimport/dllexport",
  "匿名成员类的无效成员 -- 类 %t 包含禁用的成员函数",
  "非标准的 reinterpret_cast",
  "位置格式说明符不能为零",
  "局部类无法引用封闭函数中的变长数组类型",
  "成员 %nd 已经包含显式 dllexport/dllimport 说明符",
  "函数返回类型中不允许使用变长数组",
  "指向 %t 类型成员的指针中不允许使用变长数组类型",
  "语句表达式结果不能包含涉及可变长度数组的类型",
  "已禁用对三元祖的支持",
  "%sq 特性只能出现在带有外部链接的函数和变量中",
  "严格模式与将命名空间标准视为全局命名空间的别名不兼容",
  "在宏“%s”%p 的扩展中",
  "<未知>",
  "",
  "[ %d 宏扩展未显示]",
  "在 %p 的宏扩展中",
  "符号操作数名称 %sq 无效",
  "与约束匹配的符号必须指代前十个操作数之一",
  "此上下文中不支持使用 __if_exists",
  "__if_exists 块未在其打开的相同范围内关闭",
  "无法动态初始化线程本地变量",
  "转换丢弃了“__unaligned”限定符",
  "某些枚举器值无法由枚举类型下面的整型表示",
  "友元类模板声明中不允许使用默认参数",
  "多字符字符文本(潜在可移植性问题)",
  "应为类、结构或联合类型",
  "offsetof 的第二个操作数必须是字段",
  "offsetof 的第二个操作数不能是位域",
  "无法将 offsetof 应用到虚拟基的成员",
  "offsetof 应用于非标准布局类的类型",
  "成员函数的友元声明中不允许使用默认参数",
  "非定义的友元声明中不允许使用默认参数",
  "不允许重新声明之前已声明为带有默认参数的友元的 %nd",
  "%t 的无效限定符(此处不允许使用派生类)",
  "类 %t 的定义的无效限定符",
  "%sq 之前没有 push_macro",
  "不允许宽字符串文本",
  null,
  "仅 C 中允许使用 %sq",
  "__ptr32 和 __ptr64 后面必须为“*”",
  "__ptr32 和 __ptr64 不能同时应用",
  "%sq 的模板实参列表必须与形参列表匹配",
  "不允许使用不完整的类类型",
  "不支持复杂整型",
  "__real 和 __imag 只能应用于复数值",
  "__real/__imag 适用于实数值",
  "%nd 声明为已否决(%sq)",
  "%nd 重新定义无效",
  "dllimport/dllexport 适用于未命名命名空间的成员",
  "__thiscall 只能出现在非静态成员函数声明中",
  "带有省略号参数的函数中不允许使用 __thiscall",
  "必须在其首次使用之前对 %n 进行显式专用化(%p)",
  "不能将密封类类型用作基类",
  "重复的类修饰符",
  "成员函数不能包含“abstract”和“sealed”修饰符",
  "密封成员不能是纯虚拟的",
  "不能使用“abstract”或“sealed”修饰符声明非虚拟函数",
  "使用“override”声明的成员函数不能重写基类成员",
  "不能替换密封 %nd",
  "%nd 已使用类修饰符“abstract”声明",
  "所在行数:",
  "，所属文件:",
  "其中 ",
  "关键字",
  "宏",
  "标签",
  "模板参数",
  "类型",
  "联合",
  "类",
  "结构",
  "模板 template 参数",
  "模板",
  "类模板",
  "枚举",
  "参数",
  "处理程序参数",
  "变量",
  "非类型",
  "常数",
  "函数",
  "重载函数",
  "成员",
  "字段",
  "命名空间",
  "已命名的寄存器",
  "命名地址空间",
  "函数模板",
  "基于模板参数",
  "基于模板参数",
  " (已声明 ",
  "(来源结尾)",
  "来源结尾",
  "行",
  "行",
  "列",
  "注释",
  "注释",
  "警告",
  "警告",
  "错误",
  "错误",
  "灾难性错误",
  "灾难性错误",
  "命令行错误",
  "命令行错误",
  "内部错误",
  "内部错误",
  null,
  null,
  "达到错误限制。",
  "内部错误循环",
  "灾难性错误处理循环。",
  null,
  "临时",
  "预处理输出",
  "原始清单",
  "交叉引用",
  "中间语言(1)",
  "中间语言(2)",
  "中间语言(3)",
  "中间语言(4)",
  "中间语言(5)",
  "中间语言(6)",
  "中间语言(7)",
  "中间语言(8)",
  "中间语言(9)",
  null,
  null,
  null,
  null,
  null,
  "缺少“无法重新定义”标志",
  "“,”后面缺少模式",
  "缺少宏名称",
  "cannot-redefine 值无效",
  "重复的函数修饰符",
  "char16_t 文本的无效字符",
  null,
  "无法识别的调用约定 %s，必须为以下内容之一:",
  null,
  null,
  null,
  "枚举类型的基础类型必须是整型",
  "某些枚举器常量不能由 %t 表示",
  "当前模式中不允许使用 %sq",
  "type traits helpers 选项只能在编译 C++ 时使用",
  "特性“sentinel”需要省略号参数",
  "参数必须是常量空指针值",
  "sentinel 值的参数数目不足",
  "sentinel 实参必须对应于省略号形参",
  "__declspec(implementation_key(...) 只能出现在 #pragma start_map_region 和 #pragma stop_map_region 之间",
  "#pragma start_map_region 已经处于活动状态:  已忽略 pragma",
  "没有当前处于活动状态的 #pragma start_map_region:  已忽略 pragma",
  "%n 不能用于命名析构函数(需要类型名称)",
  "非标准空宽字符文本视为 L'\\0'",
  "此处不能指定“typename”",
  "非位置运算符删除在带有虚拟析构函数的类中必须可见",
  "名称链接与前面的 %nd 声明冲突",
  "别名创建了别名条目的周期",
  null,
  "无法使用初始值设定项声明带有在特定寄存器中分配的静态存储持续时间的变量",
  "在特定寄存器中分配的变量必须是可轻松复制的",
  "%no 的预定义含义已丢弃",
  null,
  "类类型不适合用于指示符",
  null,
  "匿名联合限定符是非标准限定符",
  "已忽略匿名联合限定符",
  null,
  "已忽略 __declspec(%s) (它对于 C 结构没有意义)",
  "声明之间逗号后面的说明符是非标准说明符",
  "已忽略非标准说明符",
  "已忽略枚举声明(也不是定义)上的特性",
  "使用“mutable”声明引用是非标准做法",
  "数组的条件声明始终为 true",
  "静态断言失败，原因是 %sq",
  "已忽略可见性特性，因为它与前面的声明冲突",
  "字段名称解析为多个偏移量 -- 请参阅 %nod1 和 %nod2",
  "%sq 不是字段名称",
  "case 标签值已经出现在此开关 %p 中",
  "成员函数不能包含内部链接",
  "声明隐藏了内置 %n",
  "声明重载了内置 %n",
  "用于列出宏定义的选项不能在编译多个翻译单元时指定",
  "%n 声明后面带有意外的括号(是否参数列表格式不正确或初始值设定项无效?)",
  "围绕字符串初始值设定项的括号是非标准的",
  "__interface",
  "使用 auto 类型说明符声明的变量不能出现在其自身的初始值设定项中",
  "无法推导“auto”类型",
  "不允许使用“{...}”初始化“auto”类型",
  "“auto”类型不能出现在顶级数组类型中",
  "“auto”类型不能出现在顶级函数类型中",
  "%t 类型的成员不能包含类内初始值设定项",
  "带有类内初始值设定项的成员必须为常量",
  "无法推导“auto”类型(需要初始值设定项)",
  "对于此实体“auto”类型是 %t1，但之前默示为 %t2",
  "构造函数声明无效",
  "类型限定符使用无效",
  "联合不能是抽象的或密封的",
  "此处不允许使用“auto”",
  "基类类型的定义尚未完成",
  "\"extern template\" 不能指代静态 %nd 的专用化",
  "\"extern template\" 不能跟在 %n 的显式实例化之后",
  "__declspec(restrict) 需要返回指针类型的函数",
  "“report_gnu_extensions”选项仅在 GNU C 和 GNU C++ 模式中有效",
  "变长数组类型是非标准的",
  "指示符是非标准的",
  "该指示符语法是 GNU 扩展",
  "复合文字是非标准的",
  "语句表达式是 GNU 扩展",
  "已忽略前面定义的实体的 asm 名称",
  "特性是 GNU 扩展",
  "扩展的 asm 语法是 GNU 功能",
  "可变 asm 声明是 GNU 扩展",
  "asm 名称说明符是 GNU 扩展",
  "“__restrict”限定符是非标准限定符",
  "“typeof”是 GNU 扩展",
  "修改 typedef 的大小或符号是非标准做法",
  "零长度数组是 GNU 扩展",
  "可变数组成员是非标准的",
  "特性“nonnull”引用了非指针参数",
  "特性“nonnull”的实参大于形参数目",
  "没有指针类型的参数",
  "为使用特性“nonnull”标记的形参提供了 null 实参",
  "已取消 %t1 的析构函数，因为 %t2 的析构函数无法访问",
  "需要 %t 的已取消的析构函数",
  "例程同时为“inline”和“noinline”",
  "清理例程无效",
  "特性“cleanup”需要自动存储持续时间",
  "特性“cleanup”不适用于参数",
  "清理例程的类型无效",
  "清理例程的调用需要可疑转换",
  "__sptr 和 __uptr 后面必须为“*”",
  "__sptr 和 __uptr 不能同时指定",
  "将指针转换从 %t1 扩大到 %t2 会扩展符号位",
  "__sptr 和 __uptr 不适用于指向成员的指针类型",
  "%t 的复制赋值运算符的声明已取消，因为 %n 是常量",
  "%t 的复制赋值运算符的声明已被抑制，因为 %n 包含引用类型",
  "%t1 的复制赋值运算符的声明已取消，因为 %t2 的该声明已取消",
  "%t1 的复制赋值运算符的声明已取消，因为 %t2 的该声明不明确",
  "%t1 的复制赋值运算符的声明已取消，因为 %t2 的该声明无法访问",
  "%t1 的复制构造函数的声明已取消，因为 %t2 的该声明已取消",
  "%t1 的复制构造函数的声明已取消，因为 %t2 的该声明不明确",
  "%t1 的复制构造函数的声明已取消，因为 %t2 的该声明无法访问",
  "不会调用 %t1 的析构函数，因为它是无法访问的，且 %t2 的析构函数已取消",
  "文件结尾的定义后面不是分号或声明符",
  "第一个参数必须是指向整数或枚举类型的指针",
  "同步操作仅在大小为 1、2、4 或 8 的对象上有效",
  "已忽略多余的参数",
  "在命令行定义中，“=”假定跟在宏名称 %sq 之后",
  "宏名称 %sq 及其替换文本之间需要空白",
  "未使用调用结果",
  "已忽略 void 返回类型的“warn_unused_result”特性",
  null,
  "在使用限定名重新声明时忽略 dllimport/dllexport",
  "字符文本中的字符太多 -- 已忽略多余的前导字符",
  "%n 不能在其定义 %p 之后以内联方式声明",
  null,
  null,
  "模板参数不能引用没有名称链接的类型",
  "已忽略此处的“virtual”",
  "模板参数不能引用变长数组类型",
  "通用字符名不能指定代理码位",
  "#include_next 不能在主源文件中使用",
  "不能在模板成员定义中指定 %no1 -- 假定为 %no2",
  "已忽略局部函数声明中的特性 %sq",
  "与 %sq (位于 %n 中)串联不会创建有效标记",
  "%no 不明确(假定为 %n2)",
  "静态成员函数上不允许使用类型限定符",
  "构造函数或析构函数上不允许使用类型限定符",
  "运算符 new 或运算符 delete 上不允许使用类型限定符",
  "非成员函数上不允许使用类型限定符",
  "%s 的参数具有负面影响，但它未进行计算",
  "无法识别的 Unicode 源种类 (必须为 UTF-8、UTF-16、UTF-16LE、UTF-16BE 中的一个): %s",
  "带有十六进制值 %s 的 Unicode 字符不能在预处理输出中表示",
  "已将请求的构造函数/析构函数优先级保留为供内部使用",
  "无法识别的 GCC pragma",
  "无法识别的 GCC 可见性 pragma 指令",
  "无法识别的可见性种类",
  "可见性 pragma 仍然处于活动状态",
  "没有匹配的可见性推送",
  "不完整类型的 typeid",
  null,
  "假定数组 %n 含有一个元素",
  "vector_size 特性需要算术或枚举类型",
  "矢量大小太大",
  "矢量中的元素数量必须是 2 的幂",
  "矢量大小必须是元素大小的倍数",
  "不允许进行混合的矢量-标量运算",
  "运算需要两个大小相同的矢量",
  "不允许使用依赖于模板的矢量大小",
  null,
  null,
  "不允许对复杂元素类型使用 vector_size 特性",
  null,
  "矢量运算需要相同的元素类型",
  "矢量运算不适用于具有非整型的矢量",
  "无法打开 %s 文件 %sq2",
  "无法打开 %s 文件 %sq2:  %s3",
  "预编译头",
  "预定义宏",
  "生成的 C",
  "生成的 C++",
  "源",
  "写入 %s 文件时出错:  %s2",
  "不是常规文件",
  "是目录",
  "文件名无效",
  "定义列表",
  "实例化请求",
  "导出的模板",
  "导出信息",
  "模板信息",
  "IL 输出",
  "转换丢弃了“__restrict”限定符",
  "无法为 %sq 获取映射的内存:  %s2",
  "已忽略限制限定符",
  null,
  "包含可变数组成员的元素数组是非标准的",
  "模板参数不能为矢量类型",
  "%n1 的初始化将在 %n2 的初始化之前完成",
  null,
  "已忽略枚举说明符中的继承类型",
  null,
  "已忽略枚举说明符中的修饰符",
  "不能用 Unicode 表示标识符字符",
  "头名称包含不能用 Unicode 表示的字符",
  "%sq 不是有效的区域设置名称",
  "使用模板参数声明 void 参数列表是非标准的",
  "lambdas 选项只能在编译 C++ 时使用",
  "显式捕获与默认设置匹配",
  "%n 不是变量",
  "无法在 lambda 中捕获带有静态存储持续时间的变量",
  "“this”无法通过引用捕获",
  "“this”无法在此 lambda 体内使用",
  "外部范围匿名联合的成员不能在 lambda 体内部引用",
  "封闭函数局部变量不能在 lambda 体中引用，除非其位于捕获列表中",
  "lambda 体中对外部范围局部变量的引用无效",
  "无法捕获当前函数范围外部的局部变量",
  "封闭函数“this”不能在 lambda 体中引用，除非其位于捕获列表中",
  null,
  "无法将 lambda 捕获的 %t1 类型的变量复制到 %t2 类型的闭合类字段",
  "模板目录无效: %s",
  "错误",
  "错误",
  "灾难性错误",
  "灾难性错误",
  "与",
  "在“%s”的编译中检测到。",
  "在此编译中检测到。",
  "枚举值不在其基础类型(%t)的范围内",
  "后面紧跟空白的“\\”不是行接合",
  "无法在没有运行时类型信息(已禁用)的情况下完成此 dynamic_cast",
  "转换到 %t 不明确；已选择直接基",
  "内部缓冲区将过大",
  "已使用 C++ 异常处理程序，但尚未指定异常处理语义",
  "已忽略构造函数上的类型限定符",
  "由 lambda 捕获的变量不能包含涉及变长数组的类型",
  "不兼容矢量类型之间的转换",
  "应输入“{”以引入 lambda 体",
  "右值引用选项只能在编译 C++ 时使用",
  "lambda 上不允许使用类型限定符",
  "名称不能在捕获列表中出现多次",
  "已忽略显式模板参数",
  "常量表达式中不允许使用 lambda",
  "%t 不是类类型",
  "应用于指向数组的指针类型的“delete”被视为 delete[]",
  "应用于指向数组的指针类型的“delete”是非标准的；被视为 delete[]",
  "无法使用给定参数列表调用 %n",
  "无法将右值引用绑定到左值",
  "非类型模板参数不能为右值引用类型",
  "已忽略类型限定符(基础类型是引用)",
  "使用局部类型声明的 %n 必须在此翻译单元中定义",
  "使用没有链接的类型声明的 %n 必须在此翻译单元中定义",
  "右值引用 dynamic_cast 的操作数必须包含完整的类类型",
  "“= default”只能出现在默认构造函数、复制/移动构造函数、复制/移动赋值运算符和析构函数中",
  "“= delete”只能出现在函数的第一个声明中",
  "无法引用 %npd -- 它是已删除的函数",
  "不允许在未计算的表达式中使用 lambda",
  "__builtin_va_arg_pack/__builtin_va_arg_pack_len 只能出现在带有省略号参数的内联函数中",
  "不能在友元声明中指定“= default”",
  "应输入 C++ 关键字",
  null,
  "偏移量不是常量",
  "无法识别的 #pragma 注释类型 %sq",
  "用于控制“auto”是否为类型说明符的选项只能在编译 C++ 时使用",
  "用于控制“auto”是否为存储类的选项只能在编译 C++ 时使用",
  "含义为“auto”的类型说明符和存储类说明符不能同时禁用",
  "#pragma 注释中的字符串无效",
  "已删除的函数重写未删除的 %n",
  "未删除的函数重写已删除的 %n",
  "无法引用 %t 的默认构造函数 -- 它是已删除的函数",
  "不允许将右值引用作为 catch 类型",
  "%n 的默认参数与其他翻译单元中的声明不兼容",
  "%n 的默认参数在编译 %sq 期间是不同的",
  null,
  "%n 的初始值设定项在其他翻译单元中是不同的",
  "%n 的初始值设定项在编译 %sq 期间是不同的",
  "不允许使用依赖于模板类型的指示符",
  "无法识别的合规性种类",
  "应为“on”或“off”",
  "#pragma conform(forScope) 堆栈为空",
  "前面没有 #pragma conform(forScope) 项与 %sq 匹配",
  "forScope 行为是非标准的",
  "forScope 行为是标准的",
  "无法删除函数“main”",
  "此处的类型限定符毫无意义",
  "类型对于默认的赋值运算符无效",
  "无法默认函数模板",
  "类型对于默认构造函数无效",
  "函数调用需要一个参数",
  "函数调用需要实型浮点参数",
  "无法默认为带有默认参数的复制构造函数",
  "无法删除预声明的函数",
  "if-statement 中的空从属语句",
  "if-statement 的“else”子句中的空从属语句",
  "无法引用已消除副本所需的 %nfd -- 它是已删除函数",
  "“main”的第一个参数 %t 不标准，应为“int”",
  "“main”的参数数目不标准，应为零个或两个参数",
  "“main”的第二个参数 %t 不标准，应为“char *[]”或“char **”",
  "已将 %sq 同时指定为系统和非系统包括目录 -- 将忽略非系统项",
  "用于控制移动构造函数和移动赋值运算符的选项只能在编译 C++ 时使用",
  null,
  null,
  "尾随的返回类型需要“auto”类型说明符",
  "嵌套声明符中不能出现尾随的返回类型",
  "含有尾随的返回类型的函数声明符前面必须是简单的“auto”类型说明符",
  "“auto”函数需要尾随的返回类型",
  "成员模板不能具有纯说明符",
  "字符串太长 -- 已忽略多余的字符",
  "用于控制 nullptr 关键字的选项只能在编译 C++ 时使用",
  "std::nullptr_t 已转换为 bool",
  null,
  null,
  "特性 %sq 不允许使用空参数列表",
  "特性多次出现",
  "特性 %sq 在此处不适用",
  "特性 %sq 不适用于位域",
  "特性 %sq 需要位域",
  "特性 %sq 不适用于成员函数",
  "特性 %sq 需要成员函数",
  "特性 %sq 不适用于虚拟函数",
  "特性 %sq 需要虚拟函数",
  "特性 %sq 不适用于纯虚拟函数",
  "特性 %sq 需要纯虚拟函数",
  "特性 %sq 不适用于寄存器变量",
  "特性 %sq 需要寄存器变量",
  "特性 %sq 未出现在原始声明中",
  "此处不允许使用特性",
  "特性 %sq 必须出现在类定义中",
  "向纯虚拟函数应用了“final”",
  "无法重写“final”%nd",
  "静态 %n 被视为外部，因为它被引用，但是未定义",
  "用于启用 GNU-C89-style 内联的选项只能在编译 C 时使用",
  "以前声明函数时未使用“gnu_inline”特性",
  "已忽略非内联函数上的“gnu_inline”特性",
  "以前声明 %n 时未使用 carries_dependency 特性",
  "数组 %n 的初始值设定项无效",
  "在生成运行时库时必须指定 C++11 或 C++14 模式",
  "特性 %sq 不适用于函数类型",
  "特性 %sq 需要函数类型",
  "特性 %sq 不适用于非静态成员函数",
  "特性 %sq 不适用于自动变量",
  "特性 %sq 需要自动变量",
  "特性 %sq 不适用于带有外部链接的变量或函数",
  "特性 %sq 需要局部变量",
  "已忽略此处的特性",
  "特性不适用于任何实体",
  "错误的特性参数替换",
  "“tls_model”特性的参数必须是“global-dynamic”、“local-dynamic”、“initial-exec”或“local-exec”",
  "声明 %p 指定了不同的“tls_model”参数",
  "特性 %sq 不适用于内联函数",
  "特性 %sq 需要内联函数",
  "include_alias pragma 中的两个文件名都必须使用相同分隔符",
  "带符号与无符号操作数之间的比较",
  "已忽略未命名类型上的特性 %sq",
  "已忽略特性 %sq，因为后面没有任何定义",
  "线程区域与以前的 %nd 声明不兼容",
  "此封闭函数局部变量不能在 lambda 体中引用，因为封闭 lambda 不允许进行隐式捕获",
  "此特性参数包含不匹配的圆括号、方括号或大括号",
  "__builtin_fpclassify 调用需要五个整型参数，后跟一个浮点参数",
  "__builtin_fpclassify 调用中的最后一个参数必须具有实浮点类型",
  "对齐不能设置为小于默认对齐",
  "显式实例化上不允许使用特性",
  "特性 %sq 不适用于定义",
  "特性 %sq 需要定义",
  "标准特性不能出现在不是定义的友元声明中",
  "指定的对齐(%s1)与以前声明中指定的对齐(%s2)不同",
  "对齐特性还必须出现在定义 %p 中",
  "%n 不能在别名声明的类型 id 中使用",
  "别名模板",
  "%t 不能是透明的，因为其第一个字段具有浮点类型",
  "%t 不能是透明的，因为其第一个字段是位域",
  "“base_check”类的虚拟函数重写了基类成员，但是缺少“override”特性",
  "在不隐藏基类声明的声明中指定了“hiding”特性",
  "在通过 using 声明 %p 引用的声明中指定了“hiding”特性",
  "在隐藏 %nd 的声明(在“base_check”类中)中需要特性“hiding”",
  "%n 未在此翻译单元中定义，但是依赖于局部类型",
  "%n 未在此翻译单元中定义，但是依赖于不带链接的类型",
  "其他翻译单元中缺少特性 %sq",
  "特性 %sq 与其他翻译单元冲突",
  "“nonstd_gnu_keywords”选项仅在 GNU C 和 GNU C++ 模式中有效",
  "在 C 中，在常量表达式中使用常量变量是非标准的",
  "不能为具有自动存储持续时间的可变数组成员指定初始值设定项",
  null,
  "不能将“final”类类型用作基类",
  "标准 C++ 语言中不再有导出模板",
  "不允许使用依赖于模板的指示符",
  "offsetof 的第二个操作数不能是具有引用类型的字段",
  "长生存期临时内存与其他请求的较新语言功能不兼容",
  "诊断中不会引用宽字符串文本",
  "缺少特性 %sq 的参数",
  "选项“c++11”和“c++11_sfinae”需要不同的编译器配置",
  "模板参数包不在参数列表结尾",
  "此处不允许使用参数包声明",
  "参数包不能含有默认值",
  "只能在 Microsoft C++ 模式中启用 C++/CLI",
  "“value__”不能用作枚举器常量的名称(它在此上下文中为保留名称)",
  "具有布尔基础类型的枚举类型中需要显式枚举器值",
  null,
  "参数包 %sq 已引用，但未扩展",
  "包扩展不利用任何参数包",
  "包 %sq 与 %sq2 的元素数目不相同",
  null,
  "不允许对枚举类型使用 vector_size 特性",
  "属性不能既是静态的又是虚拟的",
  "索引属性不能是普通的",
  "此声明不能出现在属性定义中",
  "限定函数类型不能用于声明访问器函数",
  "访问器函数不能具有省略号参数",
  "已对此属性 %p 声明“get”访问器",
  "已对此属性 %p 声明“set”访问器",
  "“get”访问器不能有参数",
  "“get”访问器的返回类型与属性类型不匹配",
  "“set”访问器的返回类型必须为 void",
  "属性不能声明空索引列表",
  "属性索引不能具有 void 类型",
  "索引类型与“set”访问器中的对应参数不匹配",
  "索引类型与“get”访问器中的对应参数不匹配",
  "“set”访问器中缺少索引类型",
  "“get”访问器中缺少索引类型",
  "“set”访问器缺少其值参数",
  "访问器函数的参数太多",
  "“set”访问器的最后一个参数与属性类型不匹配",
  "%sq 需要 C++/CLI 模式",
  "Win32 API“%s”中出错:  %s",
  "#using 只能在全局范围使用",
  "元数据",
  "成员名称 %sq 由 %nd 保留",
  "应输入“[”",
  "%[C++/CLI] 模式要求 microsoft_version >= 1600",
  "默认索引属性不能是静态的",
  "属性访问器不能既是静态的又是虚拟的",
  "顶级可见性说明符不能出现在嵌套类型声明中",
  "顶级可见性说明符需要类型定义",
  "普通属性不能具有引用类型",
  "普通属性不能具有常量或可变类型",
  "%nd 以前声明为不同种类的枚举类型",
  "由 lambda 捕获的变量不能具有 %[managed] 类类型",
  "%[managed] 类中不允许使用用协变返回类型的虚函数重写",
  "不允许使用句柄的数组",
  "不允许使用数组的句柄",
  "不允许使用函数的句柄",
  "不允许使用 void 的句柄",
  "不允许使用句柄的句柄、指针或引用",
  "不允许使用对函数的跟踪引用",
  null,
  "字段不能是跟踪引用",
  "跟踪引用不能以这种方式与普通引用组合",
  "带有静态存储持续时间的变量不能具有 ref 类类型",
  "%[managed] 类不能是未命名的",
  "%[managed] 类不能是局部的",
  "%nd 以前声明为不同种类的类",
  "%nd 以前声明为不同种类的类模板",
  "literal 数据成员只能是 %[managed] 类的成员",
  "literal 数据成员必须已初始化",
  "不允许使用 %t 类型的 literal 数据成员",
  "常量不会影响 literal 数据成员",
  "initonly 数据成员只能是 %[managed] 类的成员",
  "常量不会影响 initonly 数据成员",
  "%nd 没有“get”访问器",
  "%nd 没有“set”访问器",
  "静态构造函数不能包含参数",
  "静态构造函数不能是成员模板",
  "复合左值不允许用作 asm 输出操作数",
  "属性只能是 %[managed] 类的成员",
  "%[managed] 类的成员函数上不允许使用类型限定符",
  "不允许使用指向 %[C++/CLI] ref 类或接口类的普通指针",
  "不允许使用对 %[C++/CLI] ref 类或接口类的普通引用",
  "重写说明符不会命名基类成员函数",
  "重写说明符指定非虚拟成员 %nd",
  "成员函数重写已由 %nd2 重写的 %nd1",
  "最多允许使用一个可见性说明符",
  "用于委托定义的类型 %t 不是函数类型",
  "委托成员类型只能是 %[managed] 类的成员",
  "不允许使用对委托类型的跟踪引用",
  "此处不允许使用委托类型",
  "此包扩展生成了一个空表达式列表，而此处需要一个表达式",
  "事件不能既是静态的又是虚拟的",
  "事件只能是 %[managed] 类的成员",
  "此声明不能出现在事件定义中",
  "事件类型必须是委托句柄类型",
  "已对此事件 %p 声明“add”访问器",
  "已对此事件 %p 声明“remove”访问器",
  "已对此事件 %p 声明“raise”访问器",
  "事件访问器不能既是静态的又是虚拟的",
  "“add”和“remove”访问器的返回类型必须为 void",
  "事件访问器缺少其值参数",
  "访问器函数的参数太多",
  "事件访问器的参数的类型 %t1 与事件类型(%t2)不匹配",
  "“raise”访问器的类型与事件的委托调用类型不匹配",
  "事件定义必须同时包含“add”和“remove”访问器",
  "静态转换函数必须接受正好一个参数",
  "静态运算符必须具有参数类型 T、T%%、T& 或 T^ 并且 T = %t",
  "sizeof... 的操作数必须是参数包名称",
  "sizeof... 运算符只能在可变参数模板中使用",
  "事件名不能出现在此处",
  "不允许使用非 %[managed] 类的句柄",
  "不允许使用未区分范围的枚举类型的句柄",
  "%[managed] 类中不允许使用“property”特性",
  "后跟定义的纯说明符(“= 0”)是非标准的",
  "此处不能使用 %[managed] nullptr 类型",
  "& 运算符不能用于采用具有 ref 类类型的对象的地址",
  "不允许使用 %[managed] 类的数组",
  "带有静态存储持续时间的变量不能具有句柄或跟踪引用类型",
  "由 lambda 捕获的变量不能是句柄或跟踪引用",
  "%[C++/CLI] 参数数组需要一维 %[cli::array] 类型的句柄",
  "无法从文件 %sq 导入元数据",
  "无法扩展 CLI 命名空间",
  "%[cli::array] 的元素类型必须是句柄或值类型",
  "%[cli::array] 类型的维数无效",
  "cli::interior_ptr/cli::pin_ptr 必须指向标准类、值类、整数、句柄或标准指针",
  "%t 不能是类成员",
  "不允许使用 cli::pin_ptr 类型的参数",
  "终结器声明无效",
  "终结器不能带有参数",
  "终结器上不允许使用类型限定符",
  "不能对终结器指定返回类型",
  "using 声明不能命名终结器",
  "终结器名称必须是限定的",
  "终结器名称 %t1 的限定符与类型 %t2 不匹配",
  "%n 不能用于命名终结器(需要类型名称)",
  "类型 %t 的终结器名称无效",
  "终结器引用不明确 -- %n1 和 %n2 都可以使用",
  "终结器只能是 ref 类的成员",
  null,
  "用作终结器名称的类型与类型 %t 不匹配",
  "此类型不存在终结器",
  "“%%”运算符只能在具有 %[managed] 类类型的对象上使用",
  "不允许使用指向 cli::interior_ptr 的指针、句柄或引用",
  "不允许使用指向 cli::pin_ptr 的指针、句柄或引用",
  "不允许使用指向 %[C++/CLI] 数组的指针或引用",
  "此处不允许使用 %[C++/CLI] 数组类型",
  "%[C++/CLI] ref 类只能从另一个 ref 类或接口类派生",
  "%[C++/CLI] 值类只能从接口类派生",
  "%[C++/CLI] 接口类只能从接口类派生",
  "ref 类最多只能有一个直接 ref 基类(%t 已是这样的一个基类)",
  "标准类不能从 %[managed] 类派生",
  "%[managed] 类不能具有虚拟基",
  "%[managed] 类不能具有“private”或“protected”基",
  "“override”修饰符需要带有显式“virtual”关键字的虚拟函数声明",
  "“abstract”修饰符需要带有显式“virtual”关键字的虚拟函数声明",
  "“sealed”修饰符需要带有显式“virtual”关键字的虚拟函数声明",
  "命名重写说明符需要带有显式“virtual”关键字的虚拟函数声明",
  "不允许使用 cli::pin_ptr 返回类型",
  "特性 %sq 只适用于 %[C++/CLI] 模式",
  "简单(非跟踪)引用不能绑定到托管堆上的实体",
  "可移植程序集",
  "“%s”不从默认程序集加载",
  "列表初始化语法是一项 C++11 功能",
  "sizeof 的操作数不能是 ref 类类型或接口类类型",
  "此 %[cli::array] 类型的子脚本数无效",
  "指向成员的指针对于 %[managed] 类无效",
  "%[managed] 类的私有虚拟成员函数不是密封的",
  "析构函数上不允许使用修饰符",
  "终结器上不允许使用修饰符",
  "“virtual”不会影响 %[managed] 类的析构函数",
  "“new”或“override”是必需的，因为此声明与 %nd 匹配",
  "“new”或“virtual”是必需的，因为此声明与 %nd 匹配",
  "此处的“new”或“override”无效，因为匹配的 %nd 是接口的成员",
  "“new”修饰符没有匹配的 ref 基类成员",
  "%nd 已重写(访问权降低)",
  "%t1 类型的引用无法使用 %t2 类型的值初始化",
  "不能在值类中声明复制构造函数",
  "不能在值类中声明默认构造函数",
  "不能在值类中声明析构函数",
  "不能在值类中声明赋值运算符",
  "非值类 %t 不能是值类成员的类型",
  "选项“cppcli”需要不同的编译器配置",
  "不允许对 %[managed] 类的成员函数使用异常规范",
  "%[managed] 类不能声明友元",
  null,
  null,
  "%[managed] 类的成员函数中不允许使用局部类定义",
  "%[managed] 类的成员函数中不允许使用局部 lambda",
  "%[C++/CLI] 接口类类型的成员函数不能包含定义",
  "属性定义必须包含至少一个访问器(“get”或“set”)",
  "默认索引属性与 %nd 冲突",
  "无法使用 %n1，因为它跟随一个参数包，无法从 %n2 的参数推导出来",
  "此包扩展生成了多个表达式，而此处需要单个表达式",
  "类型必须对应于 System::Boolean、System::Byte、System::SByte、System::Int16、System::UInt16、System::Int32、System::UInt32、System::Int64 或 System::UInt64",
  "在没有适当 operator() 的情况下调用句柄类型的对象，或将函数转换为指向函数的指针类型",
  "未命名的参数包声明不能带圆括号",
  "只有在编译 C++ 时才能启用可变参数模板",
  "属性定义与 %nd 冲突",
  "重载的属性",
  "属性",
  "泛型参数不能具有默认值",
  "泛型只能具有类型参数",
  "为了与“for each”语句一起使用，类型 %t 必须提供非静态成员函数 %sq",
  "“for each”不能使用成员 %n，因为它是静态的",
  "在此“for each”语句中，参数列表为空的情况下无法调用 %no 的任何实例",
  "“for each”不能使用成员函数“MoveNext”，因为返回类型无效",
  "“for each”语句不能操作 %t 类型的表达式",
  "为了与“for each”语句一起使用，类型 %t 必须提供非索引属性 %sq",
  null,
  "在此“for each”语句中，%t2 不是有效的枚举器(由 %t1 的“GetEnumerator”返回)",
  "应输入“in”",
  "类 %t 没有适合的赋值运算符(运算符合成之后)",
  "%sq 不是泛型参数",
  "%sq 不是最内部的泛型参数列表的泛型参数",
  "泛型约束无效",
  "对事件成员的使用无效(仅允许使用订阅、取消订阅和调用)",
  "在没有“raise”访问器的情况下调用事件无效",
  "仅“+=”和“-=”对于事件有效",
  "不允许使用 %[managed] 类型的 typeid",
  "不允许使用 %[managed] 指针类型的 typeid",
  "后跟“::typeid”的名称必须是类型名称",
  "此类型的成员 %sq 在 %[managed] 类中是保留的 -- 是否想要使用析构函数?",
  "此类型的成员 %sq 在 %[managed] 类中是保留的 -- 是否想要使用终结器?",
  "%[System]::IDisposable::Dispose 缺失或无效",
  "%[System]::Object::Finalize 缺失或无效",
  "%n 不会重写 %[System]::Object::Finalize",
  "句柄 dynamic_cast 的操作数必须是完整类类型的句柄",
  "跟踪引用 dynamic_cast 的操作数必须是完整类类型的左值",
  "到句柄或跟踪引用类型的 dynamic_cast 中的类型必须引用完整类",
  "内部指针不能强制转换为本机指针",
  "只能在 ref 和值类类型中声明显式转换运算符",
  "显式转换运算符不能是虚拟的",
  "表达式必须具有算术或未区分范围的枚举类型",
  "表达式必须具有算术、未区分范围的枚举或指针类型",
  "表达式必须具有整数或未区分范围的枚举类型",
  "表达式必须具有整数、未区分范围的枚举或固定点类型",
  "应用于区分范围的枚举的内置二元运算符需要两个类型相同的操作数",
  "%[gcnew] 不能分配 %t 类型的实体",
  "位置语法不能与 %[gcnew] 一起使用",
  "new 只能与简单值类型一起使用",
  "不能对 %[managed] 类使用 new (而应使用 %[gcnew])",
  "new 不能在句柄类型上使用",
  "%[C++/CLI] 数组的 %[gcnew] 必须具有新的初始值设定项或数组初始值设定项",
  "数组初始值设定项只能用于初始化 %[C++/CLI] 数组类型",
  "%[gcnew] 不允许使用 auto",
  "数组绑定过多",
  "数组绑定过少",
  "%nf 的参数太少",
  "%nf 的参数太多",
  "泛型类",
  "%nf 的任何声明都不接受提供的泛型参数数目",
  "委托初始值设定项无效 -- 必须是函数",
  "委托初始值设定项无效 -- 多个函数与委托类型匹配",
  "委托初始值设定项无效 -- 函数与委托类型不匹配",
  "委托初始值设定项无效 -- 除函数以外还需要一个对象",
  "委托初始值设定项无效 -- 函数不是 %[managed] 类的成员",
  "委托初始值设定项无效 -- 指定函数不需要对象",
  "委托初始值设定项无效 -- 对象的类型为 %t1，但应为类型 %t2",
  "不允许采用 %[managed] 类的成员函数的地址",
  "委托初始值设定项无效 -- 应为“(<function-address>)”或“(<object-handle>, <member-address>)”",
  "类无法实现接口成员 %nd",
  "%[gcnew] 不能用于分配本机数组",
  "%[C++/CLI] 接口类不能声明赋值运算符",
  "%[C++/CLI] 接口类不能是密封的",
  null,
  "析构函数或终结器声明不能包含命名重写说明符",
  "重写说明符不能指定析构函数或终结器",
  "仅允许在 %[managed] 类中使用命名的重写说明符",
  "命名重写说明符指定的任何成员都不与此成员的类型相匹配",
  "静态构造函数声明不能包含命名重写说明符",
  "区分范围的枚举类型必须具有名称",
  "不允许将控制传输到 finally 块",
  "不允许 finally 块内存在 return 语句",
  "try 块至少需要一个 handler 或 finally 子句",
  "%[managed] 对象必须由句柄引发",
  "%[managed] 对象必须由句柄捕获",
  "不能在 finally 块中使用 break 语句",
  "不能在 finally 块中使用 continue 语句",
  "子脚本被重载时不能使用内置 offsetof",
  "重复约束",
  "多个类约束:  %t1 和 %t2",
  "%n 有多个约束子句",
  "initonly 静态数据成员必须具有初始值设定项或在静态构造函数中进行初始化",
  "模板重新声明上的 GNU 特性不起作用",
  "模板重新声明上的 GNU 特性不起作用(改为应用原始声明 %p 的特性)",
  "%[C++/CLI] 参数数组必须是最后一个参数",
  "带有 %[C++/CLI] 形参数组的函数不能包含默认实参",
  "%[C++/CLI] 参数数组后面不能跟省略号参数",
  "运算符函数参数列表中不允许包含 %[C++/CLI] 参数数组",
  "此处不允许使用 __inline 和 __forceinline",
  "数据成员不能具有 %[C++/CLI] 接口类类型",
  "变量不能具有 %[C++/CLI] 接口类类型",
  "参数不能具有 %[C++/CLI] 接口类类型",
  "函数返回类型不能是 %[C++/CLI] 接口类类型",
  "不允许使用泛型参数类型的数组",
  "不允许使用指向泛型参数类型的指针、句柄或引用",
  "initonly 字段不能具有 ref 类类型",
  "引用不能绑定到 initonly 字段",
  "不允许采用 initonly 字段的地址",
  "initonly 字段只能由其包含类的实例构造函数进行修改",
  "静态 initonly 字段只能由其包含类的静态构造函数进行修改",
  "将对 initonly 字段的副本调用成员函数",
  "表达式必须具有指针或句柄类型，但它具有类型 %t",
  "移动构造函数或移动赋值运算符用于在此处复制左值，这可能会破坏源对象",
  "%[C++/CLI] 泛型实体上的成员选择必须使用“->”语法，而不是使用“.”",
  "ref 类类型不能从 %t 派生",
  "泛型类必须是 %[managed] (即，ref 类、值类或接口类)",
  "密封类不能用作约束",
  "dynamic_cast 中的类型不能是可能为值类型的泛型类型",
  "通用字符名必须指定有效的码位",
  "泛型约束与 %nd 的这些约束不匹配",
  "__underlying_type 仅适用于枚举类型",
  "此强制转换应只有一个操作数表达式",
  "带有十六进制值 %s 的 Unicode 字符不能在系统默认代码页中表示",
  "绑定指向成员的指针转换为函数指针是非标准的",
  "访问说明符 %s1 已弃用 -- 改用 %s2",
  "不允许在非静态属性或事件定义中使用静态访问器函数",
  "%t 同时具有值类和 ref 类约束",
  "%t1 和 %t2 涉及循环裸类型约束",
  "%t 不是有效的类型约束",
  "未使用预编译头文件 %sq (因为它不完整)",
  "%t 不是有效的泛型参数",
  "对无效类型应用了 assembly_info 特性",
  "%t1 不满足泛型参数 %t2 的 ref 类约束",
  "%t1 不满足泛型参数 %t2 的值类约束",
  "%t1 不满足泛型参数 %t2 的 %[gcnew] 约束，因为它是抽象的",
  "%t1 不满足泛型参数 %t2 的 %[gcnew] 约束，因为它没有公共的默认构造函数",
  "泛型参数 %t1 不满足泛型参数 %t2 的 %[gcnew] 约束，因为它没有 %[gcnew] 约束",
  "%t1 不满足泛型参数 %t2 的 %t3 类型约束",
  "泛型参数 %t 的约束与之前的声明(%p)不同",
  "%[managed] 类的成员不能是标准数组",
  "非 %[managed] 类的成员不能是句柄",
  "非 %[managed] 类的成员不能是跟踪引用",
  "句柄的 reinterpret_cast 不安全",
  "模板参数不能引用泛型类型参数",
  "此下标操作中不允许使用表达式列表(用括号括起顶级逗号操作符)",
  "表达式必须包含指向对象的指针类型或指向 %[C++/CLI] 数组的句柄类型，但它具有类型 %t",
  "无法识别的特性",
  "%[managed] 类的成员不能是非 %[managed] 类类型",
  "非 %[managed] 类的成员不能有 ref 类类型或接口类类型",
  "在 ",
  "委托不能声明为模板",
  "泛型不能显式专用化",
  "不能在类模板中声明泛型",
  "不能在泛型类中声明模板",
  "文本字段不能声明为“static”",
  "“long float”是非标准扩展 -- 应使用“double”",
  "标准类不能嵌套在 %[managed] 类中",
  "__clrcall 仅在 C++/CLI 模式下有效",
  "在带有省略号参数的函数中不允许使用 __clrcall",
  "此处不允许使用 %sq",
  "不能使用 trivial 属性或事件重写 %nd",
  "需要迭代器变量名",
  "此“for each”语句中的迭代器类型为 %t，它不是指针类型或类似迭代器的类类型",
  "此“for each”语句中的迭代器类型为 %t，它不是指针类型或类似迭代器的类类型",
  "此“for each”语句中的迭代器类型为 %t，它不是指针类型或类似迭代器的类类型",
  "为 %t 类类型的此字段(非标准布局)忽略了父类型上的封装特性",
  "%nd 未实现，因为此声明不是公共的，并且没有指定重写说明符",
  "此声明缺少在前面的声明 %p 中指定的 gnu_inline 特性",
  "%[managed] 类的成员函数不能有省略号参数",
  "之前声明的 %n 作为“for each”语句的迭代器无效",
  "调用约定被忽略，因为函数类型涉及泛型参数；改为使用 __clrcall",
  "涉及泛型参数的函数类型不能有省略号参数",
  "重写匹配的 %nd 需要“virtual”",
  "实现匹配的 %nd 需要“virtual”",
  "initonly 数据成员不能是 volatile",
  "此类型的成员 %sq 在 %[managed] 类中是保留的 -- 必须使用关键字“operator”声明 %[C++/CLI] 运算符",
  "不能将对非常量的跟踪引用绑定到常量",
  "此处忽略了不适用于已声明实体的特性",
  "不允许使用对 %[System]::String 的跟踪引用",
  "将泛型类 %t 与挂起的约束一起使用无效(原因可能是元数据文件无效)",
  "只允许对泛型类声明(而不是泛型类定义)使用挂起的 constraint 子句",
  "此处不允许初始值设定项列表为空",
  "不能在 %[managed] 类中声明模板",
  "此处不允许泛型声明",
  "接口类型不能包含泛型成员",
  "Unicode 字符不是拉丁语 1，已截断到低位字节",
  "为了与基于范围的“for”语句一起使用，类型 %t 必须提供函数 %sq",
  "此基于范围的“for”语句中的迭代器类型为 %t，它不是指针类型或类似迭代器的类类型",
  "此基于范围的“for”语句中的迭代器类型为 %t，它不是指针类型或类似迭代器的类类型",
  "此基于范围的“for”语句中的迭代器类型为 %t，它不是指针类型或类似迭代器的类类型",
  "基于范围的“for”语句不能操作未知大小或不完整类型 %t 的数组",
  "在基于范围的“for”语句中使用的“begin”和“end”函数的返回类型必须相同(“begin”返回类型是 %t1，“end”返回类型是 %t2)",
  "销毁已清除的临时对象所需的 %nfd 无法访问",
  "在此基于范围的“for”语句中，没有 %no 实例与参数列表匹配",
  "此基于范围的“for”语句需要适合的 %sq 函数，但未找到",
  "此“for each”语句需要适合的 %sq 函数，但未找到",
  "%t 具有不能使用 %[C++/CLI] 表示的元数据表示形式",
  "需要“...”",
  "__implements 列表中的 %t 不是一个接口",
  "__implements 列表必须在虚函数声明之前",
  "%t 在其基列表中指定了“__implements ...”，但缺少匹配的 __implements 列表",
  "必须使用取消对 ref 或接口类类型的句柄的引用的结果",
  null,
  "需要“)”；已忽略 pragma",
  "using 声明或访问声明不能出现在托管类中",
  "注意: 可能已调用 %nd，但未考虑，因为它不可访问",
  "C++/CLI 托管类的抽象成员函数不能包含定义",
  "声明此一元“operator*”会更改取消引用句柄的含义(使用静态成员运算符显式指示适用类型)",
  "托管",
  "C++/CX",
  "C++/CLI",
  "C++/CX 映射",
  "默认",
  "cli 映射",
  "cli::array",
  "Platform::Array",
  "C++/CLI 数组",
  "C++/CX 数组",
  "系统",
  "平台",
  "gcnew",
  "ref new",
  "接口类不能包含非静态数据成员",
  "#pragma GCC system_header 不能在主要源文件中使用",
  "%n 太大，无法进行内联",
  " (已隐式声明)",
  "用于控制移动操作的选项只能在编译 C++ 时使用",
  "当 rvalue 构造函数是复制构造函数时，无法生成移动操作",
  "在禁用 rvalue 引用时，无法使用用于控制移动操作的选项",
  "“final”不能用于托管类(改用“sealed”)",
  "不允许强制转换为 CLI 接口类 %t -- 打算强制转换为句柄?",
  "无法创建 CLI 接口类的对象",
  "由于基础类型不兼容，此声明隐藏了 %nd 的非标准声明",
  "由于操作数永远不能为空，因此指针比较结果为常量",
  "不完整类型 %t 的对象不能进行值初始化",
  "引用不能进行值初始化",
  "预期为“(”或“{”",
  "复制列表初始化不能使用标记为“显式”的构造函数",
  "不允许使用指向类型为 void 的成员的指针",
  "不允许使用指向引用类型的成员的指针",
  "不允许使用指向句柄类型的成员的指针",
  "此处不允许使用用大括号括起的列表",
  "托管类中不允许使用 operator->* 成员",
  "程序集元数据引用不存在的程序集",
  "特性 %sq2 与早期特性 %sq1 冲突",
  "%nd 之前是用不同的基类型声明的",
  "此处不能使用“enum class”和“enum struct”(改用普通“enum”)",
  "在类型为 %t 的对象的初始值设定项中只允许使用一级括号",
  "%nd 不能在具有隐式返回类型",
  null,
  "用大括号括起来的初始值设定项无法与“new auto”配合使用",
  "std::initializer_list 的定义未包含预期的构造函数",
  "声明隐藏了 %nd",
  "std::initializer_list 的模板参数列表无效(它应是一个无默认值的普通类型参数)",
  "无法为省略号参数传递用大括号括起的列表",
  "需要先加入 #include <initializer_list>，然后才能使用 std::initializer_list，其中包括隐式使用",
  "不能在命名空间别名声明中使用“inline”关键字",
  "以前的 %n 声明不是以内联方式声明的",
  "%n 之前声明为内联",
  "第一个参数必须为整数常量",
  "指示符不能与非聚合类型 %t 配合使用",
  "匿名联合成员的指示符只能出现在与该匿名联合对应的大括号中",
  "只有在编译 C 时才能启用函数原型标记",
  "不能对此子对象初始值设定项省略大括号",
  "从 %t1 到 %t2 进行收缩转换无效",
  "从 %t1 到 %t2 进行收缩转换无效: 常量值不适合目标类型",
  "不允许强制转换为不完整的数组类型 %t",
  "从 %t1 到 %t2 进行收缩转换无效: 无法准确地在目标类型中表示常量值",
  "非类实体的带圆括号的初始值设定项必须为表达式，而不能是用大括号括起的列表",
  "用大括号括起的列表无法为此 lambda 提供返回类型",
  "所声明的异常规范与所生成的异常规范不兼容",
  "区分范围的枚举类型是 C++11 的一项功能",
  "函数类型不能进行值初始化",
  "不允许对象类型 %t 的列表初始化，因为该类型不完整",
  "std::initializer_list 有析构函数，但实际不应有 -- 库配置有误",
  "显式枚举基类型是 C++11 的一项功能",
  "此常量表达式的类型为 %t1，而所需类型为 %t2",
  "std::initializer_list 对象的“new”可能无法发挥预期的作用，因为在整个表达式的结尾将销毁基础数组",
  "在预定义宏文件中",
  null,
  "“defined”在 Microsoft 模式下的宏扩展中始终为 false",
  "%t 不得为初始值设定项列表的元素类型，因为它不是完整的对象类型",
  "默认参数表达式中的分隔符不匹配",
  "指向成员的指针转换为函数指针是非标准的",
  "已弃用动态异常规范",
  "%n 无法在当前范围内部分专用化",
  "%nd 是之前声明的 constexpr",
  "%nd 是之前未声明的 constexpr",
  "缺少 constexpr 变量的初始化表达式",
  "“constexpr”在此处无效",
  "一个 constexpr 函数只能包含一个 return 语句",
  "语句不能出现在 constexpr 函数中",
  "语句不能出现在 constexpr 构造函数中",
  "在此模式下，函数不能同时为 constexpr 和 virtual",
  "constexpr 函数不能具有非文本返回类型 %t",
  "constexpr 函数不能具有非文本类型 %t 的参数",
  "在表达式中未按顺序使用 %n 可能生成未定义的结果",
  "对 __builtin_assumed_aligned 的调用的可选的第三个参数必须具有整数类型",
  "析构函数不能是 constexpr",
  "为 mmap 提供的地址必须在页边界上对齐: %s",
  "constexpr 构造函数的主体不能是函数 try 块",
  "constexpr %nf 没有为以下对象提供初始值设定项:",
  "%n",
  "调用 %t 的默认构造函数不会生成常量值",
  "%t 的默认构造函数不是 constexpr",
  "constexpr 变量必须具有文本类型或引用类型",
  "带虚拟基的类的构造函数不能是 constexpr",
  "函数调用在常量表达式中必须具有常量值",
  "函数“main”不能是已声明的 constexpr",
  null,
  "类或枚举类型定义不能出现在 constexpr 函数或构造函数主体中",
  "此处只允许 GNU 样式的特性",
  "以非标准方式使用“auto”从初始值设定项推导类型并声明尾随返回类型",
  "使用限定 void 类型声明 void 参数列表是非标准的",
  "已忽略此局部声明上的限定符",
  "此常量表达式的类型为 %t，而所需类型为 %s",
  "实例化 __bases 或 __direct_bases 需要类类型",
  "__bases and __direct_bases 的参数必须是类型模板参数",
  "%s 只能在模板上下文中使用",
  "constexpr 函数返回值不是常量",
  "constexpr 构造函数调用了非 constexpr %n",
  "构造函数不能是 constexpr，因为 %n 的初始值设定项不是常量表达式",
  "constexpr 构造函数的非常量初始值设定项",
  "%t 的生成的默认构造函数不能在其自身的数据成员的初始值设定项中使用",
  "%n 的初始值设定项的实例化依赖于其自身的值",
  "默认化的默认构造函数不能是 constexpr，因为对应的隐式声明的默认构造函数不会是 constexpr",
  null,
  "二进制数无效",
  "一个联合最多只能有一个字段初始值设定项 - %nd 也具有初始值设定项",
  null,
  "联合的 constexpr 构造函数必须初始化它的一个字段",
  "constexpr 构造函数未能初始化匿名联合(已定义 %p)",
  "constexpr 静态数据成员声明需要类内初始值设定项",
  "最大 constexpr 深度/计数选项只能在编译 C++ 时使用",
  "表达式未折叠为常量，因为 constexpr 函数调用过于复杂",
  "无限制的联合选项只能在编译 C++ 时使用",
  "constexpr 构造函数必须初始化直接基类 %t",
  "字段初始值设定项中的 std::initializer_list 对象的创建可能无法发挥预期的作用，因为在整个表达式的结尾将销毁基础数组",
  "“this”不能在常量表达式中使用",
  null,
  "不允许对显式实例化指令使用“constexpr”",
  "无法确定默认构造函数的异常规范，因为存在循环依赖",
  "匿名联合定义的 %p",
  "此构造函数使用初始值设定项 %nd，这将导致无限定递归",
  null,
  "不允许对外部变量的局部声明使用初始值设定项",
  "不允许对命名的寄存器变量的局部声明使用初始值设定项",
  null,
  "无法在 Microsoft 模式下启用无限制联合",
  "构造函数直接或间接委托给其自身",
  "委托构造函数不能具有其他成员初始化表达式",
  "此处禁止使用引用限定符",
  "重载参数类型相同的两个成员函数需要它们同时具有或缺少引用限定符",
  "原始字符串分隔符中的字符无效",
  "在 16 个字符内找不到终止原始字符串分隔符的括号 - 原始字符串指示器被忽略",
  "找不到原始字符串的结束分隔符",
  "参数包必须是部分专用化中的最终模板参数",
  "类型为 %t 的指向成员的指针函数只能与 lvalue 对象一起使用",
  "类型为 %t 的指向成员的指针函数只能与 rvalue 对象一起使用",
  "此默认复制构造函数的参数不能是常量，因为基项或成员复制构造函数参数为非常量",
  "此默认赋值运算符的参数不能是常量，因为基项或成员复制赋值参数为非常量",
  "匿名联合必须至少包含一个非静态数据成员",
  "选项 \"delegating_constructors\" 需使用不同的编译器配置",
  "对齐降低已忽略",
  "rvalue 引用类型的 const_cast 的操作数不能是非类 prvalue",
  "表达式必须是 lvalue 或 xvalue",
  "转换可能会更改值",
  "已弃用从字符串文本到“char *”的转换",
  "已弃用从字符串文本到指向字符的指针(非常量)的转换",
  "\"override\" 和 \"final\" 是 C++11 特性",
  "禁止将 rvalue 引用作为异常规范类型",
  "属性 %sq 不适用于处理程序参数",
  "属性 %sq 需使用处理程序参数",
  "alignas 在此处不适用",
  "标准“alignof”运算符不接受表达式参数(而是使用类型)",
  "%t 的无效限定符(此处不允许使用派生类)",
  "\"always_inline\" 属性在非内联函数中被忽略",
  "继承构造函数时，必须从直接基类进行继承",
  null,
  "应有一个标签",
  "\"%%l\" 应后接一个操作数",
  "“%%l”的操作数编号未引用有效的 label 参数",
  "宽字符串在 \"asm\" 语句中无效",
  "属性不是标准属性",
  "不是 %t 类的基类",
  "用户定义的文本后缀中的非标识符字符",
  "多字符文本不能作为用户定义的文本的组成部分",
  "用户定义的文本后缀与之前的 %sq 不匹配",
  "文本运算符名称无效",
  "找不到用户定义的文本运算符",
  "文本运算符和/或文本运算符模板不明确:",
  "文本运算符不能是类的成员",
  "文本运算符不能具有外部 \"C\" 名称链接",
  "文本运算符应至少有一个参数",
  "此文本运算符的参数太多",
  "文本运算符的参数类型 %t 无效",
  "文本运算符的整数参数类型(%t)无效；应为字符类型或无符号 long long 类型",
  "文本运算符的浮点参数类型(%t)无效；应该为 long double",
  "文本运算符的第一个参数类型(%t)无效；不允许使用指向非 const 类型的指针",
  "文本运算符的第二个参数类型(%t)无效；必须为 size_t",
  "文本运算符的指针参数类型(%t)无效；应为指向字符类型的指针",
  "文本运算符不能具有省略号参数",
  "文本运算符模板不能具有任何参数",
  "文本运算符模板必须具有一个与“<char ...>”类似的模板参数列表",
  "线程本地存储类在此处无效",
  "线程本地声明后接非线程本地声明(声明了 %p)",
  "非线程本地声明后接线程本地声明(声明了 %p)",
  "文本运算符不能具有默认参数",
  "忽略线程本地变量的属性",
  "用户提供的文本后缀必须以 \"_\" 开头",
  "rvalue 引用是一项 C++11 特性",
  "lambda 表达式是一项 C++11 特性",
  "标准属性语法是一项 C++11 特性",
  "委托构造函数是一项 C++11 特性",
  "继承构造函数是一项 C++11 特性",
  "字段初始值是一项 C++11 特性",
  "删除函数是一项 C++11 特性",
  "默认函数是一项 C++11 特性",
  "不允许在显式专用化中使用存储类",
  null,
  "未区分范围的枚举不得透明，以进行专用化",
  "枚举模板声明必须引用以前声明的类模板成员",
  "应为矢量操作数",
  "shuffle 源操作数具有不兼容的类型 %t1 和 %t2",
  "shuffle 掩码(类型 %t)不是整数向量",
  "shuffle 掩码(类型 %t1)的长度与源操作数(类型 %t2)不同",
  "使用地址值进行的静态初始化要求大小与地址相同的目标",
  "功能测试宏的参数必须是简单标识符",
  "不能在主源文件中使用 __has_include_next",
  "在 __has_include_next 中使用了绝对文件名称",
  "属性 %sq 必须应用于函数类型",
  null,
  "此处不允许使用 _Noreturn",
  "应为实际浮点类型的操作数(而非 %t)",
  "__builtin_complex 需要兼容类型的操作数(与 %t1 和 %t2 不同)",
  "此 _Generic 选择内容中已出现默认关联",
  "此处不允许使用涉及可变长度数组的类型",
  "_Generic 选择内容中的关联类型(%t)重复",
  "关联均不与选择器类型 %t 匹配",
  "%n (%t)的类型与 ifunc 解决程序类型不兼容",
  "函数不能同时具有 ifunc 和 alias 属性",
  "函数不能同时具有 ifunc 和 weak 属性",
  "调用需使用字符串文本操作数",
  "继承构造函数声明重复(之前的 %p)",
  "“decltype(auto)”必须是完整变量类型(而不是该类型的一部分)的占位符",
  "此处禁止使用 decltype(auto)",
  "无法推导出 \"decltype(auto)\" (需要初始化表达式)",
  "无法推导出 \"decltype(auto)\" 类型",
  "块范围线程本地声明必须包含 static 或 extern",
  "推导出的返回类型 %t1 与之前推导出的类型 %t2 冲突",
  "无法推导出 %nd; 的返回类型；尚未定义",
  "虚函数不能具有推导出的返回类型",
  "从这个时间点起，%n 将被视为上下文相关的关键字",
  "全局命名空间不具有任何实际成员 %sq",
  "两种不同的枚举类型(%t1 和 %t2)之间的比较",
  "无法识别目标属性",
  "缺少 \"default\" 目标函数",
  "只能指定一个“arch= 目标”",
  "泛型类不能是自定义属性",
  "属性目标 %sq 无效",
  "不明确的属性 — 可以使用 %t1 和 %t2",
  "命名的属性参数只能引用公共非静态读/写字段或标量属性",
  "命名的属性参数只能引用属性参数类型的非静态字段或标量属性",
  "属性参数无效 — 表达式必须是属性参数类型的常数",
  "属性参数不能使用泛型类型参数",
  "%t 只能用作独立属性",
  "不常用属性/事件不能使用“field”属性目标",
  "独立属性的属性目标无效",
  "此上下文的属性目标无效",
  "此处不能使用 %t 属性",
  "已弃用 %t；请使用 \"...\" 来指定参数数组",
  "无法扩展默认命名空间",
  "装箱类型必须为值类或枚举",
  "不允许跟踪对值类的引用",
  "不允许使用值类图柄",
  "不允许跟踪对枚举的引用",
  "不允许使用枚举图柄",
  "不允许使用公共本机类型",
  "不允许使用公共嵌套类型",
  "C++/CX 中不允许使用泛型类型",
  "C++/CX 中不允许使用泛型方法",
  "不允许使用泛型约束",
  "公共 C++/CX 值类型中不允许使用非公共数据成员",
  "公共 C++/CX 值类型中不允许使用公共非数据成员",
  "不允许在公共 C++/CX 值类型中使用构造函数",
  "“add”访问器的返回类型必须为 Windows::Foundation::EventRegistrationToken",
  "“remove”访问器的返回类型必须为 void",
  "“remove”访问器的参数类型必须为 Windows::Foundation::EventRegistrationToken",
  "不允许对泛型参数类型使用句柄，也不允许引用泛型参数类型",
  "非值类型中不允许公共数据成员",
  "只能在 Microsoft C++ 模式中启用 C++/CX",
  "不能合并 C++/CLI 和 C++/CX 模式",
  "%sq 需要 C++/CX 模式",
  "C++/CX 模式需要 microsoft_version >= 1600",
  "C++/CX 中不允许使用文本字段",
  "标准引用不能绑定到 C++/CX 类型",
  "类型必须对应于 Platform::Boolean、default::uint8、default::int8、default::int16、default::uint16、default::int32、default::uint32、default::int64 或 default::uint64",
  "C++/CX 值类型不能具有事件",
  "句柄类型的 dynamic_cast 必须引用完整的类类型",
  "Platform::Array 只能是一维的",
  "不允许跟踪对标准类类型的引用",
  "C++/CX 值类型不能从接口继承",
  "C++/CX 值类型不能包含虚函数",
  "\"partial\" 只能应用到全局范围或命名空间范围的 \"ref class\" 或 \"ref struct\"",
  "\"set\" 访问器的参数必须为类型 \"const Platform::Array<T>^\"",
  "在全局范围内不允许使用公共 C++/CX 类型的定义",
  "不允许使用具有公共“get”或“set”访问器的索引属性",
  "不允许使用公共嵌套的委托类型",
  "委托初始值设定项无效 - 预期为“(<function-address 或 functor-object> [, Platform::CallbackContext])”或“(<object handle>, <member-address> [, Platform::CallbackContext [, bool]])”",
  "委托初始值设定项无效 - 对象必须是 %[managed] 类的句柄",
  "C++/CX 不支持“in/out”数组 — 在公共 API 中，请使用“const Platform::Array<T>^”代替“in”，使用“Platform::WriteOnlyArray<T>^”或“Platform::Array<T>^*”代替“out” 。",
  "%nd 缺少 \"target\" 属性",
  "所声明的成员函数均不与 %n 的 \"target\" 属性匹配",
  "此位置的 Microsoft 属性只允许接口类型",
  "需要 GNU 函数的多版本解析程序例程",
  "在托管类中声明的枚举类型必须包含一个定义",
  "在此声明上下文中，由 decltype 限定的名称是非标准的",
  "不能使用 \"final\" 修饰符声明非虚函数",
  "不支持特殊函数上的 \"target\" 属性",
  "必须是窄字符串文本",
  "圆括号不匹配",
  "没有对应的 \"push_options\"",
  "函数内部不允许使用此 pragma",
  "声明一个新的或删除运算符 \"inline\" 是非标准操作",
  "数据成员的成员初始值设定项不能为包扩展",
  "泛型 lambda 表达式在此模式下不能具有捕获默认值",
  "友元声明中的默认模板参数只能在定义中指定",
  "带默认模板参数的友元模板声明必须是唯一的声明(第一次声明 %p)",
  "不透明的枚举声明不能是另一个声明的一部分",
  "不透明的枚举声明在此上下文是非标准的",
  "扩展的友元语法是一项 C++11 特性",
  "未启用数字分隔符，字符文本以撇号开头",
  "此处不能出现数字分隔符",
  "Microsoft 模式中忽略 \"constexpr\"",
  "语句表达式结果的表达式无效",
  "标识符是宏，而非后缀文本",
  "不能在 lvalue 上调用 %nd",
  "不能在 rvalue 上调用 %nd",
  "不能在 lvalue 上调用成员函数",
  "不能在 rvalue 上调用成员函数",
  "模板参数列表太长",
  "别名模板类型 %t1 与 %nfd 的重新声明中 %t2 的上一个类型不兼容",
  "%nd 的字段初始值设定项不是常量表达式",
  "各约束字符串中操作数约束的数量必须相同",
  "约束字符串包含太多可选约束；并未检查所有的约束",
  "通过不完整的类 %t 进行的调用在实例化时总是会生成错误",
  "decltype(auto) 不能有添加的类型限定符",
  "此处无法捕获 init-capture %nod",
  "类型 %t 的非类型模板参数无效",
  "已忽略 abi_tag 属性(它在 C 模式下没有任何意义)",
  "重新声明将添加 abi_tag 属性“%s”",
  "已忽略 abi_tag 属性(已被随后的 abi_tag 属性取代)",
  "%nd 以前的声明没有 abi_tag 属性",
  "(请参阅之前的声明 %p)",
  "专用化时忽略了 abi_tag 属性",
  "decltype(auto)不能在指针、引用或指向成员的指针构造下出现",
  "应为 \"class\" 或 \"typename\"",
  "放置 \"new\" 表达式引用了非放置 %nd",
  "在生成运行时库时必须指定 C++14 模式",
  "%s",
  "命令行警告",
  "命令行警告",
  "constexpr 非静态成员函数在 C++14 中将不会是隐式 \"const\"",
  "constexpr 函数中的变量类型 %t 不是文本类型",
  "constexpr 函数中的变量不具有自动存储持续时间",
  "constexpr 函数中的变量未初始化",
  "使用占位符类型(但未使用 \"=\")声明的变量的大括号初始化只需要大括号里有一个元素",
  "无 \"%s\" --存在目标配置",
  "64 位 x86 配置中不支持属性",
  "“%s”需要一个参数",
  "构造函数或析构函数不能是协同例程",
  "%n 不能是协同例程",
  "catch 子句中不允许 co_yield 表达式",
  null,
  null,
  null,
  null,
  "未找到类模板 %sq",
  "在依赖上下文中使用 \"typename\" 关键字将 %n 视为类型 ",
  "参数值必须小于矢量元素的总和",
  "%t 不具有成员 %sq",
  "用大括号括起的列表不提供返回类型",
  "co_await 表达式必须出现在函数范围内",
  "catch 子句中不允许 co_await 表达式",
  "协同例程不能具有省略号参数",
  "要具备对 \"bool\" 的支持才能启用 C++14 样式的 constexpr",
  "未定义 constexpr %nd",
  "无法计算此调用，因为目标函数 %nd 不为 constexpr 或尚未完全定义",
  "注释",
  "注释",
  "匿名联合无效 -- 不允许使用别名成员模板",
  "UTF-8 字符文本值不能占用多个代码单元",
  "%nd 的值不可用作常量",
  "%nd 的指针或引用不可用作常量",
  "非数组对象的非零下标",
  "无法访问 %d2 元素数组的位置 %d1",
  "调用自:",
  "对联合的非活动 %n1 (%n2 处于活动状态)的无效访问",
  "无法在 constexpr 上下文中执行 \"goto\"",
  "缺少返回值",
  "被调用方为空",
  "尝试取消引用空指针",
  "尝试访问 %d 元素数组末尾后一个位置的存储",
  "尝试访问已过期的存储",
  "尝试访问运行时存储",
  null,
  "无法调用非 constexpr %nd",
  "无法在 constexpr 计算过程中使用变长数组",
  "无法执行负移位",
  "移位量(%d)过大",
  "值超出 %t 的范围",
  "浮点错误",
  "尝试取消引用指向成员的空指针(数据成员)",
  "比较指向 void 和指向函数的指针是非标准的",
  "元数据初始化失败",
  "从基类到派生类的转换无效(完整的类类型是 %t)",
  "对完整类型 %t 的对象中的 %n 的访问无效",
  "此处禁止使用 \"__auto_type\"",
  "\"__auto_type\" 不允许多个声明符",
  "\"__auto_type\" 不允许使用 \"{...}\" 进行初始化",
  "\"__auto_type\" 必须是完整类型变量的占位符(而不是该类型组件的占位符)",
  "使用 \"__auto_type\" 声明的变量需要初始化表达式",
  "整型常数必须大于等于零",
  "类型必须是整型类型",
  "表达式无法解释",
  "语句无法解释",
  "对解释器存储空间地址的使用无效",
  "常数类型对常数表达式无效",
  "类型 %t 对常数表达式求值太大",
  "类型 %t 对常数表达式求值无效",
  "从 %t1 转换到 %t2 在常数表达式求值中无效",
  "浮点转换失败",
  null,
  "推导出的返回类型是一项 C++14 特性",
  "无法计算具有关联析构函数的构造函数",
  "在 constexpr 求值过程中，%n 未初始化",
  "constexpr 求值中的指针差异无效",
  "非数组指针上的算术无效",
  "无法在第一个数组元素的前面设置指针",
  "具有推导出的返回类型的协同例程无效",
  "未求值的上下文中禁止使用表达式",
  null,
  null,
  "在协同例程中不允许使用 \"return\" (请改用 \"co_return\")",
  "仅允许在协同例程中使用 \"co_return\"",
  "不能比较浮点值",
  "不能对指针值进行比较，因为它们不指向同一完整对象或者它们指向具有不同可访问性的子对象",
  "忽略非内联命名空间上的 abi_tag 属性",
  "忽略匿名命名空间上的 abi_tag 属性",
  "复杂或假想的模板参数类型是非标准的",
  "不允许在函数范围之外使用 co_yield 表达式",
  "忽略匿名联合上的线程本地指示",
  null,
  "变量模板",
  "对未初始化的对象的访问",
  "尝试从易失存储中读取",
  "对联合的非活动 %n1 (没有字段处于活动状态)的无效访问",
  "constexpr 函数中不能出现标签定义",
  "无法将超过数组的结尾指针与指向另一个完整对象的指针相比较",
  "函数类型 %t 对变量模板实例化是一个无效的类型",
  "变量不能有不完整的类型 %t",
  "对未初始化的子对象的访问(%n)",
  "对未初始化的子对象的访问(基类 %t)",
  "常数表达式中不允许使用伪析构函数调用",
  "尝试修改常量存储",
  null,
  null,
  "尝试访问存储，一个超过被视为某个元素的一个数组的对象的位置",
  "不能在常数表达式求值中使用 reinterpret_cast",
  "禁止在空指针上操作",
  "*this 的值不能用作常数",
  "“内联”关键词不能用于嵌套命名空间声明中",
  "忽略了 \"carries_dependency\" 属性",
  "\"__event __interface\" 不能在此处定义",
  "事件处理程序必须具有 void 或整型返回类型",
  "之前肯定已定义过 \"__event __interface\"",
  "%n 的模板参数太多",
  "枚举器已声明(请参阅 %nd)",
  "正在模拟的 Microsoft 版本至少必须是 1903 才能使用 \"--ms_c++14\"",
  "正在模拟的 Microsoft 版本至少必须是 1903 才能使用 \"--ms_c++latest\"",
  "类型 %t 不能为 _Atomic，因为其为数组或函数类型",
  "_Atomic(...) 说明符不能应用于限定类型 %t",
  "对 _Atomic 对象的成员的访问",
  "位域不能具有 _Atomic 类型",
  "已禁用 _Atomic 类类型",
  "constexpr 构造函数调用非 constexpr 构造函数来初始化子对象",
  "应为逗号(此模式未启用 static_assert 的单参数版本)",
  "静态断言失败",
  "最多使用 _Nullable、_Nonnull 和 _Null_unspecified 中的一个限定符修饰类型",
  "只有指针和指向成员的指针类型允许使用为 null 性的限定符",
  "矢量过长",
  "矢量元素类型必须是整型、枚举或真浮点类型",
  "内置函数无法使用，因为不支持 128 位整数",
  "内置函数无法使用，因为不支持矢量类型",
  "两个连续的左方括号必然会引入一个属性列表，但此处不能出现属性列表",
  "无法识别的 \"target\" 特性将使解析程序例程无法使用此例程",
  "%t 不是矢量类型",
  "适量类型 %t1 和 %t2 长度必须相同",
  "添加的默认参数不会导致声明默认或复制构造函数",
  "引用类型的非类型模板参数必须绑定到一个函数或一个完整对象",
  "此处不允许使用 %t",
  "不允许使用 \"register\" 存储类说明符",
  "已弃用 \"register\" 存储类说明符",
  "不允许递增布尔值",
  "%sq 已声明为基于范围的 \"for\" 语句的迭代，不能在此范围内重新声明",
  "此处不能使用特性命名空间(因为指定了 \"using\" 前缀)",
  "未识别属性命名空间 %sq",
  "值类中不允许使用默认成员初始化表达式",
  "\"--implicit_noexcept\" 需要可启用 noexcept 的模式",
  "不能折叠涉及虚拟基类的操作(%t)",
  "初始化不是常数",
  "无法计算不完整 %t 的值",
  "忽略使用 \"nodiscard\" 属性声明的例程的返回值",
  "忽略具有 \"nodiscard\" 属性的返回值类型",
  "\"nodiscard\" 属性不适用于析构函数或返回类型为 void 的例程",
  "\"fallthrough\" 属性仅适用于 null 语句",
  "\"fallthrough\" 属性可能只出现在封闭的 switch 语句中",
  "fallthrough 语句必须后接 switch case 标签或默认值",
  "指向生存期有限的临时内容的引用或指针",
  "无法获取属性为 \"enable_if\" 的函数的地址，该属性的条件并非绝对为 true",
  "当前不支持条件非常数值的 \"enable_if\" 属性",
  "属性在此处声明",
  "__has_include 不能出现在 #if 外部",
  "无法添加 CComCoClass 基类",
  "不是以 null 结尾的字符串",
  "伪析构函数调用中不能使用非标量类型 %t",
  "\"weak\" %n 的地址不是常量",
  "函数模板签名的递归替换项过多",
  "结构化绑定声明的说明符无效",
  "结构化绑定语法无效",
  "缺少初始化表达式",
  "类型 %t 没有要绑定到的组件",
  "标识符过多",
  "元素数量比绑定名称数量多",
  "未定义 \"std::tuple_element\"",
  "无法为 <%s, %t> 实例化 \"std::tuple_element\"",
  "无法为类型 %t 调用成员函数 \"get<%s>()\"",
  "%no 的实例均不与参数列表匹配",
  "此结构化绑定需要合适的 %sq 函数，但未找到任何此类函数",
  "结构化绑定无法声明为 \"inline\"",
  "结构化绑定无法声明为 \"constexpr\"",
  "结构化绑定无法声明显式存储类",
  "std::tuple_size<%t>::value 不是有效的整型常数表达式",
  "条件声明必须声明变量",
  "条件声明必须包含初始化表达式",
  "条件声明不允许使用带圆括号的初始化表达式",
  "一个条件声明只能声明一个变量",
  "结构化绑定无法绑定到结束类型",
  "无法绑定到非公共的 %n",
  "无法绑定到不完整的类型 %t",
  "此声明在此处无效",
  "constexpr 函数的主体不能是函数 try 块",
  "不允许将控制传输到 constexpr if 块",
  "无法捕获结构化绑定",
  "正在模拟的 Microsoft 版本必须至少为 1911 才能使用 \"--ms_c++17\"",
  "尝试读取超出对象末尾的内容",
  "此模式中未启用 constexpr lambda",
  "常数表达式不能包含 lambda 表达式",
  "值超出模板参数的数目",
  "二进制 fold 表达式中的第二个运算符与第一个不匹配",
  "fold 表达式运算符无效",
  "一个二进制 fold 表达式不可应用于两个参数包",
  "空扩展对此 fold 表达式无效",
  "无法将非静态数据成员声明为 inline",
  "fold 表达式不引用参数包",
  "无法重载参数类型相同但异常规范不同的两个函数",
  "此模式下不允许动态异常规范",
  null,
  "noexcept 说明符的操作数无效",
  "Lambda 表达式不能出现在模板的 noexcept 说明符中",
  "%nfd 不可访问",
  "枚举模板声明中的说明符无效",
  "此配置中不支持 80 位浮点类型",
  "此配置中不支持 128 位浮点类型",
  "枚举值无效",
  "必须是 _Atomic 限定类型",
  "数组元素的类型必须是完整的",
  "已取消此函数的 always_inline 属性",
  "此处不允许使用负值",
  "整数包元素不能与 %n 匹配",
  "整数包元素不能与 %n 匹配",
  "意外的指示符",
  "无法计算 __builtin_offsetof",
  "不能定义推导指南 %t",
  "必须在与 %n 相同的范围内声明推导指南",
  "推导指南声明说明符无效(仅允许 \"explicit\")",
  "无法在常量表达式中访问常量的可变 %n",
  "函数修饰符不适用于静态成员声明",
  "\"overloadable\" 属性需要原型函数声明",
  "无法从 %t2 推导出“自动”模板参数类型 %t1",
  "类模板名称必须是正在初始化的完整类型的占位符(而不是该类型组件的占位符)",
  "别名声明是一项 C++11 特性",
  "别名模板是一项 C++11 特性",
  "返回类型必须直接指定关联类模板的特例",
  "复制列表初始化不能使用“显式”%n",
  "推导指南",
  "用户定义的文本运算符的值无效",
  "#if 或 #elif 之外不能出现 __has_cpp_attribute",
  "必须使用与 %n 相同的辅助功能声明推导指南",
  "此上下文中不允许使用 lambda",
  "指定的对齐方式不等同于以前的声明",
  "定义上未指定对齐方式；以前的声明具有指定的对齐方式",
  "内置函数不可用，因为不支持 128 位浮点类型",
  "左移负值具有未定义的行为",
  "C++ 中的数组指示符不标准",
  "C++ 中的链接指示符不标准",
  "在 C++ 中将指定和非指定的初始化表达式混搭是非标准操作",
  "C++ 中的无序初始化表达式不标准",
  "字符串文本运算符模板必须具有一个与“<typename T, T ...>”等效的模板参数列表",
  "指示符不得重复",
  "属性与之前的 likely/unlikely 属性相冲突",
  "已弃用 \"this\" 的隐式 by-copy 捕获",
  "lambda 表达式中不允许使用空模板参数列表",
  "正在模拟的 Microsoft 版本必须至少为 1920 才能使用 \"--ms_c++20\"",
  "此模式下不接受 STDC pragma 参数",
  "constexpr if 语句是 C + + 17 特性",
  "指定的初始值设定项列表中不允许包含包扩展",
  "字段指示符没有值",
  "一个联合最多只能有一个字段初始值设定项",
  "找不到有效的 std::%s 类型(必须包括 <compare>)",
  "以下内置运算符的类型(%t1 和 %t2)无效: <=>",
  "fold 表达式在此模式中是非标准的",
  "通过 --current_directory 选项指定的目录不是目录: %s",
  "PCH 警告",
  "头停止点需要位于全局范围。未生成 IntelliSense PCH 文件。",
  "宏调用正在进行中。未生成 IntelliSense PCH 文件。",
  "头停止点不在文件范围内。未生成 IntelliSense PCH 文件。",
  "头停止点不能位于宏或 #if 块中。未生成 IntelliSense PCH 文件。",
  "头停止点不能位于链接块中。未生成 IntelliSense PCH 文件。",
  "找不到合适的头停止点位置。未生成 IntelliSense PCH 文件。",
  "不能在 PCH 中使用行指令。未生成 IntelliSense PCH 文件。",
  "限制说明符无效",
  "必须从受 AMP 限制的函数调用受 AMP 限制的函数 %nfd",
  "函数 %nfd1 的限制说明符与调用函数 %nfd2 不相符",
  "重载候选项均不具备正确的限制说明符",
  "%t 不可在受 AMP 限制的函数 %nfd 中使用",
  "this-pointer 中的类型 %t 对于 amp 限制的成员函数 %nfd 是非法的",
  "返回类型 %t 对于受 AMP 限制的函数 %nfd 是非法的",
  "参数类型 %t 对于受 AMP 限制的函数 %nfd 是非法的",
  null,
  "存储类 %s 在受 AMP 限制的函数 %nfd 中是非法的",
  "%s 不可在受 AMP 限制的函数 %nfd 中使用",
  "受 AMP 限制的函数中的强制转换非法",
  "不允许在受 AMP 限制的函数中使用异常规范",
  "受 AMP 限制的函数 %nfd 中的间接寻址非法",
  "虚函数调用在受 AMP 限制的函数 %nfd 中是非法的",
  "间接函数调用在受 AMP 限制的函数 %nfd 中是非法的",
  "此处不允许使用 tile_static 存储类",
  "受 AMP 限制的函数 %nfd 中的标签非法",
  "受 AMP 限制的函数 %nfd 的位域非法",
  "受 AMP 限制的函数 %nfd 的省略号非法",
  "amp 兼容的类型 %nfd 的虚拟基非法",
  "受 AMP 限制的函数 %nfd 中的外部引用非法",
  "常数值超出了受 AMP 限制的函数 %nfd 中的支持范围",
  "受 AMP 限制的函数的 pragma 包值 %s 非法",
  "限制说明符不可重叠",
  "析构函数的限制说明符必须包含所有构造函数的限制说明符的联合部分",
  null,
  "nostdlib 要求至少使用一个强制 using",
  null,
  null,
  null,
  null,
  "extern \"C\" 函数不支持多个限制说明符",
  "不允许使用成员函数指针、函数指针和引用带 \"amp\" 限制说明符的函数",
  "对于受 AMP 限制的函数 %nfd，基类、数据成员或数组元素必须至少有 4 个字节对齐",
  "对于受 AMP 限制的函数 %nfd，数据成员的偏移必须为其自然对齐的倍数",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "tile_static 变量不能有初始化表达式",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "/clr:nostdlib 要求 mscorlib.dll 位于强制 using 的列表中",
  "/clr:netcore with /clr:nostdimport 要求 System.Runtime.dll、System.Runtime.Extensions.dll、System.Runtime.InteropServices.dll 和 System.Runtime.CompilerServices.VisualC.dll 位于包含强制 using 的列表中",
  null,
  null,
  null,
  null,
  null,
  "<diagnostic emission failure>",
  "错误过多，导致 IntelliSense 引擎无法正常工作。其中一些错误可能在编辑器中不可见。",
  "对 \"this\" 计时错误的赋值与 C++11 模式不兼容",
  "出现了未知错误。未生成 IntelliSense PCH 文件。",
  "一个或多个远程路径无法映射到现有本地路径。IntelliSense 体验可能会降级。",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "应使用 \">>>\"",
  "找不到 __cudaPushCallConfiguration 声明。CUDA 工具包安装可能已损坏。",
  "C++17 样式初始值设定项在此模式中是非标准的",
  "正在捕获 *这在此模式中是非标准的",
  "C++17 样式 \"using\" 属性前缀在此模式中是非标准的",
  "C++17 样式嵌套命名空间在此模式中是非标准的",
  "声明中只能出现 \"constexpr\"、\"consteval\" 和 \"constinit\" 中的一个",
  "在此模式下，函数不能同时为 consteval 和 virtual",
  "不允许对显式实例化指令使用 \"consteval\"",
  "\"consteval\" 在此处无效",
  "析构函数不能是 consteval",
  "带虚拟基的类的构造函数不能是 consteval",
  "不允许对变量或静态数据成员的声明使用 \"consteval\"",
  "%nd 是之前声明的 consteval",
  "%nd 是之前未声明的 consteval",
  "函数 \"main\" 不能是已声明的 consteval",
  "调用 consteval %n 不会生成有效的常数表达式",
  "常数表达式结果中 consteval %n 的地址",
  "consteval 成员不能替代非 consteval %n",
  "非 consteval 成员不能替代 consteval %n",
  "结构化绑定",
  "%t1 类型的子对象的 dynamic_cast 无效(最底层派生类型为 %t2)",
  "标识符 __VA_OPT__ 只能出现在可变参数宏中的替换列表中",
  "__VA_OPT__ 不能出现在 __VA_OPT__ 操作数中",
  "__VA_OPT__ 缺少右括号",
  "__VA_OPT__ 必须后跟 \"(\"",
  "\"##\" 不能为 __VA_OPT__ 操作数中的第一项",
  "\"##\" 不能为 __VA_OPT__ 操作数中的最后一项",
  "C++20 样式嵌套内联命名空间在此模式中是非标准的",
  "无法将指向基类 %t2 的指针转换为指向派生类 %t1 的指针 - 尝试指向最底层派生类对象之外的对象",
  null,
  "\"main\" 不能用作全局变量名或给定 C 语言的链接",
  "不能在链接规范中声明函数 \"main\"",
  "条件中不允许使用结构化绑定",
  "在 \"::\" 之前需要使用属性命名空间标识符",
  "只允许使用一个属性命名空间",
  "此处禁止使用 \"return\"",
  "结构化绑定不能与其他声明符组合",
  "无法从常量计算上下文中作出分支",
  "不允许使用结构化绑定模板",
  "带圆括号的初始值设定项必须为表达式，而不能是用大括号括起的列表",
  "无法推导类模板参数",
  "new 或 delete 运算符不能声明为 \"consteval\"",
  "此处不能使用 consteval 函数的地址",
  "函数类型(%t)的对齐方式是非标准的",
  "非指定边界的数组的对齐方式在 C 中是非标准的",
  "变量不能同时具有 \"common\" 和 \"internal_linkage\" 属性",
  "\"internal_linkage\" 属性未出现在之前的声明中",
  "未找到 %n 的可行模板参数推导候选项",
  "不允许使用完全限定的构造函数调用",
  "默认比较运算符必须是它适用于的类的成员或友元",
  "默认比较运算符的参数的类型 %t 不正确(必须是“对 const X 的引用”，其中 X 是封闭类类型)",
  "默认比较运算符的返回类型必须是 \"bool\"",
  "默认成员比较运算符必须为 \"const\"",
  null,
  "协同例程的 promise 类型 %t 不能同时设置 \"return_void\" 和 \"return_value\"",
  "“return_value”已声明 %p",
  "\"return_void\" 已声明 %p",
  "当 %t 在 %n 末尾没有 \"return_void\" 时，缺少 co_return 语句",
  "对于协同例程状态分配，找不到全局 \"operator new\" 的 nothrow 变体",
  "对于协同例程状态解除分配，找不到可行的 \"operator delete\"",
  "constexpr 函数不能是协同例程",
  "此 %s 表达式的操作数解析为非类 %t",
  "静态初始化表达式中不允许使用 co_await 表达式",
  "调用 %n 的 co_await 表达式必须是非引发的",
  "递归比较重写操作太多",
  "默认运算符 <=> 可推导的返回类型必须为 \"auto\"",
  "非常数源的隐式副本",
  "结构化绑定不能声明静态或 thread_local 以外的显式存储类",
  "重要 Microsoft 属性字段不支持默认比较运算符",
  "标准比较类型(%t)必须是具有单个整型非静态数据成员的类类型",
  "未在 %t 中找到任何 constexpr 静态数据成员 %sq",
  "元素数(%d)太大，无法动态分配",
  "constexpr 动态分配请求过大",
  "解除分配未动态分配的存储",
  "解除分配大小(%d1)与分配的大小(%d2)不对应",
  "此处发生了分配",
  "解除分配类型(%t1)与分配类型(%t2)不对应",
  "某些动态分配(总数 = %d)未解除分配",
  "使用意外签名(类型 %t)声明了内部 %n",
  ">> std::__report_constexpr_value 的输出",
  ">> 结束 std::__report_constexpr_value 的输出",
  "无法在 constexpr 计算中使用大小取决于数组的数组",
  "忽略使用 \"nodiscard\" 属性(%sq)声明的例程的返回值",
  "忽略具有 \"nodiscard\" 属性(%sq)的返回值类型",
  "用于创建已放弃对象的构造函数具有 \"nodiscard\" 属性",
  "用于创建已放弃对象的构造函数具有 \"nodiscard\" 属性(%sq)",
  "已放弃对象的类型具有 \"nodiscard\" 属性",
  "已放弃对象的类型具有 \"nodiscard\" 属性(%sq)",
  "伪析构函数引用仅可用于伪析构函数调用",
  "常数表达式中不允许使用显式析构函数调用",
  "数组下标表达式中未带圆括号的逗号运算符已弃用",
  "对于初始化表达式，动态分配的元素数(%d)太小",
  "%s 表达式的可变操作数已弃用",
  "不建议使用易失标量对象的赋值结果",
  "复合赋值表达式的易失目标类型已弃用",
  "易失函数参数已弃用",
  "易失返回类型已弃用",
  "不推荐在结构化绑定上使用易失限定符",
  "\"ext_vector_type\" 参数必须介于 1 到 2047 之间",
  "\"ext_vector_type\" 属性只能出现在 typedef 中",
  "\"ext_vector_type\" 属性仅适用于整数或浮点类型",
  "在当前编译模式下，忽略了此功能测试宏(并返回 0)",
  "无法使用联合的多个元素计算聚合初始值设定项",
  "为运算符重写选择的 %nd 不返回布尔类型",
  "无法对调用类专属分配函数的 new-expression 进行常量计算",
  "无法对 placement new 表达式进行常量计算",
  "需使用虚拟析构函数才能通过子对象指针删除",
  "%npTd，带逆序参数",
  "__INTADDR__ 的操作数必须是从空指针算起的偏移量",
  "泛型构造与多个类型相匹配(_G)",
  "另一匹配是 %t",
  "已忽略此处使用的 \"availability\" 属性",
  "在基于范围的 \"for\" 语句中，C++20 样式的初始化表达式语句在此模式下不是标准的",
  "co_await 只能应用到基于范围的 for 语句",
  "无法在基于范围的 \"for\" 循环中推断范围类型",
  "内联变量是 C++17 功能",
  "销毁运算符 delete 需要 %t 作为第一个参数",
  "销毁运算符 delete 不能具有 std::size_t 和 std::align_val_t 以外的参数",
  "宽松抽象类选项只能在编译 C++ 时使用",
  "requires 子句中表达式的开头无效",
  "requires 子句中的强制转换表达式必须放在括号中",
  "此运算符不能出现在 requires 子句的顶层(不带括号)",
  "原子约束必须具有 bool 类型",
  "原子约束未能替换",
  "原子约束不是常量",
  "原子约束的计算结果为 false",
  "不满足模板约束",
  "概念定义不能出现在此范围内",
  "%nd 的重新声明无效",
  "concept-id 的参数 %T 替换失败",
  "参数 %T 的概念为 false",
  "此处不允许使用 requires 子句(不是模板化函数)",
  "概念模板",
  "requires 子句与 %nfd 不兼容",
  "预期特性",
  null,
  "预期类型名称",
  "requires 表达式中不允许使用省略号参数",
  "requires 表达式中未命名的参数不起任何作用",
  "预期概念名称",
  "在常量表达式中出现的对 %s 的调用始终产生 \"true\"",
  "在 consteval 上下文中出现的对 %s 的调用始终产生 \"true\"",
  "在非 constexpr 函数中出现的对 %s 的调用始终产生 \"false\"",
  "%t 的类型约束失败",
  "在启用 C++ 模块的模式中，不能使用选项“导出”",
  "全局模块片段声明必须位于任何其他声明之前",
  "模块声明前面只能是全局模块片段",
  "专用模块片段前面必须有模块声明",
  "无法导出 %s 模块片段",
  "不能声明一个以上的模块",
  "不能声明一个以上的 %s 模块片段",
  "必须使用非空名称声明模块",
  "%sq 不是可导入标头",
  "不能导入没有名称的模块",
  "模块不能与自身有接口依赖关系",
  "已导入模块 %sq",
  "模块文件",
  "找不到模块 %sq 的模块文件",
  "无法导入模块文件 %sq",
  "预期 %s1，但找到 %s2",
  "打开模块文件 %sq 时",
  "未知的分区名称 %sq",
  "未知模块文件",
  "可导入标头模块文件",
  "EDG 模块文件",
  "IFC 模块文件",
  "意外的模块文件",
  "第二个操作数的类型 %t2 必须与 %t1 大小相同",
  "类型必须可轻松复制",
  "类型 %t 当前不支持对 __builtin_bit_cast 进行 constexpr 计算",
  "位域为 %t 的类类型当前不支持对 __builtin_bit_cast 进行 constexpr 计算",
  "引用类型 %t 的非静态数据成员阻止对 __builtin_bit_cast 进行 constexpr 计算",
  "易失类型 %t 阻止对 __builtin_bit_cast 进行 constexpr 计算",
  "联合类型、指针类型或指向成员的指针类型 %t 阻止对 __builtin_bit_cast 进行 constexpr 计算",
  "%npTd，已通过使用 decl %p 继承",
  "无法为继承构造函数执行 %t 的子对象构造 -- 已删除隐式默认构造函数",
  "%n 必须返回 void",
  "成员声明的开头无效",
  "应为 \"auto\"",
  "此位置不允许使用此运算符；请前面的新表达式括起来",
  "概念的使用无效",
  "默认成员比较运算符不能是 \"&&\" 限定",
  "默认的 constexpr 比较函数会调用非 constexpr 函数 %nd",
  "只有整数或数组整数对象支持 constexpr 内存比较",
  "概念模板不能具有关联约束",
  "不允许使用 \"export\"",
  "不允许导出单个类成员",
  "导出的声明必须引入名称",
  "导出声明不能包含导出声明(以前的声明 %p)",
  "导出声明不能包含模块导入声明",
  "导出声明只能出现在模块接口单元中",
  "导出声明无法导出具有内部链接的名称",
  "using 声明包括 %nfd",
  "内置函数不可用，因为不支持 __fp16 浮点类型",
  "requires 表达式必须指定至少一个要求",
  "\"constinit\" 在此处无效",
  "\"constinit\" 仅对具有静态或线程存储持续时间的变量的声明有效",
  "constinit 变量需要动态初始化",
  "以前使用 \"constinit\" %p 声明了变量",
  "使用非原型函数声明符",
  "参数不能具有常量限定类型",
  "不允许使用不完整类型 %t 的指向成员的指针",
  "此模式下未启用 init-capture 中的包扩展",
  "init-capture 中的包扩展是 C++ 20 功能",
  "类定义中默认的比较运算符必须是该比较运算符的第一个声明(%nd)",
  "init-capture 中的包扩展只能在可变参数模板中使用",
  "类型约束使用不是类型概念的 %nd (即，第一个参数为类型参数的概念模板)",
  "推导出的占位符类型 %t 未能通过类型约束",
  "%t 的默认构造函数不合格",
  "%t 的析构函数不明确，因为存在未排序的约束",
  "由于约束失败，%t 的析构函数不合格",
  "析构函数候选项不明确",
  "虚函数不能有尾随 requires 子句",
  "%nd 不满足其约束",
  "decltype 限定符的结果 %t 不是类或枚举",
  "标准 C++20 中的比较不明确，因为连接反向参数的隐式比较运算符的比较结果表示了同等好的匹配--这通常是由于比较运算符中缺少 \"const\" 限定符造成的; 请参阅 %nod",
  "concept-id 无效",
  "requires-clause 的参数 %T 替换失败",
  "不满足 %nd 的约束",
  "constexpr 函数中变量类型 %t 具有虚拟基类",
  "常数表达式无法为类型 %t 分配虚拟基子对象",
  "类类型的模板参数必须是结构类类型",
  "对 UTF-8 文本的支持需要 u 文本支持。",
  "多次为“%s”指定了模块文件映射",
  "多次为“%s”指定了标头单元映射",
  "未为“%s”指定映射",
  "“%s”的模块文件映射无效",
  "找不到要导入的标头“%s”",
  "模块文件列表中有多个文件与“%s”匹配",
  "为“%s”找到的模块文件用于其他模块",
  "任何类型的模块文件",
  "无法读取模块文件",
  "内置函数不可用，因为当前选项不支持 char8_t 类型",
  "如果启用了 C++20 协同程序，则无法指定 --ms_await 命令行选项",
  "对默认聚合元素初始化使用显式构造函数 %nod 不是标准做法",
  "与 memcpy 类似的固有项的源或目标不指向对象",
  "与 memcpy 类似的固有项尝试复制在表达上不同的类型 %t1 和 %t2",
  "与 memcpy 类似的固有项尝试复制非平凡可复制类型 %t",
  "与 memcpy 类似的固有项尝试复制部分对象",
  "与 memcpy 类似的固有项尝试复制过去的数组边界",
  "与 memcpy 类似的固有项尝试复制重叠的字节范围(改为使用相应的 memmove 操作)",
  "带有尾随 requires 子句的 friend 声明必须是一个定义",
  "表达式必须包含算术或指针类型，但它具有类型 %t",
  "表达式必须包含算术、枚举或指针类型，但它具有类型 %t",
  "表达式必须包含算术、未区分范围的枚举或指针类型，但它具有类型 %t",
  "表达式必须包含指针类型，但它具有类型 %t",
  "运算符 -> 或 ->* 应用于 %t 而不是指针类型",
  "不允许使用不完整的类类型 %t",
  "无法解释此编译目标的位布局",
  "IFC 运算符 %sq 没有对应的运算符",
  "IFC 调用约定 %sq 没有相应的调用约定",
  "模块 %sq 包含不受支持的构造",
  "不支持的 IFC 构造: %sq",
  "__is_signed 不再是从此点开始的关键字",
  "数组维度必须具有常量无符号整数值",
  "IFC 文件 %sq 具有不受支持的版本 %d1。%d2",
  "此模式中没有启用模块",
  "模块名称中不允许使用 \"import\"",
  "模块名称中不允许使用 \"module\"",
  null,
  null,
  "%n 不是枚举类型",
  "枚举器 %no2 与 %n1 冲突",
  "枚举器 %no 已在此范围 %p 中进行声明",
  "\"throw()\" 规范不是 C++20 及更高版本的一部分",
  "标头单元映射中的多个条目与“%s”匹配",
  "#pragma 诊断必须具有 '推送' 或 'pop' 参数",
  "未找到 '#pragma 诊断推送' 匹配此 '诊断 pop'",
  "用于导出或模块指令时，%sq 不能是宏",
  "此指令只能出现在全局命名空间范围内",
  "'导出' 声明只能出现在全局或命名空间范围内",
  "将 %sq 分析为标识符而不是关键字，因为其后续标记与预处理器指令的标记不匹配",
  "这似乎只是预处理器指令的开始，但缺少后面紧跟换行符的 ';' 阻止了该指令",
  "这看起来是预处理指令的模块，但此类指令出现在宏扩展内。",
  "'模块' 指令不能出现在条件包含范围内(例如，#if、#else、#elseif 等)",
  "已跳过 %sq 导入",
  "承诺类型 %t 必须声明 get_return_object_on_allocation_failure 为不需要参数的静态成员函数",
  "别名模板不能显式专用化",
  "以匹配此“{”",
  "在此宏调用中",
  "调用需要不明确的参数转换",
  "模块 %s 拥有的声明与 %nd 冲突",
  "全局模块拥有的声明与命名模块拥有的 %nd 冲突",
  "“malloc”属性的第一个参数必须是函数",
  "无法捕获 %nod",
  "无法捕获“this”",
  "已在 consteval 上下文中",
  "'if consteval' 和 'if not consteval' 需要大括号从属语句",
  "'if consteval' 和 'if not consteval' 在非 constexpr 函数中无意义",
  "不允许将控制传输到 'if consteval' 或 'if not consteval' 语句",
  "常数计算无法通过具有静态或线程存储持续时间的变量的声明",
  "在具有显式 'this' 参数的 lambda 上，不允许使用可变限定符",
  "使用 'static' 声明的成员函数不能具有显式 'this' 参数",
  "显式 'this' 参数必须是第一个声明的参数",
  "此处不允许使用 'this'",
  "不能默认使用具有显式 'this' 的比较函数",
  "显式 'this' 函数需要选择器操作数",
  "在此模式下，'if consteval' 和 'if not consteval' 不标准",
  "在此模式下，在 lambda 声明符中省略 '()' 为不标准操作",
  "当省略 lambda 参数列表时，不允许使用尾随 Requires 子句",
  "已请求模块 %sq 无效分区",
  "已请求模块 %sq1 未定义分区(被认为是 %sq2)",
  "已请求模块 %sq1 文件位置 %d1 (相对位置 %d2),针对分区 %sq2 请求 - 为空",
  "已请求模块 %sq1 文件位置 %d1 (相对位置 %d2),针对分区 %sq2 请求 - 分区开始前",
  "已请求模块 %sq1 文件位置 %d1 (相对位置 %d2),针对分区 %sq2 请求 - 溢出其分区的末尾",
  "已请求模块 %sq1 文件位置 %d1 (相对位置 %d2)，针对分区 %sq2 - 与其分区元素不一致",
  "从子域 %sq (相对于节点 %d 的位置)",
  "从分区 %sq 元素 %d1 (文件位置 %d2，相对位置 %d3)",
  "lambda 属性在此处为非标准属性",
  "标识符 %sq 可能与显示 %p 的视觉上相似的标识符混淆",
  "此注释包含可疑的 Unicode 格式控制字符",
  "此字符串包含可能导致意外运行时行为的 Unicode 格式控制字符",
  "遇到 %d1 条已抑制警告(处理模块 %sq1 时)",
  "遇到 %d1 条已抑制警告(处理模块 %sq1 时)",
  "遇到 %d1 条已抑制错误(处理模块 %sq1 时)",
  "遇到 %d1 条已抑制错误(处理模块 %sq1 时)",
  "包括",
  "已抑制",
  "虚拟成员函数不能具有显式 'this' 参数",
  "获取显式 'this' 函数的地址需要限定名称",
  "形成显式 'this' 函数的地址需要 '&' 运算符",
  "字符串文本无法用于初始化灵活数组成员",
  "函数 %sq 定义的 IFC 表示形式无效",
  "已进行更正以删除隐式 “this” 参数",
  "未将 UniLevel IFC 图表用于指定参数",
  "%d1 参数由 IFC 参数定义图表指定，而 %d2 参数由 IFC 声明指定",
  "%d1 参数由 IFC 参数定义图表指定，而 %d2 参数由 IFC 声明指定",
  "%d1 参数由 IFC 参数定义图表指定，而 %d2 参数由 IFC 声明指定",
  "缺少函数 %sq 定义的 IFC 表示形式",
  "函数修饰符不适用于成员模板声明",
  "成员选择涉及太多嵌套的匿名类型",
  "操作数之间没有通用类型",
  "需要指向成员的指针",
  "不能在其他空类型中声明灵活数组成员",
  "应将“std::source_location::__impl”定义为仅包含数据成员“__M_function_name”、“_M_file_name”、“_M_column”、“_M_line”的类",
  "在初始化“std::source_location::__impl”期间，列号将溢出类型为 %t 的成员“_M_column”",
  "在初始化“std::source_location::__impl”期间，行号将溢出类型为 %t 的成员“_M_line”",
  "UTF-16 字符常量不能占用多个代码单元；值已截断",
  "两个参数的类型必须相同",
  "类型 %t 无效，不能用作此内置项的参数",
  "调用自 %nd:",
  "限定类型对于匿名位字段是非标准的",
  "向量条件的元素类型(%t1)的大小必须与结果的元素类型相同(%t2)",
  "浮点向量操作数类型(%t)没有匹配的整数向量类型",
  "尚未实现 “requires” 表达式的变量名压缩",
  "因为“不可用”属性",
  "已尝试使用索引将一个元素从 IFC 分区 %sq 构造到 IFC 分区 %sq",
  "分区 %sq 将其条目大小指定为 %d1，正确的大小为 %d2",
  "处理模块 %sq1 时遇到意外的 IFC 要求",
  "条件失败，行 %d，%s1: %sq2",
  "原子约束依赖于自身",
  "“noreturn”函数具有非 void 返回类型",
  "通过删除参数 %sq (在相对索引 %d 处)进行了更正",
  "实体重建期间遇到了无效的 IFC 标识符名称 %sq",
  "实体重建期间跳过了名为 %sq 的无效 IFC 标识符",
  "模块 %sq 排序值无效",
  "从 IFC 模块加载的函数模板被错误地分析为 %nd",
  "未能在模块 %sq 中加载 IFC 实体引用",
  "IFC 索引排序 = %d1，值 = %d2"
]