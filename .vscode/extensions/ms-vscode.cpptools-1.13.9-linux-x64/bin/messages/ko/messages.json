[
  "알 수 없는 오류입니다.",
  "파일의 마지막 줄이 줄 바꿈 없이 끝납니다.",
  "파일의 마지막 줄이 백슬래시로 끝납니다.",
  "#include 파일 %sq에 해당 파일 자체가 포함되어 있습니다.",
  "메모리가 부족합니다.",
  null,
  "주석이 파일 끝에서 닫히지 않았습니다.",
  "인식할 수 없는 토큰입니다.",
  "닫는 따옴표가 없습니다.",
  "주석은 중첩될 수 없습니다.",
  "'#'은 여기에 사용할 수 없습니다.",
  "인식할 수 없는 전처리 지시문입니다.",
  "이전에 구문 오류가 발생한 후 여기에서 구문 분석이 다시 시작됩니다.",
  "파일 이름이 필요합니다.",
  "전처리 지시문이 끝나야 하는데 필요 없는 텍스트가 있습니다.",
  null,
  null,
  "']'가 필요합니다.",
  "')'가 필요합니다.",
  "숫자가 끝나야 하는데 필요 없는 텍스트가 있습니다.",
  "식별자 %sq이(가) 정의되어 있지 않습니다.",
  "이 선언에서는 형식 한정자가 의미가 없습니다.",
  "잘못된 16진수입니다.",
  "정수 상수가 너무 큽니다.",
  "잘못된 8진수입니다.",
  "따옴표 붙은 문자열에는 적어도 하나의 문자가 있어야 합니다.",
  "문자 상수에 문자가 너무 많습니다.",
  "문자 값이 범위를 벗어났습니다.",
  "식에 상수 값이 있어야 합니다.",
  "식이 필요합니다.",
  "부동 소수점 상수가 범위를 벗어났습니다.",
  "식에 정수 계열 형식이 있어야 합니다.",
  "식에 산술 형식이 있어야 합니다.",
  "줄 번호가 필요합니다.",
  "잘못된 줄 번호입니다.",
  "#error 지시문: %s",
  "이 지시문에 대한 #if가 없습니다.",
  "이 지시문에 대한 #endif가 없습니다.",
  "지시문을 사용할 수 없습니다. #else가 이미 있습니다.",
  "0으로 나누었습니다.",
  "식별자가 필요합니다.",
  "식에 산술 또는 포인터 형식이 있어야 합니다.",
  "피연산자 형식이 호환되지 않습니다(%t1 및 %t2).",
  null,
  "식에 포인터 형식이 있어야 합니다.",
  "이 미리 정의된 이름에는 #undef를 사용할 수 없습니다.",
  "%no이(가) 미리 정의되어 있습니다. 재정의 시도가 무시되었습니다.",
  "%nod 매크로의 호환되지 않는 재정의",
  null,
  "중복된 매크로 매개 변수 이름",
  "'##'가 매크로 정의의 처음에 나타날 수 없습니다.",
  "'##'가 매크로 정의의 마지막에 나타날 수 없습니다.",
  "매크로 매개 변수 이름이 필요합니다.",
  "':'가 필요합니다.",
  "%n 호출의 인수가 너무 적습니다.",
  "%n 호출의 인수가 너무 많습니다.",
  "sizeof의 피연산자는 함수일 수 없습니다.",
  "상수 식에 this 연산자를 사용할 수 없습니다.",
  "전처리 식에 this 연산자를 사용할 수 없습니다.",
  "상수 식에 함수 호출을 사용할 수 없습니다.",
  "정수 계열 상수 식에 this 연산자를 사용할 수 없습니다.",
  "정수 연산 결과가 범위를 벗어났습니다.",
  "시프트 횟수가 음수입니다.",
  "시프트 횟수가 너무 큽니다.",
  "선언이 아무 것도 선언하지 않습니다.",
  "';'가 필요합니다.",
  "열거형 값이 'int' 범위를 벗어났습니다.",
  "'}'가 필요합니다.",
  "정수 변환으로 인해 부호가 변경되었습니다.",
  "정수 변환으로 인해 잘라내기 발생했습니다.",
  "불완전한 형식은 사용할 수 없습니다.",
  "sizeof의 피연산자는 비트 필드일 수 없습니다.",
  null,
  null,
  null,
  "'*'의 피연산자는 포인터여야 하는데 %t 형식이 있음",
  "매크로에 대한 인수가 비어 있습니다.",
  "이 선언에는 스토리지 클래스 또는 형식 지정자가 없습니다.",
  "매개 변수 선언은 이니셜라이저를 가질 수 없습니다.",
  "형식 지정자가 필요합니다.",
  "여기에 스토리지 클래스를 지정할 수 없습니다.",
  "두 개 이상의 스토리지 클래스를 지정할 수 없습니다.",
  "스토리지 클래스가 처음에 나타나지 않습니다.",
  "형식 한정자가 두 번 이상 지정되었습니다.",
  "형식 지정자의 조합이 잘못되었습니다.",
  "매개 변수의 스토리지 클래스가 잘못되었습니다.",
  "함수의 스토리지 클래스가 잘못되었습니다.",
  "여기에 형식 지정자를 사용할 수 없습니다.",
  "함수 배열을 사용할 수 없습니다.",
  "void 배열을 사용할 수 없습니다.",
  "함수를 반환하는 함수를 사용할 수 없습니다.",
  "배열을 반환하는 함수를 사용할 수 없습니다.",
  "식별자 목록 매개 변수는 함수 정의에서만 사용할 수 있습니다.",
  "typedef에서 함수 형식을 가져올 수 없습니다.",
  "배열 크기가 0보다 커야 합니다.",
  "배열이 너무 큽니다.",
  "변환 단위에 선언이 적어도 하나는 있어야 합니다.",
  "함수가 이 형식의 값을 반환할 수 없습니다.",
  "배열에 이 형식의 요소를 사용할 수 없습니다.",
  "여기서 선언이 매개 변수를 선언해야 합니다.",
  "매개 변수 이름이 중복되었습니다.",
  "현재 범위에 이미 %sq이(가) 선언되어 있습니다.",
  "열거형 형식의 정방향 선언이 표준이 아닙니다.",
  "클래스가 너무 큽니다.",
  "구조체 또는 공용 구조체가 너무 큽니다.",
  "비트 필드의 크기가 잘못되었습니다.",
  "비트 필드의 형식이 잘못되었습니다.",
  "길이가 0인 비트 필드는 이름이 없어야 합니다.",
  "길이가 1인 부호 있는 비트 필드",
  "명백한 호출의 괄호 앞에 오는 식에는 함수 (포인터) 형식이 있어야 합니다.",
  "정의 또는 태그 이름이 필요합니다.",
  "문에 접근할 수 없습니다.",
  "'while'이 필요합니다.",
  null,
  "%n이(가) 참조되었지만 정의되어 있지 않습니다.",
  "continue 문은 루프 내에서만 사용할 수 있습니다.",
  "break 문은 루프 또는 스위치 내에서만 사용할 수 있습니다.",
  "void가 아닌 %n은(는) 값을 반환해야 합니다.",
  "void 함수는 값을 반환할 수 없습니다.",
  "%t 형식으로 캐스트할 수 없습니다.",
  "반환 값 형식이 함수 형식과 일치하지 않습니다.",
  "case 레이블은 스위치 내에서만 사용할 수 있습니다.",
  "기본 레이블은 스위치 내에서만 사용할 수 있습니다.",
  null,
  "이 스위치에는 기본 레이블이 이미 있습니다.",
  "'('가 필요합니다.",
  "식이 lvalue여야 합니다.",
  "문이 필요합니다.",
  "루프에 접근할 수 없습니다.",
  "블록 범위 함수에는 외부 스토리지 클래스를 하나만 사용할 수 있습니다.",
  "'{'가 필요합니다.",
  "식에 클래스 포인터 형식이 있어야 하는데 %t 형식이 있음",
  "식에 구조체 포인터 또는 공용 구조체 포인터 형식이 있어야 하는데 %t 형식이 있음",
  "멤버 이름이 필요합니다.",
  "필드 이름이 필요합니다.",
  "%n에 %sq 멤버가 없습니다.",
  "%n에 %sq 필드가 없습니다.",
  "식이 수정할 수 있는 lvalue여야 합니다.",
  "레지스터 변수의 주소를 가져올 수 없습니다.",
  "비트 필드의 주소를 가져올 수 없습니다.",
  "함수 호출에 인수가 너무 많습니다.",
  "본문이 있는 경우 명명되지 않은 프로토타입 매개 변수를 사용할 수 없습니다.",
  "식에 개체 포인터 형식이 있어야 하는데 %t 형식이 있음",
  "프로그램이 너무 크거나 복잡하여 컴파일할 수 없습니다.",
  "%t1 형식의 값을 사용하여 %t2 형식의 엔터티를 초기화할 수 없습니다.",
  "%n을(를) 초기화할 수 없습니다.",
  "이니셜라이저 값이 너무 많습니다.",
  "선언이 %nfd과(와) 호환되지 않습니다.",
  "%n이(가) 이미 초기화되었습니다.",
  "전역 범위 선언에 이 스토리지 클래스를 사용할 수 없습니다.",
  "형식 이름을 매개 변수로 다시 선언할 수 없습니다.",
  "typedef 이름을 매개 변수로 다시 선언할 수 없습니다.",
  "0이 아닌 정수를 포인터로 변환",
  "식에 클래스 형식이 있어야 하는데 %t 형식이 있음",
  "식에 구조체 또는 공용 구조체 형식이 있어야 하는데 %t 형식이 있음",
  "더 이상 사용되지 않는 대입 연산자",
  "더 이상 사용되지 않는 이니셜라이저",
  "식은 정수 계열 상수 식이어야 합니다.",
  "식은 lvalue 또는 함수 지정자여야 합니다.",
  "선언이 이전 %nod과(와) 호환되지 않습니다.",
  "외부 이름이 %nd의 외부 이름과 충돌합니다.",
  "인식할 수 없는 #pragma",
  null,
  "임시 파일 %sq을(를) 열 수 없습니다. %s2",
  "임시 파일의 디렉터리 이름이 너무 깁니다(%sq).",
  "함수 호출에 인수가 너무 적습니다.",
  "부동 소수점 상수가 잘못되었습니다.",
  "%t1 형식의 인수가 %t2 형식의 매개 변수와 호환되지 않습니다.",
  "여기에는 함수 형식을 사용할 수 없습니다.",
  "선언이 필요합니다.",
  "포인터가 내부 개체를 벗어난 범위를 가리킵니다.",
  "잘못된 형식 변환입니다.",
  "외부/내부 연결이 이전 선언 %p과(와) 충돌함",
  "부동 소수점 값이 필요한 정수 계열 형식에 맞지 않습니다.",
  "의미 없는 식입니다.",
  "첨자가 범위를 벗어났습니다.",
  null,
  "%n이(가) 선언되었지만 참조되지 않습니다.",
  "배열에 적용된 '&'는 효과가 없습니다.",
  "'%%'의 오른쪽 피연산자는 0입니다.",
  "인수가 정식 매개 변수와 호환되지 않습니다.",
  "인수가 대응하는 서식 문자열 변환과 호환되지 않습니다.",
  "소스 파일 %sq을(를) 열 수 없습니다(검색 목록에 디렉터리 없음).",
  "캐스트 형식은 정수 계열이어야 합니다.",
  "캐스트 형식은 산술 또는 포인터여야 합니다.",
  "접근할 수 없는 코드의 동적 초기화",
  "부호 없는 정수와 0의 무의미한 비교",
  "'=='를 사용해야 하는 위치에 '='를 사용했습니다.",
  "열거 형식이 다른 형식과 혼합되었습니다.",
  "%s 파일을 쓰는 동안 오류가 발생했습니다.",
  "중간 언어 파일이 잘못되었습니다.",
  "캐스트 형식에는 형식 한정자가 의미가 없습니다.",
  "인식할 수 없는 문자 이스케이프 시퀀스입니다.",
  "정의되지 않은 전처리 식별자 %sq에 0을 사용했습니다.",
  "asm 문자열이 필요합니다.",
  "asm 함수는 프로토타입화되어야 합니다.",
  "asm 함수에 가변 매개 변수(...)를 사용할 수 없습니다.",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "%sq 파일을 삭제하는 동안 오류가 발생했습니다. %s2",
  "정수 계열 값이 필요한 부동 소수점 형식에 맞지 않습니다.",
  "부동 소수점 값이 필요한 부동 소수점 형식에 맞지 않습니다.",
  "부동 소수점 연산 결과가 범위를 벗어났습니다.",
  "%sq 함수가 암시적으로 선언되었습니다.",
  "서식 문자열에 추가 인수가 필요합니다.",
  "서식 문자열이 이 인수 앞에서 끝납니다.",
  "서식 문자열 변환이 잘못되었습니다.",
  "매크로 재귀",
  "후행 쉼표가 표준이 아닙니다.",
  "비트 필드에 열거 형식의 모든 값이 포함될 수 없습니다.",
  "비트 필드의 비표준 형식",
  "함수 외부에 선언이 보이지 않습니다.",
  "'void'에서 더 이상 사용되지 않는 typedef가 무시되었습니다.",
  "왼쪽 피연산자가 이 필드를 포함하는 구조체나 공용 구조체가 아닙니다.",
  "포인터가 이 필드를 포함하는 구조체 또는 공용 구조체를 가리키지 않습니다.",
  "변수 %sq이(가) 불완전한 형식으로 선언되었습니다.",
  "제어 식이 상수입니다.",
  "selector 식이 상수입니다.",
  "매개 변수의 지정자가 잘못되었습니다.",
  "클래스 선언을 벗어난 잘못된 지정자입니다.",
  "선언에서 지정자가 중복되었습니다.",
  "공용 구조체에 기본 클래스를 사용할 수 없습니다.",
  "제어 지정자에 여러 번 액세스할 수 없습니다.",
  "클래스 또는 구조체 정의가 없습니다.",
  "정규화된 이름이 %t 클래스 또는 해당 기본 클래스의 멤버가 아닙니다.",
  "비정적 멤버 참조는 특정 개체에 상대적이어야 합니다.",
  "비정적 데이터 멤버는 해당 클래스 외부에서 정의할 수 없습니다.",
  "%n이(가) 이미 정의되었습니다.",
  "참조에 대한 포인터를 사용할 수 없습니다.",
  "참조에 대한 참조를 사용할 수 없습니다.",
  "void에 대한 참조를 사용할 수 없습니다.",
  "참조 배열을 사용할 수 없습니다.",
  "참조 %n에 이니셜라이저가 필요합니다.",
  "','가 필요합니다.",
  "형식 이름을 사용할 수 없습니다.",
  "형식 정의를 사용할 수 없습니다.",
  "형식 이름 %nod의 재선언이 잘못되었습니다.",
  "상수 %n에 이니셜라이저가 필요합니다.",
  "'this'는 비정적 멤버 함수 내에서만 사용할 수 있습니다.",
  "상수 값을 알 수 없습니다.",
  "명시적 형식이 없습니다('int'로 간주됨).",
  "액세스 제어가 지정되어 있지 않습니다(기본적으로 %sq).",
  "클래스 또는 구조체 이름이 아닙니다.",
  "기본 클래스 이름이 중복되었습니다.",
  "기본 클래스가 잘못되었습니다.",
  "%nd에 액세스할 수 없습니다.",
  "%no이(가) 모호합니다.",
  "이전 스타일의 매개 변수 목록입니다(오래된 구문).",
  "블록에서 실행 가능 문 다음에 선언이 올 수 없습니다.",
  "액세스할 수 없는 기본 클래스 %t(으)로의 변환은 허용되지 않습니다.",
  null,
  null,
  null,
  null,
  "매크로 호출이 부적절하게 종료되었습니다.",
  null,
  "'::'가 뒤에 오는 이름은 클래스 또는 네임스페이스 이름이어야 합니다.",
  "friend 선언이 잘못되었습니다.",
  "생성자 또는 소멸자가 값을 반환할 수 없습니다.",
  "소멸자 선언이 잘못되었습니다.",
  "멤버 선언이 해당 클래스의 이름과 같습니다.",
  "전역 범위 한정자(선행 '::')를 사용할 수 없습니다.",
  "전역 범위에 %sq이(가) 없습니다.",
  "정규화된 이름은 사용할 수 없습니다.",
  "NULL 참조는 사용할 수 없습니다.",
  "%t 형식인 개체에 '{...}'를 사용한 초기화가 허용되지 않습니다.",
  "기본 클래스 %t이(가) 모호합니다.",
  "%t1 파생 클래스에 %t2 클래스의 인스턴스가 두 개 이상 있습니다.",
  "기본 클래스 %t2에 대한 포인터를 파생 클래스 %t1에 대한 포인터로 변환할 수 없습니다. 기본 클래스가 가상 클래스입니다.",
  "인수 목록이 일치하는 생성자 %no의 인스턴스가 없습니다.",
  "%t 클래스의 복사 생성자가 모호합니다.",
  "%t 클래스의 기본 생성자가 없습니다.",
  "%sq이(가) 비정적 데이터 멤버 또는 %t 클래스의 기본 클래스가 아닙니다.",
  "간접 비가상 기본 클래스를 사용할 수 없습니다.",
  "공용 구조체 멤버가 잘못되었습니다. %t 클래스에 사용할 수 없는 멤버 함수가 있습니다.",
  null,
  "lvalue가 아닌 배열을 잘못 사용했습니다.",
  "연산자가 필요합니다.",
  "상속된 멤버를 사용할 수 없습니다.",
  "%n의 인스턴스 중 사용할 인스턴스를 확인할 수 없습니다.",
  "바인딩된 함수에 대한 포인터는 함수를 호출하는 데에만 사용할 수 있습니다.",
  "typedef 이름이 동일한 형식으로 이미 선언되어 있습니다.",
  "%n이(가) 이미 정의되었습니다.",
  null,
  "인수 목록이 일치하는 %n의 인스턴스가 없습니다.",
  "함수 반환 형식 선언에는 형식 정의를 사용할 수 없습니다.",
  "기본 인수가 매개 변수 목록의 끝에 없습니다.",
  "기본 인수의 재정의",
  "%n의 인스턴스 중 두 개 이상이 인수 목록과 일치합니다.",
  "생성자 %no의 인스턴스 중 두 개 이상이 인수 목록과 일치합니다.",
  "%t1 형식의 기본 인수가 %t2 형식의 매개 변수와 호환되지 않습니다.",
  "반환 형식으로만 구분되는 함수를 오버로드할 수 없습니다.",
  "%t1에서 %t2(으)로의 사용자 정의 변환이 적절하지 않습니다.",
  null,
  "비정적 멤버 함수만 가상일 수 있습니다.",
  "개체에 멤버 함수와 호환되지 않는 형식 한정자가 있습니다.",
  "프로그램이 너무 커서 컴파일할 수 없습니다(가상 함수가 너무 많음).",
  "반환 형식이 재정의된 가상 함수 %no의 반환 형식 %t을(를) 가진 nor 공변(covariant)과 동일하지 않습니다.",
  "가상 %n의 재정의가 모호합니다.",
  "순수 지정자('= 0')는 가상 함수에서만 사용할 수 있습니다.",
  "잘못된 형식의 순수 지정자입니다('= 0'만 사용할 수 있음).",
  "데이터 멤버 이니셜라이저를 사용할 수 없습니다.",
  "추상 클래스 형식 %t의 개체를 사용할 수 없습니다.",
  "추상 클래스 %t을(를) 반환하는 함수를 사용할 수 없습니다.",
  "friend 선언이 중복되었습니다.",
  "인라인 지정자는 함수 선언에서만 사용할 수 있습니다.",
  "'inline'을 사용할 수 없습니다.",
  "인라인 함수의 스토리지 클래스가 잘못되었습니다.",
  "클래스 멤버의 스토리지 클래스가 잘못되었습니다.",
  "지역 클래스 멤버 %n에 정의가 필요합니다.",
  "%nfd에 액세스할 수 없습니다.",
  null,
  "%t 클래스에 const 개체를 복사할 복사 생성자가 없습니다.",
  "암시적으로 선언되는 멤버 함수 정의는 허용되지 않습니다.",
  "%t 클래스에 적절한 복사 생성자가 없습니다.",
  "연결 사양을 사용할 수 없습니다.",
  "알 수 없는 외부 연결 사양입니다.",
  "연결 사양이 이전 %nod과(와) 호환되지 않습니다.",
  "오버로드된 함수 %no의 인스턴스 중 두 개 이상에 'C' 연결이 있습니다.",
  "%t 클래스에 기본 생성자가 두 개 이상 있습니다.",
  "임시로 복사된 값이 임시로 사용된 값을 참조합니다.",
  "'operator%s'은(는) 멤버 함수여야 합니다.",
  "연산자는 정적 멤버 함수일 수 없습니다.",
  "사용자 정의 변환에 인수를 사용할 수 없습니다.",
  "이 연산자 함수에 매개 변수가 너무 많습니다.",
  "이 연산자 함수에 매개 변수가 너무 적습니다.",
  "비멤버 연산자에는 클래스 형식의 매개 변수가 필요합니다.",
  "기본 인수를 사용할 수 없습니다.",
  "%t1에서 %t2(으)로 적용되는 사용자 정의 변환이 두 개 이상입니다.",
  "이러한 피연산자와 일치하는 %sq 연산자가 없습니다.",
  "%sq 연산자 중 두 개 이상이 이 피연산자와 일치합니다.",
  "할당 함수의 첫 번째 매개 변수는 'size_t' 형식이어야 합니다.",
  "할당 함수에는 'void *' 반환 형식이 필요합니다.",
  "할당 해제 함수에는 'void' 반환 형식이 필요합니다.",
  "할당 해제 함수의 첫 번째 매개 변수는 'void *' 형식이어야 합니다.",
  null,
  "형식이 개체 형식이어야 합니다.",
  "기본 클래스 %t이(가) 이미 초기화되었습니다.",
  "기본 클래스 이름이 필요합니다. %t(으)로 간주됩니다(오래된 구문).",
  "%n이(가) 이미 초기화되었습니다.",
  "멤버 또는 기본 클래스의 이름이 없습니다.",
  "'this'에 대한 할당(오래된 구문)",
  "'overload' 키워드가 사용되었습니다(오래된 구문).",
  "잘못된 익명 공용 구조체 -- public이 아닌 멤버를 사용할 수 없습니다.",
  "잘못된 익명 공용 구조체 -- 멤버 함수를 사용할 수 없습니다.",
  "전역 또는 네임스페이스 범위의 익명 공용 구조체는 static으로 선언해야 합니다.",
  "%nf이(가) 다음에 대한 이니셜라이저를 제공하지 않습니다.",
  "%t 클래스에 대해 암시적으로 생성된 생성자가 다음을 초기화할 수 없습니다.",
  "%n이(가) 다음을 초기화하는 생성자를 정의하지 않습니다.",
  "%n에 초기화되지 않은 상수 또는 참조 멤버가 있습니다.",
  "%n에 초기화되지 않은 const 필드가 있습니다.",
  "%t 클래스에 const 개체를 복사하기 위한 대입 연산자가 없습니다.",
  "%t 클래스에 적절한 대입 연산자가 없습니다.",
  "%t 클래스의 모호한 대입 연산자",
  null,
  "선언에는 typedef 이름이 필요합니다.",
  null,
  "'virtual'을 사용할 수 없습니다.",
  "'static'을 사용할 수 없습니다.",
  "바인딩된 함수를 일반 함수 포인터로 캐스트합니다(오래된 구문).",
  "식에 멤버 포인터 형식이 있어야 합니다.",
  "불필요한 ';'가 무시되었습니다.",
  "비정적 멤버에 대한 in-class initializer가 표준이 아닙니다.",
  null,
  "인수 목록과 일치하는 오버로드된 %no의 인스턴스가 없습니다.",
  null,
  "%n 인스턴스 중 필요한 형식과 일치하는 인스턴스가 없습니다.",
  "delete array size 식이 사용되었습니다(오래된 구문).",
  null,
  "추상 클래스 %t(으)로의 캐스트는 사용할 수 없습니다:",
  "함수 'main'을 호출할 수 없거나 해당 주소를 가져올 수 없습니다.",
  "배열에 대해 새 이니셜라이저를 지정할 수 없습니다.",
  "멤버 함수 %no을(를) 해당 클래스 외부에서 다시 선언할 수 없습니다.",
  "불완전한 클래스 형식 %t에 대한 포인터는 사용할 수 없음",
  "바깥쪽 함수의 지역 변수에 대한 참조를 사용할 수 없습니다.",
  "후위 %sq에 단일 인수 함수가 사용되었습니다(오래된 구문).",
  null,
  "암시적으로 생성된 대입 연산자를 복사할 수 없습니다.",
  "배열 형식으로의 캐스트는 표준이 아닙니다(%t에 대한 캐스트로 처리됨).",
  "%n에 operator new%s()이(가) 있지만 기본 operator delete%s()이(가) 없습니다.",
  "%n에 기본 operator delete%s()이(가) 있지만 operator new%s()이(가) 없습니다.",
  "기본 클래스 %nod의 소멸자가 가상이 아닙니다.",
  null,
  "멤버 %npd의 재선언이 잘못되었습니다.",
  "함수 'main'을 인라인으로 선언할 수 없습니다.",
  "클래스와 이름이 같은 멤버 함수는 생성자여야 합니다.",
  "중첩된 %n을(를) 사용합니다(오래된 구문).",
  "소멸자에 매개 변수를 사용할 수 없습니다.",
  "%t 클래스의 복사 생성자에 %t 형식의 매개 변수를 사용할 수 없습니다.",
  "%n이(가) 불완전한 형식 %t을(를) 반환합니다.",
  "보호된 %nd에 %t 포인터나 개체를 통해 액세스할 수 없습니다.",
  "매개 변수를 사용할 수 없습니다.",
  "여기에는 'asm' 선언을 사용할 수 없습니다.",
  "%t1에서 %t2(으)로의 적절한 변환 함수가 없습니다.",
  "불완전한 클래스에 대한 포인터 삭제입니다.",
  "%t1에서 %t2(으)로 변환하기 위한 적절한 생성자가 없습니다.",
  "%t1에서 %t2(으)로 변환하기 위해 적용하는 생성자가 두 개 이상입니다.",
  "%t1에서 %t2(으)로 적용되는 변환 함수가 두 개 이상입니다.",
  "%t에서 기본 제공 형식으로 적용되는 변환 함수가 두 개 이상입니다.",
  "상수 %n",
  "참조 %n",
  "%npTd",
  "기본 제공 연산자 %sq",
  "%nod, 상속에 의해 모호함",
  "생성자 또는 소멸자가 해당 주소를 가져올 수 없습니다.",
  null,
  "비const 참조에 대한 초기 값으로 임시 사용(오래된 구문)",
  "정규화된 이름은 멤버 선언에 사용할 수 없습니다.",
  "열거 형식이 다른 형식과 혼합되었습니다(오래된 구문).",
  "'new'의 배열 크기는 음수가 아니어야 합니다.",
  "로컬 임시 메모리에 대한 참조를 반환합니다.",
  null,
  "'enum' 선언을 사용할 수 없습니다.",
  "%t1 형식에서 %t2 형식 이니셜라이저로의 바인딩 참조에서 한정자가 삭제되었습니다.",
  "%t1 형식(const 한정 형식 아님)의 참조를 %t2 형식의 값으로 초기화할 수 없습니다.",
  "함수 포인터를 삭제할 수 없습니다.",
  "변환 함수는 비정적 멤버 함수여야 합니다.",
  "여기에는 템플릿 선언을 사용할 수 없습니다.",
  "'<'가 필요합니다.",
  "'>'가 필요합니다.",
  "템플릿 매개 변수 선언이 없습니다.",
  "%nf에 대한 인수 목록이 없습니다.",
  "%nf에 대한 인수가 너무 적습니다.",
  "%nf에 대한 인수가 너무 많습니다.",
  null,
  "%n1이(가) %n2의 매개 변수 형식을 선언하는 데 사용되지 않습니다.",
  "중첩 형식 두 개, %no1 및 %nod2의 이름이 같습니다(cfront 호환성).",
  "전역 %no1이(가) 중첩 %nod2 다음에 선언되었습니다(cfront 호환성).",
  null,
  "%n의 인스턴스 중 두 개 이상이 필요한 형식과 일치합니다.",
  "'long long' 형식은 표준이 아닙니다.",
  "%sq 생략은 표준이 아닙니다.",
  "변환 함수에 반환 형식을 지정할 수 없습니다.",
  "다음 중 검색:",
  "%nt %p 인스턴스화",
  "%nt %p의 암시적 생성",
  "%n의 인스턴스화에서 불필요한 재귀가 발생합니다.",
  "%sq이(가) 함수 또는 정적 데이터 멤버가 아닙니다.",
  "%t1 형식의 인수가 %t2 형식의 템플릿 매개 변수와 호환되지 않습니다.",
  "임시 사용 형식이나 변환이 필요한 초기화는 사용할 수 없습니다.",
  "%sq 선언에서 함수 매개 변수를 숨깁니다.",
  "비const 참조에 대한 초기 값은 lvalue여야 합니다.",
  "%nt %p의 암시적 정의",
  "'template'을 사용할 수 없습니다.",
  "%t이(가) 클래스 템플릿이 아닙니다.",
  null,
  "'main'은 함수 템플릿에 유효한 이름이 아닙니다.",
  "%n에 대한 참조가 잘못되었습니다(공용 구조체/비공용 구조체 불일치).",
  "템플릿 인수가 지역 형식을 참조할 수 없습니다.",
  "%s 종류의 태그는 %nfd 선언과 호환되지 않습니다.",
  "전역 범위에 이름이 %sq인 태그가 없습니다.",
  "%n에 이름이 %sq인 태그 멤버가 없습니다.",
  "멤버 함수 typedef(cfront 호환성을 위해 사용됨)",
  "%n은(는) 멤버 포인터 선언에서만 사용할 수 있습니다.",
  null,
  "템플릿 인수는 비외부 엔터티를 참조할 수 없습니다.",
  "다음에 '::~'이 있는 이름은 클래스 이름이거나 형식 이름이어야 합니다.",
  null,
  "소멸자 이름으로 사용된 형식이 %t 형식과 일치하지 않습니다.",
  "%n이(가) 호출된 후에 'inline'을 다시 선언했습니다.",
  null,
  "템플릿 선언의 스토리지 클래스가 잘못되었습니다.",
  "%nd이(가) 액세스할 수 없는 형식입니다(cfront 호환성을 위해 사용됨).",
  null,
  "명시적 인스턴스화 선언이 잘못되었습니다.",
  "%nf은(는) 인스턴스화할 수 있는 엔터티가 아닙니다.",
  "컴파일러 생성 %n은(는) 명시적으로 인스턴스화할 수 없습니다.",
  "인라인 %n은(는) 명시적으로 인스턴스화할 수 없습니다.",
  null,
  "%n을(를) 인스턴스화할 수 없습니다. 제공된 템플릿 정의가 없습니다.",
  "%n을(를) 인스턴스화할 수 없습니다. 명시적으로 특수화되었습니다.",
  null,
  null,
  "%n의 인스턴스 중 지정된 형식과 일치하는 인스턴스가 없습니다.",
  "typedef가 포함된 void 매개 변수 목록 선언은 표준이 아닙니다.",
  "전역 %n1이(가) %n2 대신 사용되었습니다(cfront 호환성).",
  "이 범위에서 템플릿 매개 변수 %sq을(를) 다시 선언할 수 없습니다.",
  "%sq 선언에서 템플릿 매개 변수를 숨깁니다.",
  "템플릿 인수 목록은 매개 변수 목록과 일치해야 합니다.",
  null,
  "후위 'operator%s'의 추가 매개 변수는 'int' 형식이어야 합니다.",
  "연산자 이름을 함수로 선언해야 합니다.",
  "연산자 이름을 사용할 수 없습니다.",
  "현재 범위에서 %n을(를) 특수화할 수 없습니다.",
  "멤버 함수의 주소를 가져오는 형식이 표준이 아닙니다.",
  "너무 적은 템플릿 매개 변수 -- %p(으)로 선언된 이전 선언과 일치하지 않습니다.",
  "너무 많은 템플릿 매개 변수 -- %p(으)로 선언된 이전 선언과 일치하지 않습니다.",
  "operator delete(void *)에 대한 함수 템플릿을 사용할 수 없습니다.",
  "클래스 템플릿과 템플릿 매개 변수에 같은 이름을 사용할 수 없습니다.",
  null,
  "템플릿 인수는 명명되지 않은 형식을 참조할 수 없습니다.",
  "열거 형식에 대한 이 작업에는 적용 가능한 사용자 정의 연산자 함수가 필요합니다.",
  "참조 형식에 대한 형식 한정자를 사용할 수 없습니다.",
  "%t1 형식의 값을 %t2 형식의 엔터티에 할당할 수 없습니다.",
  "부호 없는 정수와 음수 상수의 무의미한 비교입니다.",
  "불완전한 클래스 %t(으)로 변환할 수 없습니다.",
  "const 개체에는 이니셜라이저가 필요합니다.",
  "개체에 초기화되지 않은 상수나 참조 멤버가 있습니다.",
  "비표준 전처리 지시문",
  "%n에 템플릿 인수 목록을 사용할 수 없습니다.",
  "집계 개체에는 '{...}'를 사용한 초기화가 필요합니다.",
  "멤버 포인터 선택 클래스 형식이 호환되지 않습니다(%t1 및 %t2).",
  "무의미한 friend 선언",
  "'::' 대신 '.'를 사용하여 정규화된 이름을 형성합니다.",
  "const 개체에 대해 비const 함수를 호출했습니다(오래된 구문).",
  "종속 문이 선언일 수 없습니다.",
  "매개 변수에 void 형식을 사용할 수 없습니다.",
  "%na %p의 인스턴스화",
  "%na %p의 템플릿 인수 목록을 처리합니다.",
  "이 연산자는 템플릿 인수 식에 사용할 수 없습니다.",
  "try 블록에는 최소한 하나 이상의 처리기가 필요합니다.",
  "처리기에는 예외 선언이 필요합니다.",
  "처리기가 기본 처리기로 마스킹됩니다.",
  "처리기가 %t 형식에 대한 이전 처리기로 잠재적으로 마스킹됩니다.",
  "지역 형식을 사용하여 예외를 지정합니다.",
  "예외 사양의 형식이 중복되었습니다.",
  "예외 사양이 이전 %nd%s의 예외 사양과 호환되지 않습니다.",
  "이전에 지정됨: 예외가 throw되지 않습니다.",
  "이전에 생략됨: %t",
  "이전에 지정했지만 여기서는 생략됨: %t",
  "예외 처리에 대한 지원이 비활성화되어 있습니다.",
  "모든 예외 허용이 이전 %nd과(와) 호환되지 않습니다.",
  "인스턴스화 요청 파일 %sq을(를) 만들 수 없습니다.",
  "비형식 템플릿 인수에서 비산술 연산을 사용할 수 없습니다.",
  "지역 형식을 사용하여 비지역 변수를 선언합니다.",
  "지역 형식을 사용하여 함수를 선언합니다.",
  "컨트롤 전송으로 다음 초기화를 건너뜀:",
  "%nd",
  "예외 처리기로 컨트롤 전송",
  "%n이(가) 값이 설정되기 전에 사용되었습니다.",
  "%n이(가) 설정되었지만 사용되지 않습니다.",
  "현재 범위에서 %n을(를) 정의할 수 없습니다.",
  "예외 사양이 허용되지 않습니다.",
  "%nfd에 대해 외부/내부 연결이 충돌합니다.",
  "%nf은(는) 암시적 또는 명시적 변환에 대해 호출되지 않습니다.",
  "%s 종류의 태그는 %t 형식의 템플릿 매개 변수와 호환되지 않습니다.",
  "operator new(size_t)에 대한 함수 템플릿을 사용할 수 없습니다.",
  null,
  "%t 형식의 멤버 포인터를 사용할 수 없습니다.",
  "가변 매개 변수(...)는 연산자 함수 매개 변수 목록에 사용할 수 없습니다.",
  "%no은(는) 차후에 키워드로 사용하기 위해 예약되었습니다.",
  "잘못된 매크로 정의: %s",
  "잘못된 매크로 미정의: %s",
  null,
  null,
  "입력이 다음과 같은 경우 IL 파일 이름을 지정해야 합니다. ",
  null,
  null,
  null,
  null,
  "디버그 옵션 인수의 오류입니다.",
  "잘못된 옵션: %s",
  "백 엔드에 IL 파일의 이름이 필요합니다.",
  "IL 파일 %s을(를) 열 수 없습니다.",
  "잘못된 번호: %s",
  "잘못된 호스트 CPU ID",
  "잘못된 인스턴스화 모드: %s",
  null,
  "잘못된 오류 제한: %s",
  null,
  null,
  null,
  null,
  null,
  null,
  "가상 함수 테이블은 C++를 컴파일할 경우에만 표시하지 않을 수 있습니다.",
  "오래된 구문 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "인스턴스화 모드 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "자동 인스턴스화 모드는 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "암시적 템플릿 포함 모드는 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "예외 처리 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "strict 모드가 KR 모드와 호환되지 않습니다(&R).",
  "strict 모드가 cfront 모드와 호환되지 않습니다.",
  "소스 파일 이름이 없습니다.",
  "여러 개의 입력 파일을 컴파일할 경우 출력 파일을 지정할 수 없습니다.",
  "명령줄에 인수가 너무 많습니다.",
  "출력 파일이 지정되었지만 필요하지 않습니다.",
  "IL 표시에 IL 파일의 이름이 필요합니다.",
  "템플릿 매개 변수에는 void 형식을 사용할 수 없습니다.",
  "instantiate-all 모드로 인해 %n의 불필요한 재귀 인스턴스화가 발생합니다.",
  "strict 모드가 허용되는 오래된 구문과 호환되지 않습니다.",
  "throw 식에 void 형식을 사용할 수 없습니다.",
  "로컬 인스턴스화 모드는 자동 인스턴스화와 호환되지 않습니다.",
  "추상 클래스 형식 %t의 매개 변수를 사용할 수 없습니다.",
  "추상 클래스 %t의 배열을 사용할 수 없습니다.",
  "부동 소수점 템플릿 매개 변수가 표준이 아닙니다.",
  "이 pragma는 선언 바로 앞에 와야 합니다.",
  "이 pragma는 문 바로 앞에 와야 합니다.",
  "이 pragma는 선언 또는 문 바로 앞에 와야 합니다.",
  "여기에는 이러한 종류의 pragma를 사용할 수 없습니다.",
  null,
  "오버로드된 가상 함수 %no1이(가) %n2에서 일부만 재정의됩니다.",
  "인라인 템플릿 함수를 처음 사용하기 전에 구체적인 정의가 먼저 나와야 합니다.",
  "진단 제어 옵션의 잘못된 오류 태그: %s",
  "진단 제어 옵션의 잘못된 오류 번호: %s",
  null,
  null,
  "함수 포인터에 대한 멤버 포인터 함수 캐스트입니다.",
  "구조체 또는 공용 구조체가 명명된 멤버를 선언하지 않습니다.",
  "명명되지 않은 비표준 필드",
  "명명되지 않은 비표준 멤버",
  null,
  null,
  null,
  "%sq은(는) 형식 이름이 아닙니다.",
  "미리 컴파일된 헤더 입력 파일 %sq을(를) 열 수 없습니다. %s2",
  "미리 컴파일된 헤더 파일 %sq이(가) 잘못되었거나 이 버전의 컴파일로 생성되지 않았습니다.",
  "미리 컴파일된 헤더 파일 %sq이(가) 이 디렉터리에 생성되지 않았습니다.",
  "미리 컴파일된 헤더 파일 %sq을(를) 생성하는 데 사용된 헤더 파일이 변경되었습니다.",
  "명령줄 옵션이 미리 컴파일된 헤더 파일 %sq을(를) 생성할 때 사용한 옵션과 일치하지 않습니다.",
  "전처리 지시문의 초기 시퀀스가 미리 컴파일된 헤더 파일 %sq의 시퀀스와 호환되지 않습니다.",
  "매핑된 메모리를 가져올 수 없습니다.",
  "'%s': 미리 컴파일된 헤더 파일 '%s'을(를) 사용합니다.",
  "'%s': 미리 컴파일된 헤더 파일 '%s'을(를) 만듭니다.",
  "메모리 사용량이 미리 컴파일된 헤더 파일 %sq과(와) 충돌합니다.",
  "잘못된 PCH 메모리 크기: %s ",
  "PCH 옵션은 명령줄에서 맨 앞에 표시되어야 합니다.",
  "PCH 메모리 할당에 사용할 메모리가 부족합니다.",
  "여러 개의 입력 파일을 컴파일할 경우 미리 컴파일된 헤더 파일을 사용할 수 없습니다.",
  "미리 컴파일된 헤더 파일을 생성하기 위해 미리 할당된 메모리가 부족합니다(%s바이트 필요함).",
  "프로그램에 매우 큰 엔터티가 있어 미리 컴파일된 헤더 파일을 생성할 수 없습니다.",
  "%sq은(는) 유효한 디렉터리가 아닙니다.",
  "임시 파일 이름을 작성할 수 없습니다.",
  "'restrict'를 사용할 수 없습니다.",
  "함수 형식에 대한 포인터 또는 참조가 'restrict'로 한정될 수 없습니다.",
  null,
  "여기에서 호출 규칙 한정자를 지정할 수 없습니다.",
  "호출 규칙 한정자가 충돌합니다.",
  "strict 모드가 Microsoft 모드와 호환되지 않습니다.",
  "cfront 모드가 Microsoft 모드와 호환되지 않습니다.",
  "여기에 지정된 호출 규칙이 무시됩니다.",
  "호출 규칙 다음에 중첩된 선언자가 올 수 없습니다.",
  "이 형식에 대해 호출 규칙이 무시됩니다.",
  null,
  "선언 한정자가 이전 선언과 호환되지 않습니다.",
  "한정자 %sq은(는) 이 선언에 사용할 수 없습니다.",
  "try 블록으로 컨트롤 전송",
  "인라인 사양이 이전 %nod과(와) 호환되지 않습니다.",
  "템플릿 정의의 닫는 중괄호를 찾을 수 없습니다.",
  "wchar_t 키워드 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "압축 맞춤 값이 잘못되었습니다.",
  "정수 상수가 필요합니다.",
  "순수 가상 함수 호출입니다.",
  "소스 파일 식별자 문자열이 잘못되었습니다.",
  "friend 선언에서 클래스 템플릿을 정의할 수 없습니다.",
  "'asm'을 사용할 수 없습니다.",
  "'asm'은 함수 정의와 함께 사용해야 합니다.",
  "'asm' 함수는 표준이 아닙니다.",
  "명시적 매개 변수가 없는 가변 매개 변수(...)는 표준이 아닙니다.",
  "'&...'은 표준이 아닙니다.",
  "'&...'을 잘못 사용했습니다.",
  null,
  "const volatile 참조에 대한 초기 값으로 임시 사용(오래된 구문)",
  "%t1 형식의 참조를 %t2 형식의 값으로 초기화할 수 없습니다.",
  "const volatile 참조에 대한 초기 값은 lvalue여야 합니다.",
  "SVR4 C 호환성 옵션은 ANSI C를 컴파일할 경우에만 사용할 수 있습니다.",
  "범위를 벗어난 %nd 선언을 사용합니다.",
  "strict 모드가 SVR4 C 모드와 호환되지 않습니다.",
  "%nd 호출은 인라인될 수 없습니다.",
  "%n은(는) 인라인될 수 없습니다.",
  "잘못된 PCH 디렉터리: %s",
  "__except 또는 __finally가 필요합니다.",
  "__leave 문은 __try 내에서만 사용할 수 있습니다.",
  "%nt %p의 인스턴스화 중에 검색되었습니다.",
  "%nt %p의 암시적 생성 중에 검색되었습니다.",
  "%na %p의 인스턴스화 중에 검색되었습니다.",
  "%na %p의 템플릿 인수 목록 처리 중에 검색되었습니다.",
  "%nt %p의 암시적 정의 중에 검색되었습니다.",
  "압축 맞춤 스택에서 %sq을(를) 찾을 수 없습니다.",
  "압축 맞춤 스택이 비어 있습니다.",
  "RTTI 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "제거된 복사에 필요한 %nfd에 액세스할 수 없습니다.",
  "참조 매개 변수를 rvalue에 바인딩할 수 없기 때문에 제거된 복사에 필요한 %nf을(를) 호출할 수 없습니다.",
  "typeid를 사용하려면 <typeinfo>가 포함되어야 합니다.",
  "%s을(를) const 또는 다른 형식 한정자로 캐스트할 수 없습니다.",
  "dynamic_cast에 포함되는 형식은 완전한 클래스 형식에 대한 포인터 또는 참조이거나 void *이어야 합니다.",
  "포인터 dynamic_cast의 피연산자는 완전한 클래스 형식에 대한 포인터여야 합니다.",
  "참조 dynamic_cast의 피연산자는 완전한 클래스 형식의 lvalue여야 합니다.",
  "런타임 dynamic_cast의 피연산자는 다형 클래스 형식이어야 합니다.",
  "bool 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  null,
  "여기에는 배열 형식을 사용할 수 없습니다.",
  "'='가 필요합니다.",
  null,
  "조건에 선언된 %sq을(를) 이 범위에서 다시 선언할 수 없습니다.",
  "함수 템플릿에 대해 기본 템플릿 인수를 사용할 수 없습니다.",
  "',' 또는 '>'가 필요합니다.",
  "템플릿 매개 변수 목록이 필요합니다.",
  "bool 값 증분은 더 이상 사용되지 않습니다.",
  "bool 형식을 사용할 수 없습니다.",
  "%no2 클래스 내에서 기본 클래스 %no1의 오프셋이 너무 큽니다.",
  "식에 bool 형식(또는 bool로 변환할 수 있는 형식)이 있어야 합니다.",
  "배열 new 및 delete 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "%n이(가) 변수 이름이 아닙니다.",
  "여기에는 __based 한정자를 사용할 수 없습니다.",
  "__based는 포인터 연산자 앞에 오지 않습니다. __based가 무시되었습니다.",
  "__based 한정자의 변수는 포인터 형식이어야 합니다.",
  "const_cast의 형식은 개체 형식에 대한 포인터, 참조 또는 멤버 포인터여야 합니다.",
  "const_cast는 형식 한정자만 조정할 수 있으며 내부 형식을 변경하지 못합니다.",
  "mutable을 사용할 수 없습니다.",
  "%n의 재선언은 해당 액세스를 변경하는 데 사용할 수 없습니다.",
  null,
  "대체 토큰 '<:'은 의도치 않게 사용한 것으로 보입니다.",
  "대체 토큰 '%%:'의 의도하지 않은 사용으로 보입니다.",
  "네임스페이스 정의를 사용할 수 없습니다.",
  "이름은 네임스페이스 이름이어야 합니다.",
  "네임스페이스 별칭 정의를 사용할 수 없습니다.",
  "네임스페이스로 정규화된 이름이 필요합니다.",
  "네임스페이스 이름을 사용할 수 없습니다.",
  "DLL 특성 조합이 잘못되었습니다.",
  "%n이(가) 클래스 템플릿이 아닙니다.",
  "불완전한 요소 형식이 있는 배열은 표준이 아닙니다.",
  "네임스페이스에 할당 연산자를 선언할 수 없습니다.",
  "네임스페이스에 할당 해제 연산자를 선언할 수 없습니다.",
  "%np1이(가) %np2의 using 선언과 충돌합니다.",
  "%np1의 using 선언이 %npd2과(와) 충돌합니다.",
  "네임스페이스 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "현재 네임스페이스를 참조하기 때문에 using 선언이 무시되었습니다.",
  "클래스로 정규화된 이름이 필요합니다.",
  "인수 형식이 (%s)입니다.",
  "피연산자 형식이 %s입니다.",
  null,
  "%n에 실제 멤버 %sq이(가) 없습니다.",
  null,
  "호환되지 않는 메모리 특성이 지정되었습니다.",
  "메모리 특성이 무시되었습니다.",
  "메모리 특성 다음에 중첩된 선언자가 올 수 없습니다.",
  "메모리 특성이 두 번 이상 지정되었습니다.",
  "호출 규칙이 두 번 이상 지정되었습니다.",
  "형식 한정자를 사용할 수 없습니다.",
  "%npd1이(가) 해당 템플릿이 선언되기 전에 사용되었습니다.",
  "매개 변수 형식이 같은 정적 및 비정적 멤버 함수는 오버로드할 수 없습니다.",
  "%np의 이전 선언이 없습니다.",
  "템플릿 ID를 사용할 수 없습니다.",
  "클래스로 정규화된 이름을 사용할 수 없습니다.",
  "현재 범위에서 %n을(를) 다시 선언할 수 없습니다.",
  "정규화된 이름은 네임스페이스 멤버 선언에 사용할 수 없습니다.",
  "%n은(는) 형식 이름이 아닙니다.",
  "현재 범위에서 명시적 인스턴스화를 사용할 수 없습니다.",
  "현재 범위에서 %n을(를) 명시적으로 인스턴스화할 수 없습니다.",
  "%n을(를) 두 번 이상 명시적으로 인스턴스화했습니다.",
  "형식 이름은 템플릿 내에서만 사용할 수 있습니다.",
  "special_subscript_cost 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "형식 이름 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "암시적 형식 이름 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "개체 형식의 매크로 정의 시작 부분에 비표준 문자가 있습니다.",
  "가상 %n1에 대한 예외 사양이 재정의된 %n2의 사양과 호환되지 않습니다.",
  "포인터에서 더 작은 정수로의 변환",
  "암시적으로 선언된 가상 %n1에 대한 예외 사양이 재정의된 %n2의 사양과 호환되지 않습니다.",
  "%no1이(가) %np2에서 암시적으로 호출되어 모호합니다.",
  "'explicit' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'explicit'를 사용할 수 없습니다.",
  "선언이 %sq과(와) 충돌합니다(예약된 클래스 이름).",
  "'()'만 배열 %n의 이니셜라이저로 사용될 수 있습니다.",
  "'virtual'은 함수 템플릿 선언에 사용할 수 없습니다.",
  "잘못된 익명 공용 구조체 -- 클래스 멤버 템플릿을 사용할 수 없습니다.",
  "템플릿 중첩 한도가 %n의 이전 선언과 일치하지 않습니다.",
  "이 선언에는 'template <...>' 절 여러 개를 사용할 수 없습니다.",
  "for 초기화 범위를 제어하는 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "for 루프 초기화에 선언된 %sq을(를) 이 범위에서 다시 선언할 수 없습니다.",
  "%nd1에 대한 참조입니다. 이전 for 초기화 범위 규칙에서는 %nd2이(가) 될 수 있습니다.",
  "for 초기화 차이에 대한 경고를 제어하는 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "여기에는 가상 %n의 정의가 필요합니다.",
  "비어 있는 주석은 토큰 붙여넣기 연산자 '##'으로 해석됩니다.",
  "friend 선언에서 스토리지 클래스를 사용할 수 없습니다.",
  "이 선언에서 %no에 대한 템플릿 매개 변수 목록을 사용할 수 없습니다.",
  "%n이(가) 유효한 클래스 멤버 템플릿이 아닙니다.",
  "유효한 멤버 클래스 또는 함수 템플릿 선언이 아닙니다.",
  "템플릿 매개 변수 목록을 포함하는 템플릿 선언 다음에 명시적 특수화 선언이 올 수 없습니다.",
  "%n1의 명시적 특수화는 %n2을(를) 처음 사용하기 전에 나타나야 합니다.",
  "현재 범위에서 명시적 특수화를 사용할 수 없습니다.",
  "%n의 부분 특수화를 사용할 수 없습니다.",
  "%nf은(는) 명시적으로 특수화할 수 있는 엔터티가 아닙니다.",
  "%n의 명시적 특수화는 처음 사용하기 전에 나타나야 합니다.",
  "상세 형식 지정자에서 템플릿 매개 변수 %sq을(를) 사용할 수 없습니다.",
  "%n을(를) 특수화하려면 'template<>' 구문이 필요합니다.",
  null,
  null,
  "'old_specializations' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'template<>' 구문 없이 %n을(를) 특수화하는 것은 표준이 아닙니다",
  "이 선언에 외부 'C' 연결을 사용할 수 없습니다.",
  "%sq이(가) 현재 범위의 클래스 또는 함수 템플릿 이름이 아닙니다.",
  "참조되지 않은 함수 템플릿을 다시 선언할 때 기본 인수를 지정하는 것은 표준이 아닙니다.",
  "이미 참조된 함수 템플릿을 다시 선언할 때 기본 인수를 지정할 수 없습니다.",
  "기본 클래스 %t2의 멤버 포인터를 파생 클래스 %t1의 멤버 포인터로 변환할 수 없습니다. 기본 클래스가 가상입니다.",
  "예외 사양이 %nd%s의 예외 사양과 호환되지 않습니다.",
  "모든 예외 허용이 %nd과(와) 호환되지 않습니다.",
  "기본 인수 식의 예기치 않은 끝이 나타났습니다.",
  "참조의 기본 초기화를 사용할 수 없습니다.",
  "초기화되지 않은 %n에 const 멤버가 있습니다.",
  "초기화되지 않은 기본 클래스 %t에 const 멤버가 있습니다.",
  "const %n에 이니셜라이저가 필요합니다. %t 클래스에 사용자가 제공한 기본 생성자가 없습니다.",
  "const 개체에 이니셜라이저가 필요합니다. %t 클래스에 사용자가 제공한 기본 생성자가 없습니다.",
  "'implicit_extern_c_type_conversion' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "strict 모드가 long 보존 규칙과 호환되지 않습니다",
  "반환 형식에 대한 형식 한정자가 의미가 없습니다.",
  "함수 정의에서 'void' 반환 형식에 대한 형식 한정자를 사용할 수 없습니다.",
  "이 클래스에 정적 데이터 멤버 선언을 사용할 수 없습니다.",
  "템플릿 인스턴스화에서 잘못된 함수 선언이 발생했습니다.",
  "'...'을 사용할 수 없습니다.",
  "'extern_inline' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "extern 인라인 %n이(가) 참조되지만 정의되지 않았습니다.",
  "%t 형식에 대한 소멸자 이름이 잘못되었습니다.",
  null,
  "소멸자 참조가 모호합니다. %n1 및 %n2을(를) 모두 사용할 수 있습니다.",
  "가상 인라인 %n이(가) 정의되지 않았습니다.",
  "%n이(가) 참조되지 않습니다.",
  "공용 구조체의 멤버 중 하나만 생성자 이니셜라이저 목록에 지정할 수 있습니다.",
  "'new[]' 및 'delete[]'에 대한 지원이 비활성화되어 있습니다.",
  "생성된 C 코드에서 'long double' 대신 'double'이 사용됩니다.",
  "%n에 대응하는 operator delete%s이(가)가 없습니다(할당된 개체의 초기화 중에 예외가 throw되는 경우 호출됨).",
  "placement delete에 대한 지원이 비활성화되어 있습니다.",
  "적절한 operator delete가 표시되지 않습니다.",
  "불완전한 형식에 대한 포인터 또는 참조를 사용할 수 없습니다.",
  "잘못된 부분 특수화 -- %n이(가) 이미 완전하게 특수화되었습니다.",
  "호환되지 않는 예외 사양",
  "지역 변수에 대한 참조를 반환합니다.",
  "명시적 형식의 생략은 표준이 아닙니다('int'로 간주됨).",
  "두 개 이상의 부분 특수화가 %n의 템플릿 인수 목록과 일치합니다.",
  "%nod",
  "기본 템플릿의 선언에서 템플릿 인수 목록을 사용할 수 없습니다.",
  "부분 특수화에 기본 템플릿 인수를 사용할 수 없습니다.",
  "%n1이(가) 사용되지 않았거나 %n2의 템플릿 인수 목록에서 추론할 수 없습니다.",
  null,
  "부분 특수화의 템플릿 인수 목록에 형식이 템플릿 매개 변수에 종속된 비형식 인수가 포함됩니다.",
  "이 부분 특수화를 %n을(를) 인스턴스화하는 데 사용할 수 있습니다.",
  "이 부분 특수화가 %n의 인스턴스화를 모호하게 만들 수 있습니다.",
  "식에 정수 계열 형식이나 열거형 형식이 있어야 합니다.",
  "식에 산술 형식이나 열거형 형식이 있어야 합니다.",
  "식에 산술, 열거형 또는 포인터 형식이 있어야 합니다.",
  "캐스트 형식이 정수 계열이나 열거형이어야 합니다.",
  "캐스트 형식이 산술, 열거형 또는 포인터여야 합니다.",
  "식이 완전한 개체 형식에 대한 포인터여야 합니다.",
  null,
  "부분 특수화 비형식 인수가 비형식 매개 변수 또는 상수의 이름이어야 합니다.",
  "반환 형식이 재정의된 가상 함수 %no의 반환 형식 %t과(와) 동일하지 않습니다.",
  "'guiding_decls' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "클래스 템플릿의 부분 특수화는 해당 템플릿이 멤버인 네임스페이스에서 선언되어야 합니다.",
  "%n은(는) 순수 가상 함수입니다.",
  "순수 가상 %n에 재정의자가 없습니다.",
  "__declspec 특성이 무시되었습니다.",
  "입력 줄에 잘못된 문자가 있습니다.",
  "함수가 불완전한 형식 %t을(를) 반환합니다.",
  "이 '#pragma pack' 지시문의 효과가 %n에 로컬입니다.",
  "%s이(가) 템플릿이 아닙니다.",
  "friend 선언은 부분 특수화를 선언할 수 없습니다.",
  "예외 사양이 무시되었습니다.",
  "'size_t'의 선언이 필요한 형식 %t과(와) 일치하지 않습니다.",
  "중첩된 템플릿 인수 목록에서 인접한 '>' 구분 기호 사이에 공백이 필요합니다('>>'는 오른쪽 시프트 연산자임).",
  "멀티바이트 문자를 처리할 수 있는 로캘 %sq을(를) 설정할 수 없습니다.",
  "멀티바이트 문자 시퀀스가 잘못되었습니다.",
  "템플릿 인스턴스화로 인해 예기치 않은 함수 형식 %t1이(가) 발생했습니다(템플릿 선언 후 이름의 의미가 변경되었을 수 있음 -- 템플릿의 형식은 %t2).",
  "모호한 가이딩 선언 -- 두 개 이상의 함수 템플릿 %no이(가) %t 형식과 일치합니다.",
  "비형식 템플릿 인수에서 비정수 연산을 사용할 수 없습니다.",
  "'embedded_c++' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "Embedded C++는 템플릿을 지원하지 않습니다.",
  "Embedded C++는 예외 처리를 지원하지 않습니다.",
  "Embedded C++는 네임스페이스를 지원하지 않습니다.",
  "Embedded C++는 런타임 형식 정보를 지원하지 않습니다.",
  "Embedded C++는 새 캐스트 구문을 지원하지 않습니다.",
  "Embedded C++는 using 선언을 지원하지 않습니다.",
  "Embedded C++는 'mutable'을 지원하지 않습니다.",
  "Embedded C++는 다중 또는 가상 상속을 지원하지 않습니다.",
  "잘못된 Microsoft 버전 번호: %s",
  "멤버 포인터 표현 %sq이(가) %n에 이미 설정되어 있습니다.",
  "%t1은(는) %t2에 대한 생성자를 지정하는 데 사용할 수 없습니다.",
  "정수 계열 상수에 대한 접미사가 잘못되었습니다.",
  "__uuidof의 피연산자에 __declspec(uuid('...'))가 지정된 클래스 또는 열거형 형식이 있어야 합니다.",
  "__declspec(uuid('...'))에 잘못된 GUID 문자열이 있습니다.",
  "'vla' 옵션은 C를 컴파일할 경우에만 사용할 수 있습니다.",
  "범위가 지정되지 않은 가변 길이 배열은 사용할 수 없습니다.",
  "이 선언에서 명시적 템플릿 인수 목록을 사용할 수 없습니다.",
  "연결이 있는 엔터티에는 가변 길이 배열과 관련된 형식을 사용할 수 없습니다.",
  "가변 길이 배열에는 정적 저장 기간을 사용할 수 없습니다.",
  "%n이(가) 템플릿이 아닙니다.",
  "가변 길이 배열 차원(%p(으)로 선언됨)",
  "템플릿 인수가 필요합니다.",
  null,
  "비멤버 연산자에는 클래스 또는 열거형 형식의 매개 변수가 필요합니다.",
  "'enum_overloading' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  null,
  "소멸자 이름 %t1의 한정자가 %t2 형식과 일치하지 않습니다.",
  "형식 한정자가 무시되었습니다.",
  "'nonstd_qualifier_deduction' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'dllimport'를 선언한 함수는 정의할 수 없습니다.",
  "잘못된 속성 사양입니다. 올바른 형식은 __declspec(property(get=이름1,put=이름2))입니다.",
  "속성이 이미 지정되어 있습니다.",
  "이 선언에서 __declspec(property)를 사용할 수 없습니다.",
  "멤버가 __declspec(property)로 선언되었지만 지정된 'get' 함수가 없습니다.",
  "__declspec(property) 'get' 함수 %sq이(가) 없습니다.",
  "멤버가 __declspec(property)로 선언되었지만 지정된 'put' 함수가 없습니다.",
  "__declspec(property) 'put' 함수 %sq이(가) 없습니다.",
  "모호한 클래스 멤버 참조 -- %nd1이(가) %nd2에 대한 참조에 사용됩니다.",
  null,
  null,
  null,
  "파생 클래스 %t1의 멤버 포인터를 기본 클래스 %t2의 멤버 포인터로 변환할 수 없습니다. 기본 클래스는 가상입니다.",
  "인스턴스화 파일에 대한 잘못된 디렉터리: %s",
  "'one_instantiation_per_object' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  null,
  null,
  "여러 개의 입력 파일을 컴파일할 때 인스턴스화 정보 파일 이름을 지정할 수 없습니다.",
  "여러 입력 파일을 컴파일할 때에는 'one_instantiation_per_object' 옵션을 사용할 수 없습니다.",
  "두 개 이상의 명령줄 옵션이 약어 '--%s'과(와) 일치합니다.",
  "--%s",
  "함수 형식에 대한 형식 한정자가 무시됩니다.",
  null,
  "late/early tiebreaker 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "va_start를 잘못 사용했습니다.",
  "va_arg를 잘못 사용했습니다.",
  "va_end를 잘못 사용했습니다.",
  "인스턴스화 보류 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "#import 파일에 대한 잘못된 디렉터리: %s",
  "가져오기 디렉터리는 Microsoft 모드에서만 지정할 수 있습니다.",
  "참조 형식이 있는 멤버는 공용 구조체에 사용할 수 없습니다.",
  "여기에는 'typedef'를 지정할 수 없습니다.",
  "%n의 재선언에서 해당 액세스를 변경합니다.",
  "클래스 또는 네임스페이스로 정규화된 이름이 필요합니다.",
  "'main' 함수 선언에서 반환 형식 'int'가 생략되었습니다.",
  "멤버 포인터 표현 %sq이(가) %n에 대해 지나치게 제한적입니다.",
  "void가 아닌 %n의 끝에 return 문이 없습니다.",
  "%no의 중복된 using 선언이 무시되었습니다.",
  "열거형 비트 필드는 항상 부호가 없지만 열거형 %t은(는) 음수 열거자를 포함합니다.",
  "'class_name_injection' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'arg_dep_lookup' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'friend_injection' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'template' 다음에 오는 이름은 템플릿이어야 합니다.",
  null,
  "비표준 지역 클래스 friend 선언 -- 바깥쪽 범위에 이전 선언이 없습니다.",
  "이 선언에 대한 기본 인수를 지정하는 것은 표준이 아닙니다.",
  "'nonstd_using_decl' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'main' 함수의 반환 형식은 'int'여야 합니다.",
  "비형식 템플릿 매개 변수에는 클래스 형식을 사용할 수 없습니다.",
  "클래스 외부의 클래스 템플릿의 선언에서 기본 템플릿 인수를 지정할 수 없습니다.",
  "생성자의 함수 try 블록 처리기에는 return 문을 사용할 수 없습니다.",
  "일반 지정자와 확장 지정자를 이니셜라이저 지정에서 결합할 수 없습니다.",
  "두 번째 첨자는 첫 번째 첨자보다 작아서는 안 됩니다.",
  null,
  "'extended_designators' 옵션은 C를 컴파일할 경우에만 사용할 수 있습니다.",
  "비트 필드의 선언된 크기가 비트 필드 형식의 크기보다 크기 때문에 %s비트로 잘립니다.",
  "생성자 이름으로 사용된 형식이 %t 형식과 일치하지 않습니다.",
  "연결이 없는 형식을 사용하여 연결이 있는 변수를 선언합니다.",
  "연결이 없는 형식을 사용하여 함수를 선언합니다.",
  "생성자에 반환 형식을 지정할 수 없습니다.",
  "소멸자에 반환 형식을 지정할 수 없습니다.",
  "유니버설 문자 이름의 형식이 잘못되었습니다.",
  "유니버설 문자 이름에서 잘못된 문자를 지정합니다.",
  "유니버설 문자 이름에서 기본 문자 집합의 문자를 지정할 수 없습니다.",
  "이 유니버설 문자는 식별자에 사용할 수 없습니다.",
  "식별자 __VA_ARGS__는 variadic 매크로의 대체 목록에만 나타날 수 있습니다.",
  "이 friend 선언의 한정자는 무시됩니다.",
  "배열 범위 지정자를 동적 이니셜라이저에 적용할 수 없습니다.",
  "여기에는 속성 이름이 표시될 수 없습니다.",
  "함수 한정자로 사용된 'inline'이 무시됩니다.",
  "'compound_literals' 옵션은 C를 컴파일할 경우에만 사용할 수 있습니다.",
  "가변 길이 배열 형식을 사용할 수 없습니다.",
  "정수 계열 상수 식에서 복합 리터럴을 사용할 수 없습니다.",
  "%t 형식의 복합 리터럴을 사용할 수 없습니다.",
  "지역 클래스에서 템플릿 friend 선언을 선언할 수 없습니다.",
  "모호한 '?' 연산: %t1 형식의 두 번째 피연산자와 %t2 형식의 세 번째 피연산자를 상호 변환할 수 있습니다.",
  "적절한 operator() 또는 함수 포인터 형식에 대한 변환 함수가 없는 클래스 형식의 개체에 대한 호출입니다.",
  "변환 %np의 서로게이트 함수",
  "인수 목록에 대해 %t 형식의 개체를 호출할 수 있는 방법이 두 가지 이상입니다.",
  "typedef 이름이 유사한 형식으로 이미 선언되어 있습니다.",
  "operator new 및 operator delete는 내부 연결에 지정할 수 없습니다.",
  "스토리지 클래스 'mutable'은 익명 공용 구조체에 사용할 수 없습니다.",
  "미리 컴파일된 헤더 파일이 잘못되었습니다.",
  "추상 클래스 형식 %t은(는) catch 형식으로 사용할 수 없습니다.",
  "비멤버 함수 또는 정적 멤버 함수를 선언하는 데 정규화된 함수 형식을 사용할 수 없습니다.",
  "매개 변수를 선언하는 데 정규화된 함수 형식을 사용할 수 없습니다.",
  "정규화된 함수 형식에 대한 포인터나 참조를 만들 수 없습니다.",
  "불필요한 중괄호는 비표준입니다.",
  "잘못된 매크로 정의: %s",
  "포인터 형식 %t1 및 %t2의 빼기는 표준이 아닙니다.",
  "template 템플릿 매개 변수 선언에서 빈 템플릿 매개 변수 목록을 사용할 수 없습니다.",
  "'class'가 필요합니다.",
  "template 템플릿 매개 변수를 선언할 때에는 'struct' 키워드를 사용할 수 없습니다.",
  "%np2이(가) %no1에 의해 숨겨집니다. 계획된 가상 함수 재정의입니까?",
  "함수 정의인 friend 선언에 정규화된 이름을 사용할 수 없습니다.",
  "%n1이(가) %n2과(와) 호환되지 않습니다.",
  "여기에 스토리지 클래스를 지정할 수 없습니다.",
  "using 선언으로 지정된 클래스 멤버는 직접 기본 클래스에 표시되어야 합니다.",
  null,
  "Sun 모드가 cfront 모드와 호환되지 않습니다.",
  "strict 모드가 Sun 모드와 호환되지 않습니다.",
  "Sun 모드는 C++를 컴파일할 때만 사용할 수 있습니다.",
  "template 템플릿 매개 변수의 이름은 해당 템플릿 매개 변수 중 하나의 이름과 같을 수 없습니다.",
  "기본 인수의 재귀 인스턴스화",
  null,
  "%n은(는) 정의할 수 있는 엔터티가 아닙니다.",
  "소멸자 이름을 정규화해야 합니다.",
  "friend 클래스 이름을 'typename'으로 지정할 수 없습니다.",
  "using 선언으로 생성자 또는 소멸자에 이름을 지정할 수 없습니다.",
  "정규화된 friend 템플릿 선언은 이전에 선언된 특정 템플릿을 참조해야 합니다.",
  "클래스 템플릿 선언에 잘못된 지정자가 있습니다.",
  "인수가 정식 매개 변수와 호환되지 않습니다.",
  "'dep_name' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "%t1 클래스에서 시작하는 'operator->' 함수의 시퀀스에 루프가 있습니다.",
  "%n에 멤버 클래스 %sq이(가) 없습니다.",
  "전역 범위에 이름이 %sq인 클래스가 없습니다.",
  "템플릿 기본 인수의 재귀 인스턴스화",
  "공용 구조체에는 액세스 선언과 using 선언이 표시될 수 없습니다.",
  "%no이(가) 클래스 멤버가 아닙니다.",
  "비표준 멤버 상수 선언을 사용할 수 없습니다.",
  "'ignore_std' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'parse_templates' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'dep_name' 옵션과 'no_parse_templates'를 함께 사용할 수 없습니다.",
  "지정된 언어 모드가 호환되지 않습니다.",
  "중첩된 클래스의 재선언이 잘못되었습니다.",
  "크기를 알 수 없는 배열이 포함된 형식은 사용할 수 없습니다.",
  "정적 저장 기간이 있는 변수는 인라인 함수 내에서 정의할 수 없습니다.",
  "내부 연결이 있는 엔터티를 외부 연결이 있는 인라인 함수 내에서 참조할 수 없습니다.",
  "인수 형식 %t이(가) 이 형식의 제네릭 함수 매크로와 일치하지 않습니다.",
  "가변 길이 배열 %nod",
  "friend 선언이 이전 선언에 기본 인수를 추가할 수 없습니다.",
  "이 범위에서 %n을(를) 선언할 수 없습니다.",
  "예약된 식별자 %sq은(는) 함수 내부에서만 사용할 수 있습니다.",
  "이 유니버설 문자는 식별자로 시작할 수 없습니다.",
  "문자열 리터럴이 필요합니다.",
  "인식할 수 없는 STDC pragma",
  "'ON', 'OFF' 또는 'DEFAULT'가 필요합니다.",
  "STDC pragma는 전역 범위의 선언 사이 또는 블록 범위의 모든 문이나 선언 이전에만 나타날 수 있습니다.",
  "va_copy를 잘못 사용했습니다.",
  "%s은(는) 부동 소수점 형식과 함께 사용해야 합니다.",
  "복합 형식을 사용할 수 없습니다.",
  "지정자 종류가 잘못되었습니다.",
  "부동 소수점 값을 정확하게 표현할 수 없습니다.",
  "복합 부동 소수점 연산 결과가 범위를 벗어났습니다.",
  "실수와 허수 간의 변환 결과가 0이 됩니다.",
  "유연한 배열 멤버에 이니셜라이저를 지정할 수 없습니다.",
  "imaginary *= imaginary는 왼쪽 피연산자를 0으로 설정합니다.",
  "표준에서는 후속 선언에 의해 %n에 형식이 지정되어야 합니다('int'로 간주됨).",
  "인라인 %n에 대한 정의가 필요합니다.",
  "정수에서 더 작은 포인터로의 변환입니다.",
  "_Complex 또는 _Imaginary 형식의 형식 지정자에 부동 소수점 형식이 포함되어야 합니다.",
  "익명 공용 구조체에서 형식을 선언할 수 없습니다.",
  "지역 변수에 대한 포인터를 반환합니다.",
  "로컬 임시 대상에 대한 포인터를 반환합니다.",
  "'export' 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'export' 옵션은 'no_dep_name'과 함께 사용할 수 없습니다.",
  "'export' 옵션은 'implicit_include'와 함께 사용할 수 없습니다.",
  "%n 선언이 다른 변환 단위의 선언과 호환되지 않습니다.",
  "다른 선언은 %p입니다.",
  "보조 변환 단위 %sq을(를) 컴파일하는 동안 검색되었습니다.",
  "보조 변환 단위 %sq의 컴파일",
  "필드 선언에는 가변 길이 배열과 관련된 형식을 사용할 수 없습니다.",
  "%n 선언이 %sq을(를) 컴파일하는 동안 의미가 달라졌습니다.",
  "'template'이 필요합니다.",
  "명시적 인스턴스화에서 'export'를 사용할 수 없습니다.",
  "이 선언에서 'export'를 사용할 수 없습니다.",
  "명명되지 않은 네임스페이스의 멤버를 'export'로 선언할 수 없습니다.",
  "템플릿을 정의한 후 'export'로 선언할 수 없습니다.",
  "선언에는 레이블을 사용할 수 없습니다.",
  "내보낸 템플릿에 대한 지원이 비활성화되어 있습니다.",
  null,
  "%n이(가) %sq 컴파일 중에 이미 정의되었습니다.",
  "%n이(가) 다른 변환 단위에서 이미 정의되었습니다.",
  "__based 사양에서 비정적 지역 변수를 사용할 수 없습니다.",
  "두 개 이상의 변환 단위를 컴파일할 때에는 메이크파일 종속성을 나열하는 옵션을 지정할 수 없습니다.",
  null,
  "두 개 이상의 변환 단위를 컴파일할 때에는 전처리된 출력을 생성하는 옵션을 지정할 수 없습니다.",
  "사용자 선언 생성자가 포함된 클래스에서 클래스와 이름이 같은 필드를 선언할 수 없습니다.",
  "두 개 이상의 변환 단위를 컴파일할 때에는 'implicit_include'를 사용할 수 없습니다.",
  "내보낸 템플릿 파일 %sq이(가) 손상되었습니다.",
  "%n은(는) 내보낸 정의를 포함하는 변환 단위에서 명시적으로 특수화되었기 때문에 인스턴스화할 수 없습니다.",
  "개체 형식: %s",
  "개체에 멤버 %n과(와) 호환되지 않는 형식 한정자가 있습니다.",
  "%n의 인스턴스 중 인수 목록 및 개체와 일치하는 인스턴스가 없습니다(개체에 일치를 방해하는 형식 한정자가 있음).",
  "특성이 %t과(와) 호환되지 않는 모드를 지정합니다.",
  "지정된 너비를 갖는 형식이 없습니다.",
  "특성으로 지정된 맞춤 값이 잘못되었습니다.",
  "%t에 대한 특성이 잘못되었습니다.",
  null,
  null,
  "%sq 특성이 인수를 사용하지 않습니다.",
  null,
  "특성 이름이 필요합니다.",
  "알 수 없는 특성 %sq",
  "여기에는 특성이 나타날 수 없습니다.",
  "%sq 특성에 대한 인수가 잘못되었습니다.",
  null,
  "'goto *expr'에서 expr은 'void *' 형식이어야 합니다.",
  "'goto *expr'은 표준이 아닙니다.",
  "레이블 주소를 가져오는 것은 표준이 아닙니다.",
  "파일 이름이 두 번 이상 지점되었습니다. %s",
  "#warning 지시문: %s",
  null,
  "'transparent_union' 특성은 공용 구조체에만 적용되지만 %t은(는) 공용 구조체가 아닙니다.",
  "불완전한 형식에서 'transparent_union' 특성이 무시됩니다.",
  "%n1의 크기가 첫 번째 필드와 같지 않으므로 %t1이(가) transparent일 수 없습니다.",
  "%t1은(는) 첫 번째 필드와 크기가 다른 %t2 형식의 필드가 있기 때문에 transparent일 수 없습니다.",
  null,
  "%sq 특성이 지역 변수에 적용되지 않습니다.",
  "함수 정의에서 특성이 허용되지 않습니다.",
  null,
  "case 범위의 두 번째 상수가 첫 번째 상수보다 커야 합니다.",
  "함수 정의에서 asm 이름은 허용되지 않습니다.",
  "typedef에서 asm 이름이 무시됩니다.",
  "알 수 없는 레지스터 이름 '%s'",
  null,
  "알 수 없는 asm 제약 조건 한정자 '%s'",
  "알 수 없는 asm 제약 조건 문자 '%s'",
  "asm 피연산자에 제약 조건 문자가 없습니다.",
  "asm 출력 피연산자에 '=' 또는 '+' 한정자 중 하나가 있어야 합니다.",
  "asm 입력 피연산자에 '=' 또는 '+' 한정자를 사용할 수 없습니다.",
  null,
  null,
  "'%s' 레지스터가 두 번 이상 사용되었습니다.",
  "'%s' 레지스터가 사용되는 동시에 변경됩니다.",
  "'%s' 레지스터가 두 번 이상 변경되었습니다.",
  "레지스터 '%s'의 용도가 고정되어 때문에 asm 문에서 사용할 수 없습니다.",
  "레지스터 '%s'의 용도가 고정되어 있기 때문에 asm 문에서 변경할 수 없습니다.",
  "비어 있는 변경 가능 목록을 완전히 생략해야 합니다.",
  "asm 피연산자가 필요합니다.",
  "변경할 레지스터가 필요합니다.",
  "'format' 특성에는 가변 매개 변수(...)가 필요합니다.",
  "첫 번째 대체 인수가 첫 번째 가변 인수가 아닙니다.",
  "format 인수의 인덱스가 매개 변수 개수보다 큽니다.",
  "format 인수에 문자열 형식을 사용할 수 없습니다.",
  "구문 명확성을 높이기 위해 사용되는 'template' 키워드는 템플릿 내에서만 사용할 수 있습니다.",
  "db_opt pragma를 사용하려면 명령줄에 디버그 옵션을 지정해야 합니다.",
  null,
  "%sq 특성이 비함수 형식 %t에 적용되지 않습니다.",
  "void 또는 함수 형식에 대한 포인터의 산술 연산",
  "스토리지 클래스는 auto 또는 register여야 합니다.",
  "가변 매개 변수(...)를 통해 전달할 경우 %t1이(가) %t2(으)로 확장될 수 있습니다. 대신 나중에 오는 형식을 사용합니다.",
  "%sq이(가) 기본 클래스 멤버가 아닙니다.",
  "__super는 '::' 다음에 표시될 수 없습니다.",
  "__super는 클래스 범위에서만 사용할 수 있습니다.",
  "__super 다음에 '::'이 와야 합니다.",
  "[ %d 인스턴스화 컨텍스트가 표시되지 않음 ]",
  "mangled 이름이 너무 깁니다.",
  "선언에서 정의되지 않은 엔터티 %sq에 대한 별칭을 지정했습니다.",
  "선언이 별칭 %n과(와) 일치하지 않습니다.",
  "별칭으로 선언된 엔터티에는 정의를 사용할 수 없습니다.",
  "가변 길이 배열 필드 형식이 길이가 0인 배열 필드 형식으로 처리됩니다.",
  "lvalue에 대한 비표준 캐스트가 무시되었습니다.",
  "인식할 수 없는 플래그 이름: %s",
  "void 반환 형식은 정규화할 수 없습니다.",
  "여기서는 auto 지정자가 무시됩니다(표준 C/C++에서 유효하지 않음).",
  "'packed' 특성이 없는 맞춤에서 환산(reduction)이 무시됩니다.",
  "%no에 해당하는 멤버 템플릿이 다른 변환 단위에서 다른 종류의 템플릿으로 선언되어 있습니다.",
  "불필요한 이니셜라이저가 무시됩니다.",
  "va_start는 가변 매개 변수(...)가 있는 함수에만 표시될 수 있습니다.",
  "'short_enums' 옵션은 GNU C 및 GNU C++ 모드에서만 유효합니다.",
  "잘못된 내보내기 정보 파일 %sq1, 줄 번호 %s2",
  "statement 식은 블록 범위에서만 사용할 수 있습니다.",
  "변환 단위에서 ",
  "비레지스터 자동 변수에서 asm 이름이 무시됩니다.",
  null,
  "인식할 수 없는 UPC pragma",
  "공유 블록 크기가 이전에 지정한 크기와 일치하지 않습니다.",
  "대괄호로 묶은 식은 배열 차원이 아니라 블록 크기 사양으로 간주됩니다.",
  "공유 배열의 블록 크기는 0보다 커야 합니다.",
  "다중 블록 크기를 사용할 수 없습니다.",
  "strict 또는 relaxed에 shared가 필요합니다.",
  "이 컨텍스트에서 THREADS를 사용할 수 없습니다.",
  "지정된 블록 크기가 %s의 최대 값을 초과합니다.",
  "shared를 반환하는 함수를 사용할 수 없습니다.",
  null,
  "스레드 수가 상수가 아닌 경우 shared 형식 배열의 1차원은 THREADS의 배수여야 합니다.",
  "구조체 또는 공용 구조체 내부에서 shared 형식을 사용할 수 없습니다.",
  "매개 변수에 shared 형식을 사용할 수 없습니다.",
  "동적 THREADS 차원에는 한정된 블록 크기가 필요합니다.",
  "shared 변수는 static이거나 extern이어야 합니다.",
  "upc_blocksizeof의 인수는 shared 형식 자체가 아니라 shared 형식에 대한 포인터입니다.",
  "중첩된 upc_forall에서 affinity 식이 무시되었습니다.",
  "upc_forall 루프 내부 또는 외부로 분기할 수 없습니다.",
  "affinity 식은 shared 형식이거나 shared 형식을 가리켜야 합니다.",
  "affinity에는 shared 포인터가 아니라 shared 형식이 필요합니다.",
  "shared void* 형식만 같은지 비교할 수 있습니다.",
  "UPC 모드는 C++ 및 KR 모드와 호환되지 않습니다(&R).",
  "입력 줄의 null(0) 문자가 무시되었습니다.",
  "문자열 또는 문자 상수의 null(0) 문자",
  "헤더 이름의 null(0) 문자",
  "for 이니셜라이저의 선언에서 바깥쪽 범위의 선언을 숨깁니다.",
  "숨겨진 선언은 %p입니다.",
  "%nfd의 프로토타입 선언이 이 프로토타입화되지 않은 재선언 이후에 무시됩니다.",
  null,
  "%npd에는 외부 C 연결이 있어야 합니다.",
  "변수 선언에서 for 이니셜라이저의 선언을 숨깁니다.",
  "상세 형식 지정자에는 typedef %sq을(를) 사용할 수 없습니다.",
  "0 상수 호출이 무시되었습니다.",
  "매개 변수 %sq을(를) 함수 try 블록의 catch 절에서 다시 선언할 수 없습니다.",
  "%n의 초기 명시적 특수화는 템플릿을 포함하는 네임스페이스에서 선언되어야 합니다.",
  "'cc' 변경이 무시되었습니다.",
  "'template' 다음에 식별자가 와야 합니다.",
  "이 컨텍스트에서 MYTHREAD를 사용할 수 없습니다.",
  "레이아웃 한정자가 shared 포인터를 한정할 수 없습니다.",
  "레이아웃 한정자가 불완전한 배열을 한정할 수 없습니다.",
  "%sq 선언이 처리기 매개 변수를 숨깁니다.",
  "배열 형식으로의 비표준 캐스트가 무시되었습니다.",
  "_Pragma 연산자에서 이 pragma를 사용할 수 없습니다(#pragma 지시문을 사용해야 함).",
  "필드에서 기본 클래스의 끝 채우기를 사용합니다.",
  "GNU C++ 컴파일러는 비트 필드 채우기를 사용할 수 있습니다.",
  "%nd이(가) deprecated로 선언되었습니다.",
  "비정적 멤버 선언에서 asm 이름을 사용할 수 없습니다.",
  "인식할 수 없는 형식의 함수 형식 %sq이(가) 무시되었습니다.",
  "기본 클래스 %no1이(가) 기본 클래스 %no2의 끝 채우기를 사용합니다.",
  "'init_priority' 특성은 정적 데이터 멤버의 정의와 클래스 형식의 네임스페이스 범위 변수에만 사용할 수 있습니다.",
  "요청된 초기화 우선 순위는 내부용으로 예약되어 있습니다.",
  "이 익명 공용 구조체/구조체 필드가 %nd에 의해 숨겨집니다.",
  "오류 번호가 잘못되었습니다.",
  "오류 태그가 잘못되었습니다.",
  "오류 번호 또는 오류 태그가 필요합니다.",
  "클래스 크기가 끝 채우기의 영향을 받습니다.",
  "레이블은 함수 정의에서만 참조할 수 있습니다.",
  "statement 식으로 컨트롤을 전송할 수 없습니다.",
  null,
  "이 문은 statement 식 내부에서 사용할 수 없습니다.",
  "일반적으로 복사할 수 없는 클래스는 statement 식 내부에서 정의할 수 없습니다.",
  null,
  "동적으로 초기화되는 지역 정적 변수는 statement 식 내부에서 사용할 수 없습니다.",
  "가변 길이 배열은 statement 식 내부에서 사용할 수 없습니다.",
  "statement 식은 기본 인수 내부에서 사용할 수 없습니다.",
  "함수 포인터와 데이터 포인터 간의 비표준 변환입니다.",
  "인터페이스 형식에는 가상 기본 클래스를 사용할 수 없습니다.",
  "인터페이스 형식에서 'private' 또는 'protected'를 지정할 수 없습니다.",
  "인터페이스 형식은 다른 인터페이스 형식에서만 파생될 수 있습니다.",
  "%t은(는) 인터페이스 형식입니다.",
  "인터페이스 형식에는 typedef 멤버를 사용할 수 없습니다.",
  "인터페이스 형식에는 사용자 선언 생성자 또는 소멸자를 사용할 수 없습니다.",
  "인터페이스 형식에는 사용자 선언 멤버 연산자를 사용할 수 없습니다.",
  "함수에서 인터페이스 형식을 선언할 수 없습니다.",
  null,
  "인터페이스 형식에는 데이터 멤버를 사용할 수 없습니다.",
  "인터페이스 형식에는 friend 선언이 포함될 수 없습니다.",
  null,
  "인터페이스 형식에는 중첩된 클래스 형식을 사용할 수 없습니다.",
  "인터페이스 형식에는 멤버 템플릿을 사용할 수 없습니다.",
  "인터페이스 형식에는 정적 멤버 함수를 사용할 수 없습니다.",
  "__pragma 연산자에서 이 pragma를 사용할 수 없습니다(#pragma 지시문을 사용해야 함).",
  "한정자가 %t의 기본 클래스여야 합니다.",
  "선언은 지정된 기본 클래스의 순수 가상 멤버 함수와 일치해야 합니다.",
  "%t의 크기나 복잡성으로 인해 내부 계산에서 정수 오버플로가 발생합니다.",
  "내부 계산의 정수 오버플로",
  "__w64는 int, long 및 포인터 형식에만 지정할 수 있습니다.",
  "int, long 또는 포인터 형식이 64비트 크기인 환경에서 컴파일한 경우 변환이 축소될 수 있습니다.",
  "pragma pack의 현재 값은 %s입니다.",
  "pragma pack(show)의 인수가 무시됩니다.",
  null,
  null,
  "이전의 __declspec(align(...))이 무시되었습니다.",
  "%sq 특성 매개 변수에 대한 인수 값이 필요합니다.",
  "%sq 특성 매개 변수에 대한 인수 값이 잘못되었습니다.",
  "%sq 특성 매개 변수에 대한 부울 값이 필요합니다.",
  "위치 인수는 특성에서 명명된 인수 다음에 올 수 없습니다.",
  "%sq1 특성에 이름이 %sq2인 매개 변수가 없습니다.",
  "%sq 특성에 대한 인수 목록이 필요합니다.",
  "',' 또는 ']'가 필요합니다.",
  "특성 인수 %sq에 이미 값이 지정되었습니다.",
  "%sq 특성에 값을 할당할 수 없습니다.",
  "throw 식에 포인터에서 불완전한 포인터 형식을 사용할 수 없습니다.",
  "alignment-of 연산자가 불완전한 형식에 적용되었습니다.",
  "%sq은(는) 독립형 특성으로만 사용할 수 있습니다.",
  "여기에는 %sq 특성을 사용할 수 없습니다.",
  null,
  "특성은 여기에 허용되지 않습니다.",
  "%sq 특성 매개 변수에 대한 인수 값이 잘못되었습니다.",
  "특성 인수가 너무 많습니다.",
  "액세스할 수 없는 기본 클래스 %t(으)로부터의 변환은 허용되지 않습니다.",
  "'export' 옵션에는 고유한 템플릿 서명이 필요합니다.",
  "서로 다른 문자 종류를 포함하는 문자열 리터럴을 연결할 수 없습니다.",
  "GNU 레이아웃 버그는 가상 기본 %no1을(를) %no2 개체 경계 밖에 배치하기 때문에 에뮬레이트되지 않습니다.",
  "가상 기본 %no1이(가) %no2 개체 경계 밖에 배치되었습니다.",
  "네임스페이스 멤버 선언의 비표준 정규화된 이름",
  "맞춤에서 환산(reduction)이 무시되었습니다.",
  "const 한정자가 무시되었습니다.",
  null,
  "GNU asm 한정자가 잘못되었습니다.",
  "일반적으로 복사할 수 없는 클래스 형식이 가변 매개 변수(...)를 통해 전달되었습니다.",
  "일반적으로 복사할 수 없는 클래스 형식은 va_arg를 통해 페치할 수 없습니다.",
  "'u' 또는 'U' 접미사는 고정 소수점 리터럴의 'l' 또는 'L' 접미사 앞에 와야 합니다.",
  "'fixed_point' 옵션은 C를 컴파일할 경우에만 사용할 수 있습니다.",
  "정수 피연산자로 인해 고정 소수점 오버플로가 발생할 수 있습니다.",
  "고정 소수점 상수가 범위를 벗어났습니다.",
  "고정 소수점 값을 정확하게 표현할 수 없습니다.",
  "상수가 long long에 비해 너무 커 부호 없는 long long 형식(비표준)이 지정되었습니다.",
  "레이아웃 한정자가 shared void 포인터를 한정할 수 없습니다.",
  "다차원 배열 형식에서 THREADS가 중복되었습니다.",
  "강력한 using 지시문은 네임스페이스 범위에만 표시될 수 있습니다.",
  "%nf에서 비템플릿 함수를 선언합니다. 템플릿 인스턴스를 참조하려면 <>를 추가하십시오.",
  "작업에서 고정 소수점 오버플로가 발생할 수 있습니다.",
  "식에 정수 계열, 열거형 또는 고정 소수점 형식이 있어야 합니다.",
  "식에 정수 계열 또는 고정 소수점 형식이 있어야 합니다.",
  "'noreturn'으로 선언된 함수가 반환을 수행합니다.",
  "asm 이름이 이전 선언과 충돌하기 때문에 무시되었습니다.",
  "클래스 멤버 typedef를 다시 선언할 수 없습니다.",
  "임시 대상의 주소를 가져옵니다.",
  "정의가 아닌 클래스 선언에서 특성이 무시됩니다.",
  "고정 소수점 값이 암시적으로 부동 소수점 형식으로 변환되었습니다.",
  "고정 소수점 형식에 분류가 사용되지 않았습니다.",
  "템플릿 매개 변수에는 고정 소수점 형식을 사용할 수 없습니다.",
  "16진수 부동 소수점 상수를 사용할 수 없습니다.",
  "'named_address_spaces' 옵션은 C를 컴파일할 경우에만 사용할 수 있습니다.",
  "부동 소수점 값이 필요한 고정 소수점 형식에 맞지 않습니다.",
  "값을 고정 소수점 값으로 정확하게 변환할 수 없습니다.",
  "고정 소수점 변환으로 인해 부호가 변경되었습니다.",
  "정수 값이 필요한 고정 소수점 형식에 맞지 않습니다.",
  "고정 소수점 연산 결과가 범위를 벗어났습니다.",
  "명명된 주소 공간이 여러 개입니다.",
  "자동 저장 기간이 있는 변수를 명명된 주소 공간에 저장할 수 없습니다.",
  "형식을 명명된 주소 공간으로 한정할 수 없습니다.",
  "함수 형식을 명명된 주소 공간으로 한정할 수 없습니다.",
  "필드 형식을 명명된 주소 공간으로 한정할 수 없습니다.",
  "고정 소수점 값이 필요한 부동 소수점 형식에 맞지 않습니다.",
  "고정 소수점 값이 필요한 정수 형식에 맞지 않습니다.",
  "값이 필요한 고정 소수점 형식에 맞지 않습니다.",
  "'named_registers' 옵션은 C를 컴파일할 경우에만 사용할 수 있습니다.",
  "여기에는 명명된 레지스터 스토리지 클래스를 사용할 수 없습니다.",
  "%nd이(가) 호환되지 않는 명명된 레지스터 스토리지 클래스로 다시 선언되었습니다.",
  "별칭이 지정된 변수에 명명된 레지스터 스토리지 클래스를 지정할 수 없습니다.",
  "명명된 레지스터 스토리지 지정자가 이미 사용되고 있습니다.",
  "'embedded_c' 옵션과 Embedded C의 개별 기능을 제어하는 옵션을 함께 사용할 수 없습니다.",
  "잘못된 EDG_BASE 디렉터리: %s",
  null,
  "미리 정의된 매크로 항목이 유효하지 않음, 줄 %s: %s2",
  "매크로 모드 이름 %sq이(가) 잘못되었습니다.",
  "미리 정의된 매크로 %sq의 재정의가 호환되지 않습니다.",
  "%nd의 재선언에 명명된 레지스터 스토리지 클래스가 없습니다.",
  "명명된 레지스터가 변수 형식에 비해 너무 작습니다.",
  "명명된 레지스터 스토리지 클래스로 배열을 선언할 수 없습니다.",
  "열거형 형식에 대한 const_cast는 표준이 아닙니다.",
  "'embedded_c' 옵션은 C를 컴파일할 경우에만 사용할 수 있습니다.",
  "여기에는 명명된 주소 공간 한정자를 사용할 수 없습니다.",
  "경계가 지정되지 않은 배열에 빈 이니셜라이저를 사용할 수 없습니다.",
  "함수가 불완전한 클래스 형식 %t을(를) 반환합니다.",
  "%n은(는) 이미 초기화되었습니다. 범위를 벗어난 클래스 이니셜라이저가 무시됩니다.",
  "선언에서 %nd을(를) 숨깁니다.",
  "명명된 주소 공간에 매개 변수를 할당할 수 없습니다.",
  "고정 소수점 또는 부동 소수점 상수의 접미사가 잘못되었습니다.",
  "명명된 주소 공간에 레지스터 변수를 할당할 수 없습니다.",
  "'SAT' 또는 'DEFAULT'가 필요합니다.",
  "%n에 대응하는 멤버 operator delete%s이(가) 없습니다(할당된 개체의 초기화 중에 예외가 throw되는 경우 호출됨).",
  "'dllimport' 또는 'dllexport'로 스레드 지역 변수를 선언할 수 없습니다.",
  "함수 반환 형식을 명명된 주소 공간으로 한정할 수 없습니다.",
  "요소에 nontrivial 소멸자가 있는 유연한 배열 멤버에 이니셜라이저를 지정할 수 없습니다.",
  "유연한 간접 배열 멤버에 이니셜라이저를 지정할 수 없습니다.",
  "잘못된 GNU 버전 번호: %s",
  "괄호로 묶인 이니셜라이저 다음에 나타나는 변수 특성은 무시됩니다.",
  "이 캐스트의 결과를 lvalue로 사용할 수 없습니다.",
  "부호 없는 고정 소수점 값의 부정",
  null,
  null,
  "레지스터 이름은 레지스터 변수에만 사용할 수 있습니다.",
  "명명된 레지스터 변수에는 void 형식을 사용할 수 없습니다.",
  null,
  "매개 변수에는 링크 범위 지정자를 사용할 수 없습니다.",
  "링크 범위 지정자가 여러 개입니다.",
  "링크 범위 지정자는 외부 연결이 있는 함수와 변수에만 표시될 수 있습니다.",
  "재선언으로 링크 범위를 약하게 만들 수 없습니다.",
  "이 선언에는 링크 범위 지정자를 사용할 수 없습니다.",
  "전역 범위 선언의 비표준 정규화된 이름입니다.",
  "64비트 정수 계열 형식을 더 작은 정수 계열 형식으로 암시적으로 변환합니다(이식성 문제가 있을 수 있음).",
  "64비트 정수 계열 형식을 더 작은 정수 계열 형식으로 명시적으로 변환합니다(이식성 문제가 있을 수 있음).",
  "포인터를 같은 크기의 정수 계열 형식으로 변환합니다(이식성 문제가 있을 수 있음).",
  null,
  "클래스 정의에서 friend 지정자를 사용할 수 없습니다. friend 지정자가 무시됩니다.",
  "정적 변수와 외부 변수만 스레드 로컬 스토리지를 사용할 수 있습니다.",
  "스레드 로컬 스토리지 지정자가 여러 개입니다.",
  "가상 %n이(가) 정의되지 않았습니다. 이는 명명되지 않은 네임스페이스의 멤버이므로 다른 위치에서 정의할 수 없습니다.",
  "소스 줄의 캐리지 리턴 문자가 주석이나 문자/문자열 리터럴 외부 있습니다.",
  "식에 고정 소수점 형식이 있어야 합니다.",
  "잘못 사용된 액세스 지정자가 무시됩니다.",
  "포인터가 bool로 변환되었습니다.",
  "멤버 포인터가 bool로 변환되었습니다.",
  "스토리지 지정자가 무시되었습니다.",
  "클래스 템플릿에서 dllexport 및 dllimport가 무시됩니다.",
  "기본 클래스 dllexport/dllimport 사양이 파생된 클래스의 사양과 다릅니다.",
  "재선언에서 dllexport/dllimport를 %nod에 추가할 수 없습니다.",
  "dllexport/dllimport가 %nod;과(와) 충돌합니다. dllexport로 간주됩니다.",
  "dllimport 엔터티를 정의할 수 없습니다.",
  "dllexport/dllimport에는 외부 연결이 필요합니다.",
  "dllexport/dllimport로 선언된 클래스의 멤버가 같은 지정자를 사용하여 자신을 선언할 수 없습니다.",
  "DLL 인터페이스가 없는 클래스 형식의 필드가 DLL 인터페이스가 있는 클래스에 사용되었습니다.",
  "괄호로 묶인 멤버 선언은 표준이 아닙니다.",
  "줄 연결에서 백슬래시와 줄 바꿈 사이의 공백은 무시됩니다.",
  "dllexport/dllimport가 %nod;과(와) 충돌합니다. dllimport/dllexport가 삭제되었습니다.",
  "익명 멤버 클래스의 잘못된 멤버 -- %t 클래스에 허용되지 않는 멤버 함수가 있습니다.",
  "비표준 reinterpret_cast",
  "위치 서식 지정자는 0이 될 수 없습니다.",
  "지역 클래스가 바깥쪽 함수에서 가변 길이 배열 형식을 참조할 수 없습니다.",
  "멤버 %nd에 이미 명시적 dllexport/dllimport 지정자가 있습니다.",
  "함수 반환 형식에 가변 길이 배열을 사용할 수 없습니다.",
  "%t 형식의 멤버에 대한 포인터에서 가변 길이 배열 형식을 사용할 수 없습니다.",
  "statement 식의 결과에는 가변 길이 배열과 관련된 형식을 사용할 수 없습니다.",
  "trigraphs에 대한 지원이 비활성화되어 있습니다.",
  "%sq 특성은 외부 연결이 있는 함수와 변수에만 표시될 수 있습니다.",
  "strict 모드가 std 네임스페이스를 전역 네임스페이스에 대한 별칭으로 처리하는 방식과 호환되지 않습니다.",
  "매크로 '%s' %p의 확장,",
  "<알 수 없음>",
  "",
  "[ %d 매크로 확장이 표시되지 않음 ]",
  "%p의 매크로 확장",
  "기호화된 피연산자 이름 %sq이(가) 잘못되었습니다.",
  "기호 일치 제약 조건은 처음 10개 피연산자 중 하나를 참조해야 합니다.",
  "이 컨텍스트에서 __if_exists 사용은 지원되지 않습니다.",
  "__if_exists 블록이 열린 범위와 같은 범위에서 닫히지 않았습니다.",
  "스레드 지역 변수는 동적으로 초기화할 수 없습니다.",
  "변환에서 '__unaligned' 한정자를 삭제합니다.",
  "일부 열거자 값은 열거형 형식의 기초가 되는 정수 계열 형식으로 표현할 수 없습니다.",
  "friend 클래스 템플릿 선언에서 기본 인수를 사용할 수 없습니다.",
  "다중 문자 리터럴(이식성 문제가 있을 수 있음)",
  "클래스, 구조체 또는 공용 구조체 형식이 필요합니다.",
  "offsetof의 두 번째 피연산자는 필드여야 합니다.",
  "offsetof의 두 번째 피연산자는 비트 필드일 수 없습니다.",
  "가상 기본의 멤버에 offsetof를 적용할 수 없습니다",
  "offsetof가 표준 레이아웃 클래스가 아닌 형식에 적용되었습니다.",
  "멤버 함수의 friend 선언에는 기본 인수를 사용할 수 없습니다.",
  "정의가 아닌 friend 선언에는 기본 인수를 사용할 수 없습니다.",
  "이전에 선언된 %nd을(를) 기본 인수가 포함된 friend로 재선언할 수 없습니다.",
  "%t에 대한 한정자가 잘못되었습니다(여기에는 파생 클래스를 사용할 수 없음).",
  "%t 클래스의 정의에 대한 한정자가 잘못되었습니다.",
  "%sq에 대한 이전 push_macro가 없습니다.",
  "와이드 문자열 리터럴을 사용할 수 없습니다.",
  null,
  "%sq은(는) C에서만 사용할 수 있습니다.",
  "__ptr32 및 __ptr64는 '*' 다음에 와야 합니다.",
  "__ptr32 및 __ptr64를 동시에 적용할 수 없습니다.",
  "%sq의 템플릿 인수 목록은 매개 변수 목록과 일치해야 합니다.",
  "불완전한 클래스 형식을 사용할 수 없습니다.",
  "복소수 정수 계열 형식은 지원되지 않습니다.",
  "__real 및 __imag는 복소수 값에만 적용할 수 있습니다.",
  "__real/__imag가 실수 값에 적용되었습니다.",
  "%nd이(가) deprecated (%sq)(으)로 선언되었습니다.",
  "%nd의 재정의가 잘못되었습니다.",
  "dllimport/dllexport가 명명되지 않은 네임스페이스의 멤버에 적용되었습니다.",
  "__thiscall은 비정적 멤버 함수 선언에만 표시될 수 있습니다.",
  "__thiscall은 가변 매개 변수(...)가 있는 함수에 사용할 수 없습니다.",
  "%n의 명시적 특수화는 처음 사용하기 전에 나타나야 합니다(%p).",
  "sealed 클래스 형식은 기본 클래스로 사용할 수 없습니다.",
  "중복된 클래스 한정자",
  "멤버 함수에 'abstract' 및 'sealed' 한정자를 함께 사용할 수 없습니다.",
  "sealed 멤버는 순수 가상 멤버일 수 없습니다.",
  "비가상 함수를 'abstract' 또는 'sealed' 한정자로 선언할 수 없습니다.",
  "'override'로 선언된 멤버 함수는 기본 클래스 멤버를 재정의하지 않습니다.",
  "sealed %nd을(를) 재정의할 수 없습니다.",
  "%nd이(가) 클래스 한정자 'abstract'로 선언되었습니다.",
  "줄 ",
  " / ",
  "대상 ",
  "키워드",
  "매크로",
  "레이블",
  "템플릿 매개 변수",
  "형식",
  "합집합",
  "클래스",
  "구조체",
  "template 템플릿 매개 변수",
  "템플릿",
  "클래스 템플릿",
  "열거형",
  "매개 변수",
  "처리기 매개 변수",
  "변수",
  "비형식",
  "상수",
  "함수",
  "오버로드된 함수",
  "멤버",
  "필드",
  "네임스페이스",
  "명명된 레지스터",
  "명명된 주소 공간",
  "함수 템플릿",
  "템플릿 인수 기반",
  "템플릿 인수 기반",
  " (선언됨 ",
  "(소스의 끝)",
  "소스의 끝",
  "줄",
  "줄",
  "열",
  "설명",
  "설명",
  "경고",
  "경고",
  "오류",
  "오류",
  "심각한 오류",
  "심각한 오류",
  "명령줄 오류",
  "명령줄 오류",
  "내부 오류",
  "내부 오류",
  null,
  null,
  "오류 한계에 도달했습니다.",
  "내부 오류 루프",
  "심각한 오류 처리의 루프입니다.",
  null,
  "임시",
  "전처리 출력",
  "원시 목록",
  "상호 참조",
  "중간 언어 (1)",
  "중간 언어 (2)",
  "중간 언어 (3)",
  "중간 언어 (4)",
  "중간 언어 (5)",
  "중간 언어 (6)",
  "중간 언어 (7)",
  "중간 언어 (8)",
  "중간 언어 (9)",
  null,
  null,
  null,
  null,
  null,
  "다시 정의할 수 없는 플래그가 없습니다.",
  "',' 다음에 모드가 없습니다.",
  "매크로 이름이 없습니다.",
  "다시 정의할 수 없는 값이 잘못되었습니다.",
  "중복된 함수 한정자",
  "char16_t 리터럴에 대한 잘못된 문자",
  null,
  "인식할 수 없는 호출 규칙 %s, 다음 중 하나여야 함:",
  null,
  null,
  null,
  "열거형 형식의 내부 형식은 정수 계열 형식이어야 합니다.",
  "일부 열거자 상수는 %t(으)로 표현할 수 없습니다.",
  "현재 모드에서 %sq을(를) 사용할 수 없습니다.",
  "type traits helpers 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'sentinel' 특성에는 가변 매개 변수(...)가 필요합니다.",
  "인수는 상수 null 포인터 값이어야 합니다.",
  "센티널 값에 대한 인수의 개수가 부족합니다.",
  "센티널 인수는 가변 매개 변수(...)와 일치해야 합니다.",
  "__declspec(implementation_key(...))는 #pragma start_map_region과 #pragma stop_map_region 사이에만 표시될 수 있습니다.",
  "#pragma start_map_region이 이미 활성화되었습니다. pragma가 무시되었습니다.",
  "현재 활성화된 #pragma start_map_region이 없습니다. pragma가 무시되었습니다.",
  "%n은(는) 소멸자의 이름을 지정하는 데 사용할 수 없습니다(형식 이름이 필요함).",
  "비어 있는 비표준 와이드 문자 리터럴을 L'\\0'(으)로 처리했습니다.",
  "여기에는 'typename'을 지정할 수 없습니다.",
  "비배치 operator delete는 가상 소멸자가 있는 클래스에서 표시되어야 합니다.",
  "이름 연결이 이전 %nd 선언과 충돌합니다.",
  "별칭에서 별칭이 지정된 엔터티의 순환을 만듭니다.",
  null,
  "특정 레지스터에 할당된 정적 저장 기간이 있는 변수를 이니셜라이저로 선언할 수 없습니다.",
  "특정 레지스터에 할당된 변수는 일반적으로 복사 가능해야 합니다.",
  "%no에 미리 정의된 의미가 삭제되었습니다.",
  null,
  "클래스 형식이 지정자와 함께 사용하기에 적합하지 않습니다.",
  null,
  "익명 공용 구조체 한정자는 표준이 아닙니다.",
  "익명 공용 구조체 한정자가 무시되었습니다.",
  null,
  "__declspec(%s)가 무시되었습니다(C 구조체에 대한 의미가 없음).",
  "선언 사이에서 쉼표 다음에 오는 지정자는 비표준입니다.",
  "비표준 지정자가 무시되었습니다.",
  "정의가 아닌 열거형 선언에서 특성이 무시됩니다.",
  "참조를 'mutable'로 선언하는 것은 표준이 아닙니다.",
  "배열에 대한 조건 선언은 항상 true입니다.",
  "정적 어설션이 %sq(으)로 인해 실패했습니다.",
  "visibility 특성이 이전 선언과 충돌하기 때문에 무시되었습니다.",
  "필드 이름이 두 개 이상의 오프셋을 확인합니다. %nod1 및 %nod2을(를) 참조하십시오.",
  "%sq이(가) 필드 이름이 아닙니다.",
  "이 스위치 %p에 case 레이블 값이 이미 있습니다.",
  "멤버 함수에는 내부 연결을 사용할 수 없습니다.",
  "선언이 기본 제공 %n을(를) 숨깁니다.",
  "선언이 기본 제공 %n을(를) 오버로드합니다.",
  "두 개 이상의 변환 단위를 컴파일할 때에는 매크로 정의를 나열하는 옵션을 지정할 수 없습니다.",
  "%n 선언 이후에 예기치 않은 괄호(잘못된 형식의 매개 변수 목록 또는 잘못된 이니셜라이저?)",
  "문자열 이니셜라이저 주위의 괄호는 비표준입니다.",
  "__interface",
  "auto 형식 지정자로 선언된 변수가 자체 이니셜라이저에 나타날 수 없습니다.",
  "'auto' 형식을 추론할 수 없습니다.",
  "'auto' 형식에는 '{...}'를 사용한 초기화를 사용할 수 없습니다.",
  "최상위 배열 형식에는 'auto' 형식이 표시될 수 없습니다.",
  "최상위 함수 형식에는 'auto' 형식이 표시될 수 없습니다.",
  "%t 형식의 멤버에는 in-class initializer를 사용할 수 없습니다.",
  "in-class initializer가 있는 멤버는 const여야 합니다.",
  "'auto' 형식을 추론할 수 없습니다(이니셜라이저 필요).",
  "'auto' 형식은 이 엔터티에 대해 %t1이지만 이전에 %t2(으)로 유추되었습니다.",
  "잘못된 생성자 선언",
  "형식 한정자를 잘못 사용했습니다.",
  "공용 구조체는 abstract 또는 sealed일 수 없습니다.",
  "여기에는 'auto'를 사용할 수 없습니다.",
  "기본 클래스 형식의 정의가 아직 불완전합니다.",
  "'extern template'은 정적 %nd의 특수화를 참조할 수 없습니다.",
  "'extern template'은 %n의 명시적 인스턴스화 다음에 올 수 없습니다.",
  "__declspec(restrict)에는 포인터 형식을 반환하는 함수가 필요합니다.",
  "'report_gnu_extensions' 옵션은 GNU C 및 GNU C++ 모드에서만 유효합니다.",
  "가변 길이 배열 형식은 비표준입니다.",
  "지정자가 비표준입니다.",
  "이 지정자 구문은 GNU 확장입니다.",
  "복합 리터럴은 비표준입니다.",
  "statement 식은 GNU 확장입니다.",
  "이전에 정의된 엔터티의 asm 이름이 무시되었습니다.",
  "특성은 GNU 확장입니다.",
  "확장 asm 구문은 GNU 기능입니다.",
  "volatile asm 선언은 GNU 확장입니다.",
  "asm 이름 지정자는 GNU 확장입니다.",
  "'__restrict' 한정자는 표준이 아닙니다.",
  "'typeof'는 GNU 확장입니다.",
  "typedef의 크기나 부호의 유무를 수정하는 것은 표준이 아닙니다.",
  "길이가 0인 배열은 GNU 확장입니다.",
  "유연한 배열 멤버는 표준이 아닙니다.",
  "'nonnull' 특성이 포인터가 아닌 매개 변수를 참조합니다.",
  "'nonnull' 특성의 인수가 매개 변수 개수보다 큽니다.",
  "포인터 형식을 가진 매개 변수가 없습니다.",
  "매개 변수에 제공된 null 인수가 'nonnull' 특성으로 표시되었습니다.",
  "%t1의 소멸자는 %t2의 소멸자에 액세스할 수 없기 때문에 표시되지 않았습니다.",
  "%t에 대해 표시되지 않는 소멸자가 필요합니다.",
  "루틴이 'inline'인 동시에 'noinline'입니다.",
  "잘못된 cleanup 루틴",
  "'cleanup' 특성에는 자동 저장 기간이 필요합니다.",
  "'cleanup' 특성은 매개 변수에 적용되지 않습니다.",
  "cleanup 루틴에 잘못된 형식이 있습니다.",
  "cleanup 루틴을 호출하려면 가정 변환이 필요합니다.",
  "__sptr 및 __uptr은 '*' 다음에 와야 합니다.",
  "__sptr 및 __uptr을 함께 지정할 수 없습니다.",
  "%t1에서 %t2(으)로의 확대 포인터 변환은 부호 비트를 확장합니다.",
  "__sptr 및 __uptr은 멤버 포인터 형식에 적용되지 않습니다.",
  "%n이(가) const이기 때문에 %t에 대한 복사 대입 연산자 선언이 표시되지 않았습니다.",
  "%n에 참조 형식이 있기 때문에 %t에 대한 복사 대입 연산자 선언이 표시되지 않았습니다.",
  "%t2의 선언이 표시되지 않았기 때문에 %t1에 대한 복사 대입 연산자 선언이 표시되지 않았습니다.",
  "%t2의 선언이 모호하기 때문에 %t1에 대한 복사 대입 연산자 선언이 표시되지 않았습니다.",
  "%t2의 선언에 액세스할 수 없기 때문에 %t1에 대한 복사 대입 연산자 선언이 표시되지 않았습니다.",
  "%t2의 선언이 표시되지 않았기 때문에 %t1에 대한 복사 생성자 선언이 표시되지 않았습니다.",
  "%t2의 선언이 모호하기 때문에 %t1에 대한 복사 생성자 선언이 표시되지 않았습니다.",
  "%t2의 선언에 액세스할 수 없기 때문에 %t1에 대한 복사 생성자 선언이 표시되지 않았습니다.",
  "%t1의 소멸자는 액세스가 불가능하며 %t2의 소멸자가 표시되지 않았기 때문에 호출되지 않습니다.",
  "파일 끝에 있는 정의 다음에 세미콜론이나 선언자가 오지 않았습니다.",
  "첫 번째 인수는 정수 포인터이거나 열거형 형식이어야 합니다.",
  "동기화된 작업은 크기가 1, 2, 4 또는 8인 개체에만 유효합니다.",
  "불필요한 인수가 무시되었습니다.",
  "명령줄 정의에서 매크로 이름 %sq 다음에는 '='로 간주됩니다.",
  "매크로 이름 %sq과(와) 해당 대체 텍스트 사이에 공백이 필요합니다.",
  "호출 결과가 사용되지 않습니다.",
  "void 반환 형식에 대한 'warn_unused_result' 특성이 무시됩니다.",
  null,
  "정규화된 이름을 사용하는 재선언에서 dllimport/dllexport가 무시됩니다.",
  "문자 리터럴에 문자가 너무 많습니다. 불필요한 선행 문자가 무시되었습니다.",
  "%n을(를) 해당 정의 %p 다음에 인라인으로 선언할 수 없습니다.",
  null,
  null,
  "템플릿 인수는 이름 연결이 없는 형식을 참조할 수 없습니다.",
  "여기서는 'virtual'이 무시됩니다.",
  "템플릿 인수는 가변 길이 배열 형식을 참조할 수 없습니다.",
  "유니버설 문자 이름은 서로게이트 코드 포인트를 지정할 수 없습니다.",
  "기본 소스 파일에서 #include_next를 사용할 수 없습니다.",
  "템플릿 멤버 정의에 %no1을(를) 지정할 수 없습니다. 대신 %no2(으)로 간주됩니다.",
  "로컬 함수 선언에서 %sq 특성이 무시됩니다.",
  "%sq 연결(%n)에서 유효한 토큰을 만들지 않습니다.",
  "%no이(가) 모호합니다(%n2(으)로 간주됨).",
  "정적 멤버 함수에서 형식 한정자를 사용할 수 없습니다.",
  "생성자 또는 소멸자에서 형식 한정자를 사용할 수 없습니다.",
  "operator new 또는 operator delete에서 형식 한정자를 사용할 수 없습니다.",
  "비멤버 함수에서 형식 한정자를 사용할 수 없습니다.",
  "%s에 대한 인수는 파생 작업이 있지만 계산되지 않음",
  "인식할 수 없는 유니코드 소스 종류(UTF-8, UTF-16, UTF-16LE, UTF-16BE 중 하나여야 함): %s",
  "16진수 값 %s의 유니코드 문자를 전처리 출력에서 표현할 수 없습니다.",
  "요청된 생성자/소멸자 우선 순위는 내부용으로 예약되어 있습니다.",
  "인식할 수 없는 GCC pragma",
  "인식할 수 없는 GCC visibility pragma 지시문",
  "인식할 수 없는 visibility 종류",
  "visibility pragma가 여전히 활성화되어 있습니다.",
  "일치하는 visibility push가 없습니다.",
  "불완전한 형식의 typeid",
  null,
  "배열 %n에 요소가 하나라고 간주합니다.",
  "vector_size 특성에는 산술 형식이나 열거형 형식이 필요합니다.",
  "벡터 크기가 너무 큽니다.",
  "벡터의 요소 수는 2의 거듭제곱이어야 합니다.",
  "벡터 크기는 요소 크기의 배수여야 합니다.",
  "벡터와 스칼라 혼합 연산을 사용할 수 없습니다.",
  "연산에 같은 크기의 벡터 두 개가 필요합니다.",
  "템플릿 종속 벡터 크기는 사용할 수 없습니다.",
  null,
  null,
  "복소수 요소 형식에서 vector_size 특성을 사용할 수 없습니다.",
  null,
  "벡터 연산에는 동일한 요소 형식이 필요합니다.",
  "정수 계열이 아닌 형식이 포함된 벡터에는 벡터 연산을 적용할 수 없습니다.",
  "파일 %s을(를) 열 수 없습니다. %sq2",
  "파일 %s을(를) 열 수 없습니다. %sq2: %s3",
  "미리 컴파일된 헤더",
  "미리 정의된 매크로",
  "생성된 C",
  "생성된 C++",
  "소스",
  "%s 파일을 쓰는 동안 오류가 발생했습니다. %s2",
  "일반 파일이 아닙니다.",
  "디렉터리입니다.",
  "잘못된 파일 이름",
  "정의 목록",
  "인스턴스화 요청",
  "내보낸 템플릿",
  "내보내기 정보",
  "템플릿 정보",
  "IL 출력",
  "변환에서 '__restrict' 한정자를 삭제합니다.",
  "%sq에 대해 매핑된 메모리를 가져올 수 없습니다. %s2",
  "restrict 한정자가 무시됩니다.",
  null,
  "유연한 배열 멤버를 포함하는 요소의 배열은 표준이 아닙니다.",
  "템플릿 매개 변수에 벡터 형식을 사용할 수 없습니다.",
  "%n1의 초기화가 %n2 초기화 이전에 완료됩니다.",
  null,
  "열거형 지정자에서 상속 종류가 무시됩니다.",
  null,
  "열거형 지정자에서 한정자가 무시됩니다.",
  "식별자 문자를 유니코드로 표현할 수 없습니다.",
  "헤더 이름에 유니코드로 표현할 수 없는 문자가 들어 있습니다.",
  "%sq이(가) 유효한 로캘 이름이 아닙니다.",
  "템플릿 매개 변수가 포함된 void 매개 변수 목록 선언은 표준이 아닙니다.",
  "람다 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "명시적 캡처가 기본값과 일치합니다.",
  "%n은(는) 변수가 아닙니다.",
  "정적 저장 기간이 있는 변수는 람다로 캡처할 수 없습니다.",
  "'this'는 참조로 캡처할 수 없습니다.",
  "이 람다의 본문 내에서 'this'를 사용할 수 없습니다.",
  "람다의 본문 내부에서 바깥쪽 범위 익명 공용 구조체의 멤버를 참조할 수 없습니다.",
  "바깥쪽 함수의 지역 변수는 캡처 목록에 있지 않는 한 람다 본문에서 참조할 수 없습니다.",
  "람다 본문에서 바깥쪽 범위 지역 변수에 대한 참조가 잘못되었습니다.",
  "현재 함수 범위 바깥쪽에 있는 지역 변수를 캡처할 수 없습니다.",
  "바깥쪽 함수 'this'는 캡처 목록에 있지 않는 한 람다 본문에서 참조할 수 없습니다.",
  null,
  "%t1 형식의 람다 캡처된 변수를 %t2 형식의 closure class 필드로 복사할 수 없습니다.",
  "잘못된 템플릿 디렉터리: %s",
  "오류",
  "오류",
  "심각한 오류",
  "심각한 오류",
  "및",
  "이(가) '%s'을(를) 컴파일할 때 검색되었습니다.",
  "이(가) 이 컴파일에서 검색되었습니다.",
  "열거형 값이 내부 형식(%t)의 범위를 벗어났습니다.",
  "공백 앞에 오는 '\\'는 줄 연결이 아닙니다.",
  "런타임 형식 정보가 없어 이 dynamic_cast를 수행할 수 없습니다. 비활성화되었습니다.",
  "%t(으)로의 변환이 모호합니다. 직접 기본 형식이 선택되었습니다.",
  "내부 버퍼가 지나치게 커질 수 있습니다.",
  "C++ 예외 처리기가 사용되었지만 예외 처리 의미 체계가 지정되지 않았습니다.",
  "생성자에서 형식 한정자가 무시되었습니다.",
  "람다로 캡처된 변수에는 가변 길이 배열과 관련된 형식을 사용할 수 없습니다.",
  "호환되지 않는 벡터 형식 간의 변환",
  "람다 본문을 시작하는 '{'가 필요합니다.",
  "rvalue 참조 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "람다에서 형식 한정자를 사용할 수 없습니다.",
  "캡처 목록에서 하나의 이름이 여러 번 표시될 수 없습니다.",
  "명시적 템플릿 인수가 무시되었습니다.",
  "람다는 상수 식에 사용할 수 없습니다.",
  "%t이(가) 클래스 형식이 아닙니다.",
  "배열 포인터 형식에 적용된 'delete'를 delete[]로 처리했습니다.",
  "배열 포인터 형식에 적용된 'delete'는 표준이 아닙니다. delete[]로 처리했습니다.",
  "지정된 인수 목록으로 %n을(를) 호출할 수 없습니다.",
  "rvalue 참조를 lvalue에 바인딩할 수 없습니다.",
  "비형식 템플릿 매개 변수에는 rvalue 참조 형식을 사용할 수 없습니다.",
  "형식 한정자가 무시되었습니다(내부 형식은 참조임).",
  "지역 형식을 사용하여 선언된 %n은(는) 이 변환 단위에서 정의되어야 합니다.",
  "연결이 없는 형식을 사용하여 선언된 %n은(는) 이 변환 단위에서 정의되어야 합니다.",
  "rvalue 참조 dynamic_cast의 피연산자는 완전한 클래스 형식을 사용해야 합니다.",
  "'= default'는 기본 생성자, 복사/이동 생성자, 복사/이동 대입 연산자 및 소멸자에만 표시될 수 있습니다.",
  "'= delete'는 함수의 첫 번째 선언에만 표시될 수 있습니다.",
  "%npd을(를) 참조할 수 없습니다. 삭제된 함수입니다.",
  "람다는 계산되지 않은 식에 사용할 수 없습니다.",
  "__builtin_va_arg_pack/__builtin_va_arg_pack_len은 가변 매개 변수(...)가 있는 인라인 함수에만 표시될 수 있습니다.",
  "'= default'는 friend 선언에서 지정할 수 없습니다.",
  "C++ 키워드가 필요합니다.",
  null,
  "offset이 상수가 아닙니다.",
  "인식할 수 없는 #pragma 주석 형식 %sq",
  "'auto'가 형식 지정자인지 여부를 제어하는 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'auto'가 스토리지 클래스인지 여부를 제어하는 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "'auto'의 형식 지정자 의미와 스토리지 클래스 지정자 의미를 모두 사용하지 않도록 설정할 수는 없습니다.",
  "#pragma 주석의 문자열이 잘못되었습니다.",
  "삭제된 함수가 삭제되지 않은 %n을(를) 재정의합니다.",
  "삭제되지 않은 함수가 삭제된 %n을(를) 재정의합니다.",
  "%t의 기본 생성자를 참조할 수 없습니다. 삭제된 함수입니다.",
  "rvalue 참조를 catch 형식으로 사용할 수 없습니다.",
  "%n의 기본 인수가 다른 변환 단위의 선언과 호환되지 않습니다.",
  "%n의 기본 인수가 %sq 컴파일 중에 달라졌습니다.",
  null,
  "다른 변환 단위에서 %n의 이니셜라이저가 다릅니다.",
  "%n의 이니셜라이저가 %sq 컴파일 중에 달라졌습니다.",
  "템플릿 종속 형식의 지정자를 사용할 수 없습니다.",
  "인식할 수 없는 규칙 종류",
  "'on' 또는 'off'가 필요합니다.",
  "#pragma conform(forScope) 스택이 비어 있습니다.",
  "이전 #pragma conform(forScope) 항목이 %sq과(와) 일치하지 않습니다.",
  "forScope 동작이 표준이 아닙니다.",
  "forScope 동작이 표준입니다.",
  "함수 'main'은 삭제할 수 없습니다.",
  "여기서는 형식 한정자가 의미가 없습니다.",
  "기본 대입 연산자에 대한 형식이 잘못되었습니다.",
  "함수 템플릿은 기본값이 될 수 없습니다.",
  "기본값으로 설정된 생성자에 대한 형식이 잘못되었습니다.",
  "함수 호출에 하나의 인수가 필요합니다.",
  "함수 호출에 실수 부동 소수점 인수가 필요합니다.",
  "기본 인수가 있는 복사 생성자는 기본값이 될 수 없습니다.",
  "미리 선언된 함수를 삭제할 수 없습니다.",
  "if 문의 빈 종속 문",
  "if 문의 'else' 절에 있는 빈 종속 문",
  "삭제된 복사에 필요한 %nfd을(를) 참조할 수 없습니다. 삭제된 함수입니다.",
  "'main'의 비표준 첫 번째 매개 변수 %t, 'int'가 필요합니다.",
  "’main'에 대한 비표준 매개 변수 개수, 매개 변수가 없거나 두 개여야 합니다.",
  "'main'의 비표준 두 번째 매개 변수 %t, 'char *[]' 또는 'char **'이 필요합니다.",
  "%sq이(가) 시스템 및 비시스템 include 디렉터리로 지정되었습니다. 비시스템 항목이 무시됩니다.",
  "이동 생성자와 이동 대입 연산자를 제어하는 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  null,
  null,
  "후행 반환 형식에는 'auto' 형식 지정자가 필요합니다.",
  "후행 반환 형식이 중첩된 선언자에 나타날 수 없습니다.",
  "후행 반환 형식이 있는 함수 선언자는 단순 'auto' 형식 지정자 뒤에 와야 합니다.",
  "'auto' 함수에는 후행 반환 형식이 필요합니다.",
  "멤버 템플릿에는 순수 지정자를 사용할 수 없습니다.",
  "문자열 리터럴이 너무 깁니다. 초과된 문자가 무시되었습니다.",
  "nullptr 키워드를 제어하는 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "std::nullptr_t가 bool로 변환되었습니다.",
  null,
  null,
  "%sq 특성이 빈 인수 목록을 허용하지 않습니다.",
  "특성이 두 번 이상 나옵니다.",
  "%sq 특성이 여기에 적용되지 않습니다.",
  "%sq 특성이 비트 필드에 적용되지 않습니다.",
  "%sq 특성에 비트 필드가 필요합니다.",
  "%sq 특성이 멤버 함수에 적용되지 않습니다.",
  "%sq 특성에 멤버 함수가 필요합니다.",
  "%sq 특성이 가상 함수에 적용되지 않습니다.",
  "%sq 특성에 가상 함수가 필요합니다.",
  "%sq 특성이 순수 가상 함수에 적용되지 않습니다.",
  "%sq 특성에 순수 가상 함수가 필요합니다.",
  "%sq 특성이 레지스터 변수에 적용되지 않습니다.",
  "%sq 특성에 레지스터 변수가 필요합니다.",
  "%sq 특성이 원래 선언에 나오지 않았습니다.",
  "특성은 여기에 허용되지 않습니다.",
  "%sq 특성이 클래스 정의에 나와야 합니다.",
  "'final'이 순수 가상 함수에 적용되었습니다.",
  "'final' %nd을(를) 재정의할 수 없습니다.",
  "정적 %n이(가) 참조되었지만 정의되지 않았으므로 extern으로 처리되었습니다.",
  "GNU-C89 스타일의 인라인 처리를 사용하도록 설정하는 옵션은 C를 컴파일할 경우에만 사용할 수 있습니다.",
  "함수가 이전에 'gnu_inline' 특성 없이 선언되었습니다.",
  "'gnu_inline' 특성이 인라인 함수가 아닌 함수에서 무시되었습니다.",
  "%n이(가) 이전에 carries_dependency 특성 없이 선언되었습니다.",
  "배열 %n에 대한 이니셜라이저가 잘못되었습니다.",
  "런타임 라이브러리를 빌드할 때는 C++11 또는 C++14 모드를 지정해야 합니다.",
  "%sq 특성이 함수 형식에 적용되지 않습니다.",
  "%sq 특성에 함수 형식이 필요합니다.",
  "%sq 특성이 비정적 멤버 함수에 적용되지 않습니다.",
  "%sq 특성이 자동 변수에 적용되지 않습니다.",
  "%sq 특성에 자동 변수가 필요합니다.",
  "%sq 특성이 외부 연결이 있는 함수 또는 변수에 적용되지 않습니다.",
  "%sq 특성에 지역 변수가 필요합니다.",
  "여기서는 특성이 무시됩니다.",
  "특성이 어떠한 엔터티에도 적용되지 않습니다.",
  "특성 인수 대체가 잘못되었습니다.",
  "'tls_model' 특성의 인수는 'global-dynamic', 'local-dynamic', 'initial-exec' 또는 'local-exec'여야 합니다.",
  "%p 선언이 다른 'tls_model' 인수를 지정했습니다.",
  "%sq 특성이 인라인 함수에 적용되지 않습니다.",
  "%sq 특성에 인라인 함수가 필요합니다.",
  "include_alias pragma의 두 파일 이름 모두에 동일한 구분 기호 문자를 사용해야 합니다.",
  "부호 있는 피연산자와 부호 없는 피연산자를 비교한 것입니다.",
  "%sq 특성이 명명되지 않은 형식에서 무시되었습니다.",
  "다음에 정의가 오지 않으므로 %sq 특성이 무시되었습니다.",
  "스레드 국부성이 이전 %nd 선언과 호환되지 않습니다.",
  "바깥쪽 람다가 암시적 캡처를 허용하지 않으므로 이 바깥쪽 함수의 지역 변수를 이 람다 본문에서 참조할 수 없습니다.",
  "이 특성 인수에는 짝이 맞지 않는 괄호, 대괄호 또는 중괄호가 포함되어 있습니다.",
  "__builtin_fpclassify에 대한 호출에는 정수 인수 5개와 부동 소수점 인수 1개가 필요합니다.",
  "__builtin_fpclassify에 대한 호출의 마지막 인수에는 실수 부동 소수점 형식이 있어야 합니다.",
  "맞춤 값을 기본 맞춤 값 미만으로 설정할 수 없습니다.",
  "명시적 인스턴스화에서는 특성을 사용할 수 없습니다.",
  "%sq 특성이 정의에 적용되지 않습니다.",
  "%sq 특성에 정의가 필요합니다.",
  "정의가 아닌 friend 선언에는 표준 특성이 나올 수 없습니다.",
  "지정된 맞춤 값(%s1)이 이전 선언에 지정된 맞춤 값(%s2)과 다릅니다.",
  "맞춤 특성은 %p 정의에도 나와야 합니다.",
  "%n은(는) 별칭 선언의 형식 ID에 사용할 수 없습니다.",
  "별칭 템플릿",
  "첫 번째 필드에 부동 소수점 형식이 있으므로 %t이(가) transparent일 수 없습니다.",
  "첫 번째 필드가 비트 필드이므로 %t이(가) transparent일 수 없습니다.",
  "'base_check' 클래스의 가상 함수가 기본 클래스 멤버를 재정의하지만 'override' 특성이 없습니다.",
  "기본 클래스 선언을 숨기지 않는 선언에 'hiding' 특성이 지정되었습니다.",
  "using 선언 %p에 의해 참조되는 선언에 'hiding' 특성이 지정되었습니다.",
  "%nd을(를) 숨기는 선언의 'base_check' 클래스에 'hiding' 특성이 필요합니다.",
  "%n은(는) 이 변환 단위에 정의되어 있지 않지만 지역 형식에 종속됩니다.",
  "%n은(는) 이 변환 단위에 정의되어 있지 않지만 연결이 없는 형식에 종속됩니다.",
  "다른 변환 단위에 %sq 특성이 없습니다.",
  "%sq 특성이 다른 변환 단위와 충돌합니다.",
  "'nonstd_gnu_keywords' 옵션은 GNU C 및 GNU C++ 모드에서만 사용할 수 있습니다.",
  "상수 식에서 상수 변수를 사용하는 것은 C에서 표준이 아닙니다.",
  "자동 저장 기간이 있는 유연한 배열 멤버에 이니셜라이저를 지정할 수 없습니다.",
  null,
  "'final' 클래스 형식은 기본 클래스로 사용할 수 없습니다.",
  "내보낸 템플릿은 더 이상 표준 C++ 언어에 포함되지 않습니다.",
  "템플릿 종속 지정자를 사용할 수 없습니다.",
  "offsetof의 두 번째 피연산자는 참조 형식이 있는 필드일 수 없습니다.",
  "수명이 긴 임시 항목이 요청된 다른 최신 언어 기능과 호환되지 않습니다.",
  "와이드 문자열 리터럴이 진단에서 따옴표로 묶여 표시되지 않습니다.",
  "%sq 특성에 대한 인수가 없습니다.",
  "'c++11' 및 'c++11_sfinae' 옵션을 사용하려면 다른 컴파일러 구성이 필요합니다.",
  "템플릿 매개 변수 팩이 매개 변수 목록 끝에 있지 않습니다.",
  "여기에는 매개 변수 팩 선언을 사용할 수 없습니다.",
  "매개 변수 팩에는 기본값을 사용할 수 없습니다.",
  "C++/CLI는 Microsoft C++ 모드에서만 사용할 수 있습니다.",
  "'value__'는 열거자 상수의 이름으로 사용할 수 없습니다(이 컨텍스트에서 예약된 이름임).",
  "부울 내부 형식을 사용하는 열거형 형식에는 명시적 열거자 값이 필요합니다.",
  null,
  "매개 변수 팩 %sq이(가) 참조되었지만 확장되지 않았습니다.",
  "팩 확장에는 인수 팩이 사용되지 않습니다.",
  "%sq 팩의 요소 수가 %sq2과(와) 같지 않습니다.",
  null,
  "열거형 형식에서 vector_size 특성을 사용할 수 없습니다.",
  "속성은 static이면서 virtual일 수 없습니다.",
  "인덱싱된 속성은 trivial일 수 없습니다.",
  "속성 정의에는 이 선언이 표시될 수 없습니다.",
  "접근자 함수를 선언하는 데 정규화된 함수 형식을 사용할 수 없습니다.",
  "접근자 함수에는 가변 매개 변수(...)를 사용할 수 없습니다.",
  "'get' 접근자가 이 속성 %p에 대해 이미 선언되었습니다.",
  "'set' 접근자가 이 속성 %p에 대해 이미 선언되었습니다.",
  "'get' 접근자에는 매개 변수를 사용할 수 없습니다.",
  "'get' 접근자의 반환 형식이 속성 형식과 일치하지 않습니다.",
  "'set' 접근자의 반환 형식은 void여야 합니다.",
  "속성은 빈 인덱스 목록을 선언할 수 없습니다.",
  "속성 인덱스에는 void 형식을 사용할 수 없습니다.",
  "인덱스 형식이 'set' 접근자의 해당 매개 변수와 일치하지 않습니다.",
  "인덱스 형식이 'get' 접근자의 해당 매개 변수와 일치하지 않습니다.",
  "'set' 접근자에 인덱스 형식이 없습니다.",
  "'get' 접근자에 인덱스 형식이 없습니다.",
  "'set' 접근자에 해당 값 매개 변수가 없습니다.",
  "접근자 함수에 매개 변수가 너무 많습니다.",
  "'set' 접근자의 마지막 매개 변수가 속성 형식과 일치하지 않습니다.",
  "%sq에는 C++/CLI 모드가 필요합니다.",
  "Win32 API '%s'의 오류: %s",
  "#using은 전역 범위에서만 사용할 수 있습니다.",
  "메타데이터",
  "멤버 이름 %sq은(는) %nd에 의해 예약되었습니다.",
  "'['가 필요합니다.",
  "%[C++/CLI] 모드에서는 microsoft_version이 1,600보다 크거나 같아야 합니다.",
  "기본 인덱싱된 속성은 static일 수 없습니다.",
  "속성 접근자는 static이면서 virtual일 수 없습니다.",
  "중첩 형식 선언에는 최상위 표시 유형 지정자가 표시될 수 없습니다.",
  "최상위 표시 유형 지정자에는 형식 정의가 필요합니다.",
  "trivial 속성에는 참조 형식을 사용할 수 없습니다.",
  "trivial 속성에는 const 또는 volatile 형식을 사용할 수 없습니다.",
  "%nd은(는) 이전에 다른 종류의 열거형 형식으로 선언되었습니다.",
  "람다로 캡처된 변수에는 %[managed] 클래스 형식을 사용할 수 없습니다.",
  "%[managed] 클래스에는 공변(covariant) 반환 형식을 사용한 가상 함수 재정의를 사용할 수 없습니다.",
  "핸들의 배열을 사용할 수 없습니다.",
  "배열에 대한 핸들을 사용할 수 없습니다.",
  "함수에 대한 핸들을 사용할 수 없습니다.",
  "void에 대한 핸들을 사용할 수 없습니다.",
  "핸들, 포인터 또는 참조에 대한 핸들을 사용할 수 없습니다.",
  "함수에 대한 추적 참조를 사용할 수 없습니다.",
  null,
  "필드는 추적 참조일 수 없습니다.",
  "추적 참조는 이러한 방식으로 일반 참조와 함께 사용할 수 없습니다.",
  "정적 저장 기간이 있는 변수에는 ref 클래스 형식을 사용할 수 없습니다.",
  "%[managed] 클래스에는 이름이 있어야 합니다.",
  "%[managed] 클래스는 지역 형식일 수 없습니다.",
  "%nd은(는) 이전에 다른 종류의 클래스로 선언되었습니다.",
  "%nd은(는) 이전에 다른 종류의 클래스 템플릿으로 선언되었습니다.",
  "리터럴 데이터 멤버는 %[managed] 클래스의 멤버일 수만 있습니다.",
  "리터럴 데이터 멤버는 초기화해야 합니다.",
  "%t 형식의 리터럴 데이터 멤버는 사용할 수 없습니다.",
  "const는 리터럴 데이터 멤버에는 영향을 미치지 않습니다.",
  "initonly 데이터 멤버는 %[managed] 클래스의 멤버일 수만 있습니다.",
  "const는 initonly 데이터 멤버에는 영향을 미치지 않습니다.",
  "%nd에 'get' 접근자가 없습니다.",
  "%nd에 'set' 접근자가 없습니다.",
  "정적 생성자에는 매개 변수를 사용할 수 없습니다.",
  "정적 생성자는 멤버 템플릿일 수 없습니다.",
  "복합 lvalue는 asm 출력 피연산자로 사용할 수 없습니다.",
  "속성은 %[managed] 클래스의 멤버일 수만 있습니다.",
  "%[managed] 클래스의 멤버 함수에는 형식 한정자를 사용할 수 없습니다.",
  "%[C++/CLI] ref 클래스 또는 인터페이스 클래스에 대한 일반 포인터는 사용할 수 없습니다.",
  "%[C++/CLI] ref 클래스 또는 인터페이스 클래스에 대한 일반 참조는 사용할 수 없습니다.",
  "재정의 지정자가 기본 클래스 멤버 함수의 이름을 지정하지 않습니다.",
  "재정의 지정자가 비가상 멤버 %nd을(를) 지정하지 않습니다.",
  "멤버 함수가 이미 %nd2(으)로 재정의된 %nd1을(를) 재정의합니다.",
  "하나의 표시 유형 지정자만 사용할 수 있습니다.",
  "대리자 정의에 대해 사용되는 %t 형식이 함수 형식이 아닙니다.",
  "대리자 멤버 형식은 %[managed] 클래스의 멤버일 수만 있습니다.",
  "대리자 형식에 대한 추적 참조는 사용할 수 없습니다.",
  "여기에는 대리자 형식을 사용할 수 없습니다.",
  "이 팩 확장이 빈 식 목록을 생성했습니다. 여기에는 식이 필요합니다.",
  "이벤트는 static이면서 virtual일 수 없습니다.",
  "이벤트는 %[managed] 클래스의 멤버일 수만 있습니다.",
  "이벤트 정의에는 이 선언이 표시될 수 없습니다.",
  "이벤트 형식은 대리자에 대한 핸들 형식이어야 합니다.",
  "'add' 접근자가 이 이벤트 %p에 대해 이미 선언되었습니다.",
  "'remove' 접근자가 이 이벤트 %p에 대해 이미 선언되었습니다.",
  "'raise' 접근자가 이 이벤트 %p에 대해 이미 선언되었습니다.",
  "이벤트 접근자는 static이면서 virtual일 수 없습니다.",
  "'add' 및 'remove' 접근자의 반환 형식은 void여야 합니다.",
  "이벤트 접근자에 해당 값 매개 변수가 없습니다.",
  "접근자 함수에 매개 변수가 너무 많습니다.",
  "이벤트 접근자의 매개 변수에 대한 %t1 형식이 이벤트 형식(%t2)과 일치하지 않습니다.",
  "'raise' 접근자의 형식이 이벤트의 대리자 호출 형식과 일치하지 않습니다.",
  "이벤트 정의는 'add' 접근자와 'remove' 접근자를 모두 포함해야 합니다.",
  "정적 변환 함수에는 하나의 인수만 사용해야 합니다.",
  "정적 연산자에는 매개 변수 형식 T, T&, T%% 또는 T = %t인 T^이(가) 있어야 합니다.",
  "sizeof...의 피연산자는 매개 변수 팩 이름이어야 합니다.",
  "sizeof... 연산자는 variadic 템플릿에서만 사용될 수 있습니다.",
  "여기에는 이벤트 이름이 표시될 수 없습니다.",
  "비 %[managed] 클래스에 대한 핸들은 사용할 수 없습니다.",
  "범위가 지정되지 않은 열거형 형식에 대한 핸들은 사용할 수 없습니다.",
  "%[managed] 클래스에는 'property' 특성을 사용할 수 없습니다.",
  "순수 지정자('= 0') 다음에 정의가 오는 것은 표준이 아닙니다.",
  "여기에는 %[managed] nullptr 형식을 사용할 수 없습니다.",
  "ref 클래스 형식을 사용하는 개체의 주소를 가져오는 데 '&' 연산자를 사용할 수 없습니다.",
  "%[managed] 클래스의 배열을 사용할 수 없습니다.",
  "정적 저장 기간이 있는 변수에는 핸들 또는 추적 참조 형식을 사용할 수 없습니다.",
  "람다로 캡처된 변수는 핸들 또는 추적 참조일 수 없습니다.",
  "%[C++/CLI] 매개 변수 배열에는 1차원 %[cli::array] 형식에 대한 핸들이 필요합니다.",
  "%sq 파일에서 메타데이터를 가져올 수 없습니다.",
  "CLI 네임스페이스는 확장할 수 없습니다.",
  "%[cli::array]의 요소 형식은 핸들 또는 값 형식이어야 합니다.",
  "%[cli::array] 형식의 차수가 잘못되었습니다.",
  "cli::interior_ptr/cli::pin_ptr은 표준 클래스, 값 클래스, 정수, 핸들 또는 표준 포인터를 가리켜야 합니다.",
  "%t은(는) 클래스 멤버일 수 없습니다.",
  "cli::pin_ptr 형식의 매개 변수는 사용할 수 없습니다.",
  "종료자 선언이 잘못되었습니다.",
  "종료자에는 매개 변수를 사용할 수 없습니다.",
  "종료자에는 형식 한정자를 사용할 수 없습니다.",
  "종료자에는 반환 형식을 지정할 수 없습니다.",
  "using 선언으로 종료자에 이름을 지정할 수 없습니다.",
  "종료자 이름을 정규화해야 합니다.",
  "종료자 이름 %t1의 한정자가 %t2 형식과 일치하지 않습니다.",
  "종료자의 이름을 지정하는 데 %n을(를) 사용할 수 없습니다(형식 이름이 필요함).",
  "%t 형식의 종료자 이름이 잘못되었습니다.",
  "종료자 참조가 모호합니다. %n1과(와) %n2을(를) 모두 사용할 수 있습니다.",
  "종료자는 ref 클래스의 멤버일 수만 있습니다.",
  null,
  "종료자 이름으로 사용된 형식이 %t 형식과 일치하지 않습니다.",
  "이 형식에 대한 종료자가 없습니다.",
  "'%%' 연산자는 %[managed] 클래스 형식을 사용하는 개체에만 사용할 수 있습니다.",
  "cli::interior_ptr에 대한 포인터, 핸들 또는 참조는 사용할 수 없습니다.",
  "cli::pin_ptr에 대한 포인터, 핸들 또는 참조는 사용할 수 없습니다.",
  "%[C++/CLI] 배열에 대한 포인터 또는 참조는 사용할 수 없습니다.",
  "여기에는 %[C++/CLI] 배열 형식을 사용할 수 없습니다.",
  "%[C++/CLI] ref 클래스는 다른 ref 클래스 또는 인터페이스 클래스에서만 파생될 수 있습니다.",
  "%[C++/CLI] 값 클래스는 인터페이스 클래스에서만 파생될 수 있습니다.",
  "%[C++/CLI] 인터페이스 클래스는 인터페이스 클래스에서만 파생될 수 있습니다.",
  "ref 클래스에는 하나의 직접 ref 기본 클래스만 사용할 수 있습니다(%t이(가) 이미 해당 기본 클래스임).",
  "표준 클래스는 %[managed] 클래스에서 파생될 수 없습니다.",
  "%[managed] 클래스에는 가상 기본을 사용할 수 없습니다.",
  "%[managed] 클래스에는 'private' 또는 'protected' 기본을 사용할 수 없습니다.",
  "'override' 한정자에는 명시적 'virtual' 키워드를 사용하는 가상 함수 선언이 필요합니다.",
  "'abstract' 한정자에는 명시적 'virtual' 키워드를 사용하는 가상 함수 선언이 필요합니다.",
  "'sealed' 한정자에는 명시적 'virtual' 키워드를 사용하는 가상 함수 선언이 필요합니다.",
  "명명된 재정의 지정자에는 명시적 'virtual' 키워드를 사용하는 가상 함수 선언이 필요합니다.",
  "cli::pin_ptr 반환 형식은 사용할 수 없습니다.",
  "%sq 특성은 %[C++/CLI] 모드에서만 적용됩니다.",
  "단순(비추적) 참조는 관리되는 힙에서 엔터티에 바인딩될 수 없습니다.",
  "이식 가능한 어셈블리",
  "기본 어셈블리에서 '%s'이(가) 로드되지 않았습니다.",
  "목록 초기화 구문이 C++11 기능입니다.",
  "sizeof의 피연산자는 ref 클래스 형식 또는 인터페이스 클래스 형식일 수 없습니다.",
  "이 %[cli::array] 형식에 대한 첨자 수가 잘못되었습니다.",
  "%[managed] 클래스에 대한 멤버 포인터가 잘못되었습니다.",
  "%[managed] 클래스의 프라이빗 가상 멤버 함수가 'sealed'가 아닙니다.",
  "소멸자에는 한정자를 사용할 수 없습니다.",
  "종료자에는 한정자를 사용할 수 없습니다.",
  "'virtual'은 %[managed] 클래스의 소멸자에는 영향을 미치지 않습니다.",
  "이 선언이 %nd과(와) 일치하므로 'new' 또는 'override'가 필요합니다.",
  "이 선언이 %nd과(와) 일치하므로 'new' 또는 'virtual'이 필요합니다.",
  "일치하는 %nd이(가) 인터페이스의 멤버이므로 여기에는 'new' 또는 'override'를 사용할 수 없습니다.",
  "일치하는 기본 ref 클래스 멤버가 없는 'new' 한정자입니다.",
  "낮은 액세스 권한으로 %nd이(가) 재정의되었습니다.",
  "%t1 형식의 참조를 %t2 형식의 값으로 초기화할 수 없습니다.",
  "값 클래스에는 복사 생성자를 선언할 수 없습니다.",
  "값 클래스에는 기본 생성자를 선언할 수 없습니다.",
  "값 클래스에는 소멸자를 선언할 수 없습니다.",
  "값 클래스에는 대입 연산자를 선언할 수 없습니다.",
  "값이 아닌 클래스 %t은(는) 값 클래스 멤버의 형식일 수 없습니다.",
  "'cppcli' 옵션에는 다른 컴파일러 구성이 필요합니다.",
  "%[managed] 클래스의 멤버 함수에는 예외 사양을 사용할 수 없습니다.",
  "%[managed] 클래스는 friend를 선언할 수 없습니다.",
  null,
  null,
  "%[managed] 클래스의 멤버 함수에는 로컬 클래스 정의를 사용할 수 없습니다.",
  "%[managed] 클래스의 멤버 함수에는 로컬 람다를 사용할 수 없습니다.",
  "%[C++/CLI] 인터페이스 클래스 형식의 멤버 함수에는 정의를 사용할 수 없습니다.",
  "속성 정의에는 하나 이상의 접근자('get' 또는 'set')를 포함해야 합니다.",
  "기본 인덱싱된 속성이 %nd과(와) 충돌합니다.",
  "%n1은(는) 매개 변수 팩을 따르며 %n2의 매개 변수에서 추론할 수 없으므로 사용할 수 없습니다.",
  "이 팩 확장이 둘 이상의 식을 생성했습니다. 여기에는 단일 식이 필요합니다.",
  "형식은 System::Boolean, System::Byte, System::SByte, System::Int16, System::UInt16, System::Int32, System::UInt32, System::Int64 또는 System::UInt64에 해당해야 합니다.",
  "적절한 operator() 또는 함수 포인터 형식에 대한 변환 함수가 없는 핸들 형식의 개체에 대한 호출입니다.",
  "명명되지 않은 매개 변수 팩 선언은 괄호로 묶일 수 없습니다.",
  "variadic 템플릿은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "속성 정의가 %nd과(와) 충돌합니다.",
  "오버로드된 속성",
  "속성",
  "제네릭 매개 변수에는 기본값을 사용할 수 없습니다.",
  "제네릭에는 형식 매개 변수만 사용할 수 있습니다.",
  "'for each' 문에서 사용하려면 %t 형식이 비정적 멤버 함수 %sq을(를) 제공해야 합니다.",
  "%n 멤버는 정적이기 때문에 'for each'에서 사용할 수 없습니다.",
  "이 'for each' 문에서는 %no의 어떠한 인스턴스도 빈 인수 목록으로 호출할 수 없습니다.",
  "반환 형식이 잘못되었으므로 'for each'가 멤버 함수 'MoveNext'를 사용할 수 없습니다.",
  "%t 형식의 식에는 'for each' 문을 수행할 수 없습니다.",
  "'for each' 문에서 사용하려면 %t 형식이 인덱싱되지 않은 속성 %sq을(를) 제공해야 합니다.",
  null,
  "'for each' 문에서 %t2은(는) 유효한 열거자가 아닙니다(%t1의 'GetEnumerator'에서 반환됨).",
  "'in'이 필요합니다.",
  "%t 클래스에 적절한 대입 연산자가 없습니다(연산자 통합 후).",
  "%sq은(는) 제네릭 매개 변수가 아닙니다.",
  "%sq은(는) 가장 안쪽에 있는 제네릭 매개 변수 목록의 제네릭 매개 변수가 아닙니다.",
  "제네릭 제약 조건이 잘못되었습니다.",
  "이벤트 멤버를 잘못 사용했습니다. 구독, 구독 취소 및 호출만 사용할 수 있습니다.",
  "'raise' 접근자를 사용하지 않고 이벤트를 호출하는 것은 잘못되었습니다.",
  "이벤트에는 '+=' 및 '-='만 올바릅니다.",
  "%[managed] 형식의 typeid는 사용할 수 없습니다.",
  "%[managed] 포인터 형식의 typeid는 사용할 수 없습니다.",
  "다음에 '::typeid'가 있는 이름은 형식 이름이어야 합니다.",
  "이 형식의 %sq 멤버는 %[managed] 클래스 내에서 예약되어 있습니다. 계획된 소멸자입니까?",
  "이 형식의 %sq 멤버는 %[managed] 클래스 내에서 예약되어 있습니다. 계획된 종료자입니까?",
  "%[System]::IDisposable::Dispose가 없거나 잘못되었습니다.",
  "%[System]::Object::Finalize가 없거나 잘못되었습니다.",
  "%n이(가) %[System]::Object::Finalize를 재정의하지 않습니다.",
  "dynamic_cast 핸들의 피연산자는 완전한 클래스 형식에 대한 핸들이어야 합니다.",
  "추적 참조 dynamic_cast의 피연산자는 완전한 클래스 형식의 lvalue여야 합니다.",
  "핸들 또는 추적 참조 형식에 대한 dynamic_cast의 형식은 완전한 클래스를 참조해야 합니다.",
  "내부 포인터는 네이티브 포인터로 캐스트할 수 없습니다.",
  "명시적 변환 연산자는 ref 및 값 클래스 형식에서만 선언할 수 있습니다.",
  "명시적 변환 연산자는 virtual일 수 없습니다.",
  "식에 산술 또는 범위가 지정되지 않은 열거형 형식이 있어야 합니다.",
  "식에 산술, 범위가 지정되지 않은 열거형 또는 포인터 형식이 있어야 합니다.",
  "식에 정수 또는 범위가 지정되지 않은 열거형 형식이 있어야 합니다.",
  "식에 정수, 범위가 지정되지 않은 열거형 또는 고정 소수점 형식이 있어야 합니다.",
  "범위가 지정된 열거형에 적용된 기본 제공 이항 연산자에는 형식이 동일한 두 피연산자가 필요합니다.",
  "%[gcnew]은(는) %t 형식의 엔터티를 할당할 수 없습니다.",
  "배치 구문은 %[gcnew]과(와) 함께 사용할 수 없습니다.",
  "new는 단순한 값 형식과 함께 사용해야 합니다.",
  "new는 %[managed] 클래스에 사용할 수 없습니다(대신 %[gcnew]을(를) 사용해야 함).",
  "new는 핸들 형식에 사용할 수 없습니다.",
  "%[C++/CLI] 배열에 대한 %[gcnew]에 새 이니셜라이저 또는 배열 이니셜라이저가 있어야 합니다.",
  "배열 이니셜라이저는 %[C++/CLI] 배열 형식을 초기화하는 데만 사용할 수 있습니다.",
  "%[gcnew]에는 auto를 사용할 수 없습니다.",
  "배열 범위가 너무 많습니다.",
  "배열 범위가 너무 적습니다.",
  "%nf에 대한 인수가 너무 적습니다.",
  "%nf에 대한 인수가 너무 많습니다.",
  "제네릭 클래스",
  "제공된 제네릭 인수의 개수를 사용하는 %nf의 선언이 없습니다.",
  "대리자 이니셜라이저가 잘못되었습니다. 함수여야 합니다.",
  "대리자 이니셜라이저가 잘못되었습니다. 둘 이상의 함수가 대리자 형식과 일치합니다.",
  "대리자 이니셜라이저가 잘못되었습니다. 함수가 대리자 형식과 일치하지 않습니다.",
  "대리자 이니셜라이저가 잘못되었습니다. 함수 외에 개체도 필요합니다.",
  "대리자 이니셜라이저가 잘못되었습니다. 함수가 %[managed] 클래스의 멤버가 아닙니다.",
  "대리자 이니셜라이저가 잘못되었습니다. 지정된 함수에는 개체가 필요하지 않습니다.",
  "대리자 이니셜라이저가 잘못되었습니다. 개체의 형식이 %t1이지만 %t2 형식이 필요합니다.",
  "%[managed] 클래스에 대한 멤버 함수의 주소를 가져올 수 없습니다.",
  "대리자 이니셜라이저가 잘못되었습니다. '(<function-address>)' 또는 '(<object-handle>, <member-address>)'가 필요합니다.",
  "클래스가 인터페이스 멤버 %nd을(를) 구현하지 못합니다.",
  "네이티브 배열을 할당하는 데 %[gcnew]을(를) 사용할 수 없습니다.",
  "%[C++/CLI] 인터페이스 클래스는 대입 연산자를 선언할 수 없습니다.",
  "%[C++/CLI] 인터페이스 클래스는 sealed가 될 수 없습니다.",
  null,
  "소멸자 또는 종료자 선언에는 명명된 재정의 지정자를 포함할 수 없습니다.",
  "재정의 지정자는 소멸자 또는 종료자를 지정할 수 없습니다.",
  "명명된 재정의 지정자는 %[managed] 클래스에서만 사용할 수 있습니다.",
  "명명된 재정의 지정자로 지정된 멤버 중 이 멤버의 형식과 일치하는 멤버가 없습니다.",
  "정적 생성자 선언에는 명명된 재정의 지정자를 포함할 수 없습니다.",
  "범위가 지정된 열거형 형식에는 이름이 있어야 합니다.",
  "finally 블록으로 컨트롤을 전송할 수 없습니다.",
  "finally 블록 내부에는 return 문을 사용할 수 없습니다.",
  "try 블록에는 최소한 하나 이상의 처리기 또는 finally 절이 필요합니다.",
  "핸들이 %[managed] 개체를 throw해야 합니다.",
  "핸들이 %[managed] 개체를 catch해야 합니다.",
  "finally 블록에는 break 문을 사용할 수 없습니다.",
  "finally 블록에는 continue 문을 사용할 수 없습니다.",
  "첨자가 오버로드된 경우 기본 제공 offsetof를 사용할 수 없습니다.",
  "중복 제약 조건",
  "둘 이상의 클래스 제약 조건: %t1 및 %t2",
  "%n에 대해 둘 이상의 제약 조건 절이 있습니다.",
  "initonly 정적 데이터 멤버는 이니셜라이저를 갖거나 정적 생성자에서 초기화되어야 합니다.",
  "템플릿 재선언의 GNU 특성은 효과가 없습니다.",
  "템플릿 재선언의 GNU 특성은 효과가 없습니다(대신 원래 선언 %p의 특성이 적용됨).",
  "%[C++/CLI] 매개 변수 배열은 마지막 매개 변수여야 합니다.",
  "%[C++/CLI] 매개 변수 배열이 있는 함수에는 기본 인수를 사용할 수 없습니다.",
  "%[C++/CLI] 매개 변수 배열 뒤에는 가변 매개 변수(...)가 올 수 없습니다.",
  "%[C++/CLI] 매개 변수 배열은 연산자 함수 매개 변수 목록에 사용할 수 없습니다.",
  "여기에는 __inline 및 __forceinline을 사용할 수 없습니다.",
  "데이터 멤버에는 %[C++/CLI] 인터페이스 클래스 형식을 사용할 수 없습니다.",
  "변수에는 %[C++/CLI] 인터페이스 클래스 형식을 사용할 수 없습니다.",
  "매개 변수에는 %[C++/CLI] 인터페이스 클래스 형식을 사용할 수 없습니다.",
  "함수 반환 형식은 %[C++/CLI] 인터페이스 클래스 형식일 수 없습니다.",
  "제네릭 매개 변수 형식의 배열은 사용할 수 없습니다.",
  "제네릭 매개 변수 형식에 대한 포인터, 핸들 또는 참조는 사용할 수 없습니다.",
  "initonly 필드에는 ref 클래스 형식을 사용할 수 없습니다.",
  "참조는 initonly 필드에 바인딩할 수 없습니다.",
  "initonly 필드의 주소를 가져올 수 없습니다.",
  "initonly 필드는 포함하는 해당 클래스의 인스턴스 생성자에 의해서만 수정될 수 있습니다.",
  "정적 initonly 필드는 포함하는 해당 클래스의 정적 생성자에 의해서만 수정될 수 있습니다.",
  "멤버 함수는 initonly 필드의 복사본에서 호출됩니다.",
  "식에 포인터 또는 핸들 형식이 있어야 하는데 %t 형식이 있음",
  "이동 생성자 또는 이동 대입 연산자를 사용하여 여기에서 lvalue를 복사할 수 있습니다. 이렇게 하면 소스 개체가 제거될 수 있습니다.",
  "%[C++/CLI] 제네릭 엔터티의 멤버 선택에는 '.'가 아니라 '->' 구문을 사용해야 합니다.",
  "ref 클래스 형식은 %t에서 파생될 수 없습니다.",
  "제네릭 클래스는 %[managed](예: ref 클래스, 값 클래스 또는 인터페이스 클래스)여야 합니다.",
  "sealed 클래스는 제약 조건으로 사용할 수 없습니다.",
  "dynamic_cast의 형식은 값 형식일 수 있는 제네릭 형식일 수 없습니다.",
  "유니버설 문자 이름은 올바른 코드 포인트를 지정해야 합니다.",
  "제네릭 제약 조건이 %nd의 제약 조건과 일치하지 않습니다.",
  "__underlying_type은 열거형 형식에만 적용됩니다.",
  "이 캐스트에는 하나의 피연산자 식만 필요합니다.",
  "16진수 값 %s의 유니코드 문자를 시스템 기본 코드 페이지에서 표현할 수 없습니다.",
  "바인딩된 멤버 포인터와 함수 포인터 간의 비표준 변환입니다.",
  "액세스 지정자 %s1은(는) 사용되지 않습니다. 대신 %s2을(를) 사용하십시오.",
  "비정적 속성 또는 이벤트 정의에서 정적 접근자 함수는 허용되지 않습니다.",
  "%t에 값 클래스 및 ref 클래스 제약 조건이 모두 있습니다. ",
  "%t1 및 %t2에 순환 naked 형식 제약 조건이 포함되어 있습니다.",
  "%t은(는) 유효한 형식 제약 조건이 아닙니다.",
  "미리 컴파일된 헤더 파일 %sq은(는) 불완전하기 때문에 사용되지 않았습니다.",
  "%t은(는) 유효한 제네릭 인수가 아닙니다.",
  "assembly_info 특성이 잘못된 형식에 적용되었습니다.",
  "%t1은(는) 제네릭 매개 변수 %t2의 ref 클래스 제약 조건을 만족하지 않습니다.",
  "%t1은(는) 제네릭 매개 변수 %t2의 값 클래스 제약 조건을 만족하지 않습니다.",
  "%t1은(는) 추상이므로 제네릭 매개 변수 %t2의 %[gcnew] 제약 조건을 만족하지 않습니다.",
  "%t1은(는) public 기본 생성자가 없으므로 제네릭 매개 변수 %t2의 %[gcnew] 제약 조건을 만족하지 않습니다.",
  "제네릭 매개 변수 %t1은(는) %[gcnew] 제약 조건이 없으므로 제네릭 매개 변수 %t2의 %[gcnew] 제약 조건을 만족하지 않습니다.",
  "%t1은(는) 제네릭 매개 변수 %t2의 %t3 형식 제약 조건을 만족하지 않습니다.",
  "제네릭 매개 변수 %t에 대한 제약 조건이 이전 선언(%p)과 다릅니다.",
  "%[managed] 클래스의 멤버는 표준 배열일 수 없습니다.",
  "비 %[managed] 클래스의 멤버는 표준 핸들일 수 없습니다.",
  "비 %[managed] 클래스의 멤버는 추적 참조일 수 없습니다.",
  "핸들의 안전하지 않은 reinterpret_cast",
  "템플릿 인수는 제네릭 형식 매개 변수를 참조할 수 없습니다.",
  "이 구독 작업에서는 식 목록을 사용할 수 없습니다(최상위 쉼표 연산자를 괄호로 묶기).",
  "식에 개체 포인터 또는 %[C++/CLI] 배열 핸들 형식이 있어야 하는데 %t 형식이 있음",
  "인식할 수 없는 특성",
  "%[managed] 클래스의 멤버는 비 %[managed] 클래스 형식일 수 없습니다.",
  "비 %[managed] 클래스의 멤버는 ref 클래스 형식 또는 인터페이스 클래스 형식일 수 없습니다.",
  "in ",
  "대리자를 템플릿으로 선언할 수 없습니다.",
  "제네릭은 명시적으로 특수화할 수 없습니다.",
  "제네릭은 클래스 템플릿에서 선언할 수 없습니다.",
  "템플릿은 제네릭 클래스에서 선언할 수 없습니다.",
  "리터럴 필드는 'static'으로 선언할 수 없습니다.",
  "'long float'는 비표준 확장입니다. 대신에 'double'을 사용하십시오.",
  "표준 클래스는 %[managed] 클래스에서 중첩될 수 없습니다.",
  "__clrcall은 C++/CLI 모드에서만 유효합니다.",
  "__clrcall은 가변 매개 변수(...)가 있는 함수에서 사용할 수 없습니다.",
  "%sq은(는) 여기에서 사용할 수 없습니다.",
  "trivial 속성 또는 이벤트를 사용하여 %nd을(를) 재정의할 수 없습니다.",
  "반복기 변수 이름이 필요합니다.",
  "이 'for each' 문의 반복기 형식이 포인터 형식 또는 반복기와 유사한 클래스 형식이 아닌 %t입니다.",
  "이 'for each' 문의 반복기 형식이 포인터 형식 또는 반복기와 유사한 클래스 형식이 아닌 %t입니다.",
  "이 'for each' 문의 반복기 형식이 포인터 형식 또는 반복기와 유사한 클래스 형식이 아닌 %t입니다.",
  "표준 레이아웃이 아닌 클래스 형식 %t의 이 필드에 대해 부모 형식의 압축 특성이 무시됩니다.",
  "이 선언이 public이 아니고 명명된 재정의 지정자가 없으므로 %nd이(가) 구현되지 않았습니다.",
  "이 선언에는 이전 선언 %p에 지정된 gnu_inline 특성이 없습니다.",
  "%[managed] 클래스의 멤버 함수에는 가변 매개 변수(...)를 사용할 수 없습니다.",
  "이전에 선언된 %n은(는) 'for-each' 문의 반복기로 유효하지 않습니다.",
  "함수 형식에 제네릭 매개 변수가 포함되어 있으므로 호출 규칙이 무시되었습니다. 대신에 __clrcall이 사용되었습니다.",
  "제네릭 매개 변수를 포함하는 함수 형식에는 가변 매개 변수(...)를 사용할 수 없습니다.",
  "일치하는 %nd을(를) 재정의하려면 'virtual'이 필요합니다.",
  "일치하는 %nd을(를) 구현하려면 'virtual'이 필요합니다.",
  "initonly 데이터 멤버는 volatile일 수 없습니다.",
  "이 형식의 멤버 %sq은(는) %[managed] 클래스 내에서 예약되어 있습니다. 'operator' 키워드를 사용하여 %[C++/CLI] 연산자를 선언해야 합니다.",
  "비상수에 대한 추적 참조는 상수에 바인딩될 수 없습니다.",
  "선언된 엔터티에 적용되지 않으므로 여기에서 특성이 무시되었습니다.",
  "%[System]::String에 대한 추적 참조는 사용할 수 없습니다.",
  "보류 중인 제약 조건을 가진 제네릭 클래스 %t이(가) 잘못 사용되었습니다(잘못된 메타데이터 파일 때문일 수 있음).",
  "보류 중인 제약 조건 절은 제네릭 클래스 선언에만 사용할 수 있습니다(제네릭 클래스 정의에는 사용할 수 없음).",
  "여기에는 빈 이니셜라이저 목록을 사용할 수 없습니다.",
  "%[managed] 클래스에서는 템플릿을 선언할 수 없습니다.",
  "여기에는 제너릭 선언을 사용할 수 없습니다.",
  "인터페이스 형식에는 멤버 제너릭을 사용할 수 없습니다.",
  "Latin-1이 아닌 유니코드 문자는 낮은 순서 바이트로 잘립니다.",
  "범위 기반의 'for' 문에 사용하려면 %t 형식에서 %sq 함수를 제공해야 합니다.",
  "이 범위 기반 'for' 문의 반복기 형식이 포인터 형식 또는 반복기와 유사한 클래스 형식이 아닌 %t입니다.",
  "이 범위 기반 'for' 문의 반복기 형식이 포인터 형식 또는 반복기와 유사한 클래스 형식이 아닌 %t입니다.",
  "이 범위 기반 'for' 문의 반복기 형식이 포인터 형식 또는 반복기와 유사한 클래스 형식이 아닌 %t입니다.",
  "범위 기반의 'for' 문은 알 수 없는 크기 또는 불완전한 형식의 %t 배열에 대해 수행할 수 없습니다.",
  "범위 기반의 'for' 문에서 사용된 'begin' 및 'end' 함수의 반환 형식은 동일해야 합니다('begin' 반환 형식: %t1, 'end' 반환 형식: %t2).",
  "제거된 임시 개체를 삭제하는 데 필요한 %nfd에 액세스할 수 없습니다.",
  "이 범위 기반의 'for' 문에는 인수 목록이 일치하는 %no의 인스턴스가 없습니다.",
  "이 범위 기반의 'for' 문에 필요한 %sq 함수를 찾을 수 없습니다.",
  "이 'for each' 문에 필요한 %sq 함수를 찾을 수 없습니다.",
  "%t에는 %[C++/CLI]을(를) 사용하여 표현할 수 없는 메타데이터 표현이 있습니다.",
  "'...'가 필요합니다.",
  "__implements 목록의 %t은(는) 인터페이스가 아닙니다.",
  "__implements 목록은 가상 함수 선언 앞에 와야 합니다.",
  "%t이(가) 해당 base 목록에서 '__implements ...'를 지정했는데 일치하는 __implements 목록이 없습니다.",
  "ref 또는 인터페이스 클래스 형식에 대한 핸들 역참조 결과를 사용해야 합니다.",
  null,
  "')'가 필요합니다. pragma가 무시됩니다.",
  "관리되는 클래스에는 using 선언 또는 액세스 선언이 표시될 수 없습니다.",
  "참조: %nd이(가) 호출되었을 수 있지만 액세스할 수 없으므로 고려되지 않았습니다.",
  "C++/CLI 관리되는 클래스의 추상 멤버 함수는 정의를 포함할 수 없습니다.",
  "이 단항 'operator*'를 선언하면 핸들 역참조의 의미가 변경될 수 있습니다. 적용 가능한 형식을 명시적으로 지정하려면 정적 멤버 연산자를 사용하십시오.",
  "관리",
  "C++/CX",
  "C++/CLI",
  "C++/CX 매핑",
  "기본값",
  "cli 매핑",
  "cli::array",
  "Platform::Array",
  "C++/CLI 배열",
  "C++/CX 배열",
  "시스템",
  "플랫폼",
  "gcnew",
  "ref new",
  "인터페이스 클래스는 비정적 데이터 멤버를 포함할 수 없습니다.",
  "기본 소스 파일에서 #pragma GCC system_header를 사용할 수 없습니다.",
  "%n이(가) 너무 커서 인라인할 수 있습니다.",
  " (암시적으로 선언됨)",
  "이동 작업을 제어하는 옵션은 C++를 컴파일하는 경우에만 사용할 수 있습니다.",
  "rvalue 생성자가 복사 생성자인 경우에는 이동 작업을 생성할 수 없습니다.",
  "rvalue 참조가 비활성화되어 있는 경우에는 이동 작업을 제어하는 옵션을 사용할 수 없습니다.",
  "관리되는 클래스는 'final'을 사용할 수 없습니다. 대신 'sealed'를 사용하세요.",
  "CLI 인터페이스 클래스 %t(으)로의 캐스트는 사용할 수 없습니다. -- 핸들로 캐스트하시겠습니까?",
  "CLI 인터페이스 클래스의 개체를 만들 수 없습니다.",
  "내부 형식이 호환되지 않으므로 이 선언이 %nd의 비표준 선언을 숨깁니다.",
  "피연산자가 null일 수 없으므로 포인터 비교 결과가 상수입니다.",
  "불완전한 형식 %t이(가) 지정된 개체의 값을 초기화할 수 없습니다.",
  "참조의 값을 초기화할 수 없습니다.",
  "'(' 또는 '{'가 필요합니다.",
  "copy-list-initialization은 'explicit'으로 표시된 생성자를 사용할 수 없습니다.",
  "void 형식의 멤버 포인터를 사용할 수 없습니다.",
  "참조 형식의 멤버 포인터를 사용할 수 없습니다.",
  "핸들 형식의 멤버 포인터를 사용할 수 없습니다.",
  "중괄호로 묶인 목록은 여기에서 사용할 수 없습니다.",
  "operator->* 멤버는 관리되는 클래스에서 사용할 수 없습니다.",
  "어셈블리 메타데이터가 존재하지 않는 어셈블리를 참조합니다.",
  "%sq2 특성이 이전 특성 %sq1과(와) 충돌합니다.",
  "%nd이(가) 이전에 다른 기본 형식을 사용하여 선언되었습니다.",
  "여기에서는 'enum class' 및 'enum struct'를 사용할 수 없습니다. 대신 일반 'enum'을 사용하세요.",
  "형식이 %t인 개체의 경우 이니셜라이저에 중괄호가 한 수준만 허용됩니다.",
  "%nd을(를) 열거형 형식 이름으로 사용할 수 없습니다.",
  null,
  "중괄호로 묶인 이니셜라이저는 'new auto'와 함께 사용할 수 없습니다.",
  "std::initializer_list의 정의에 필요한 생성자가 포함되어 있지 않습니다.",
  "선언에서 %nd을(를) 숨깁니다.",
  "std::initializer_list에 대한 잘못된 템플릿 매개 변수 목록으로, 기본값이 없는 하나의 일반 형식 매개 변수여야 합니다.",
  "중괄호로 묶인 목록은 가변 매개 변수에 대해 전달할 수 없습니다.",
  "#include <initializer_list>는 std::initializer_list의 사용(암시적 사용 포함) 전에 필요합니다.",
  "'inline' 키워드는 네임스페이스 별칭 선언에 사용할 수 없습니다.",
  "%n의 이전 선언이 인라인으로 선언되지 않았습니다.",
  "%n이(가) 이전에 인라인으로 선언됨",
  "첫 번째 인수는 정수 상수여야 합니다.",
  "지정자는 비집계 형식 %t과(와) 함께 사용할 수 없습니다.",
  "익명 공용 구조체 멤버의 지정자는 익명 공용 구조체에 해당하는 중괄호 내에만 표시될 수 있습니다.",
  "함수 프로토타입 태그는 C를 컴파일할 경우에만 사용할 수 있습니다.",
  "이 하위 개체 이니셜라이저에 대한 중괄호는 생략할 수 없습니다.",
  "%t1에서 %t2(으)로의 축소 변환이 잘못되었습니다.",
  "%t1에서 %t2(으)로의 축소 변환이 잘못되었습니다. 상수 값이 대상 형식에 맞지 않습니다.",
  "불완전한 배열 형식 %t(으)로 캐스트할 수 없습니다.",
  "%t1에서 %t2(으)로의 축소 변환이 잘못되었습니다. 상수 값을 대상 형식으로 정확하게 표현할 수 없습니다.",
  "비클래스 엔터티의 괄호로 묶인 이니셜라이저는 중괄호로 묶인 목록이 아니라 식이어야 합니다.",
  "중괄호로 묶인 목록은 이 람다에 대한 반환 형식을 제공하지 않습니다.",
  "선언된 예외 사양이 생성된 예외 사양과 호환되지 않습니다.",
  "범위가 지정된 열거형 형식이 C++11 기능입니다.",
  "함수 형식의 값은 초기화할 수 있습니다.",
  "%t 개체 형식의 list-initialization은 형식이 불완전하므로 허용되지 않습니다.",
  "std::initializer_list에 소멸자가 없어야 하는데 있습니다. 라이브러리가 잘못 구성되었습니다.",
  "명시적 열거형 기본 형식이 C++11 기능입니다.",
  "이 상수 식은 %t2 형식이어야 하지만 현재 %t1 형식입니다.",
  "기본 배열이 전체 식의 끝에서 삭제되므로 std::initializer_list 개체의 'new'가 올바르게 작동하지 않을 가능성이 있습니다.",
  "미리 정의된 매크로 파일에서",
  null,
  "'defined'는 Microsoft 모드의 매크로 확장에서 항상 false입니다.",
  "%t은(는) 완전한 개체 형식이 아니기 때문에 이니셜라이저 목록의 요소 형식일 수 없습니다.",
  "기본 인수 식에 일치하지 않는 구분 기호가 있습니다.",
  "멤버 포인터와 함수 포인터 간의 비표준 변환입니다.",
  "동적 예외 사양은 더 이상 사용되지 않습니다.",
  "현재 범위에서 %n을(를) 부분적으로 특수화할 수 없습니다.",
  "%nd이(가) 이전에 constexpr로 선언되었습니다.",
  "%nd이(가) 이전에 constexpr로 선언되지 않았습니다.",
  "constexpr 변수에 대한 이니셜라이저가 없습니다.",
  "'constexpr'은 여기에 사용할 수 없습니다.",
  "constexpr 함수에는 return 문이 하나만 있어야 합니다.",
  "constexpr 함수에는 문을 사용할 수 없습니다.",
  "constexpr 생성자에는 문을 사용할 수 없습니다.",
  "이 모드에서 함수가 동시에 constexpr 및 virtual일 수는 없습니다.",
  "constexpr 함수에는 비리터럴 반환 형식 %t을(를) 사용할 수 없습니다.",
  "constexpr 함수에는 비리터럴 형식 %t의 매개 변수를 사용할 수 없습니다.",
  "식에서 %n을(를) 비순차적으로 사용하면 정의되지 않은 결과가 생성될 수 있습니다.",
  "__builtin_assumed_aligned에 대한 호출의 선택적 세 번째 인수는 정수 형식이어야 합니다.",
  "소멸자는 constexpr일 수 없습니다.",
  "mmap에 제공된 주소는 페이지 경계에 맞춰야 합니다. %s",
  "constexpr 생성자의 본문은 함수 try 블록일 수 없습니다.",
  "constexpr %nf이(가) 다음에 대한 이니셜라이저를 제공하지 않습니다.",
  "%n",
  "%t에 대한 기본 생성자를 호출하면 상수 값이 생성되지 않습니다.",
  "%t에 대한 기본 생성자가 constexpr이 아닙니다.",
  "constexpr 변수는 리터럴 형식이거나 참조 형식이어야 합니다.",
  "가상 기본이 있는 클래스의 생성자는 constexpr일 수 없습니다.",
  "함수를 호출하려면 상수 식에 상수 값이 있어야 합니다.",
  "'main' 함수는 constexpr로 선언할 수 없습니다.",
  null,
  "클래스 또는 열거형 형식 정의는 constexpr 함수 또는 생성자 본문에 사용할 수 없습니다.",
  "여기에는 GNU 스타일의 특성만 허용됩니다.",
  "이니셜라이저에서 형식을 추론하고 후행 반환 형식을 알리는 'auto'의 비표준 사용입니다.",
  "정규화된 void 형식의 void 매개 변수 목록 선언은 표준이 아닙니다.",
  "이 지역 선언의 한정자는 무시됩니다.",
  "이 상수 식은 %s 형식이어야 하지만 현재 %t1 형식입니다.",
  "__bases 또는 __direct_bases를 인스턴스화하려면 클래스 형식이 있어야 합니다.",
  "__bases 및 __direct_bases의 인수는 형식 템플릿 매개 변수여야 합니다.",
  "%s은(는) 템플릿 컨텍스트에서만 사용할 수 있습니다.",
  "constexpr 함수 반환은 비상수입니다.",
  "constexpr 생성자는 constexpr이 아닌 %n을(를) 호출합니다.",
  "%n의 이니셜라이저가 상수 식이 아니므로 생성자는 constexpr일 수 없습니다.",
  "constexpr 생성자의 비상수 이니셜라이저입니다.",
  "%t에 대해 생성된 기본 생성자는 자체 데이터 멤버의 이니셜라이저에 사용할 수 없습니다.",
  "%n의 이니셜라이저 인스턴스화는 자체 값에 종속됩니다.",
  "암시적으로 선언된 해당 기본 생성자가 constexpr이 아니므로 기본값으로 설정된 기본 생성자는 constexpr일 수 없습니다.",
  null,
  "잘못된 이진 숫자",
  "공용 구조체에는 하나의 필드 이니셜라이저만 사용할 수 있습니다(%nd에도 이니셜라이저가 있음).",
  null,
  "공용 구조체의 constexpr 생성자는 해당 필드 중 하나를 초기화해야 합니다.",
  "constexpr 생성자가 익명 공용 구조체(정의된 %p)를 초기화하지 못합니다.",
  "constexpr 정적 데이터 멤버 선언에는 in-class initializer가 필요합니다.",
  "최대 constexpr 수준/개수 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "과도한 constexpr 함수 호출 복잡성으로 인해 식이 상수로 접히지 않았습니다.",
  "제한 없는 공용 구조체 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "constexpr 생성자는 직접 기본 클래스 %t을(를) 초기화해야 합니다.",
  "기본 배열이 전체 식의 끝에서 삭제되므로 필드 이니셜라이저에서 std::initializer_list 개체 만들기가 올바르게 작동하지 않을 가능성이 있습니다.",
  "'this'는 상수 식에 사용할 수 없습니다.",
  null,
  "'constexpr'은 명시적 인스턴스화 지시문에서 사용할 수 없습니다.",
  "순환 종속성으로 인해 기본 생성자의 예외 사양을 확인할 수 없습니다.",
  "익명 공용 구조체 정의 %p",
  "이 생성자는 %nd의 이니셜라이저를 사용합니다. 이로 인해 바인딩되지 않은 재귀가 발생할 수 있습니다.",
  null,
  "extern 변수의 지역 선언에는 이니셜라이저를 사용할 수 없습니다.",
  "명명된 레지스터 변수의 지역 선언에는 이니셜라이저를 사용할 수 없습니다.",
  null,
  "Microsoft 모드에서는 제한 없는 공용 구조체를 사용하도록 설정할 수 없습니다.",
  "생성자가 직접 또는 간접적으로 자신에게 위임합니다.",
  "위임하는 생성자는 다른 mem-initializer를 포함할 수 없습니다.",
  "ref-qualifier를 여기에 사용할 수 없습니다.",
  "매개 변수 형식이 같은 멤버 함수 두 개를 오버로드하려면 둘 다 ref-qualifier가 있거나 둘 다 ref-qualifier가 없어야 합니다.",
  "원시 문자열 구분 기호의 문자가 잘못됐습니다.",
  "16자 이내에 원시 문자열 구분 기호를 종료하는 괄호가 없습니다. 원시 문자열 표시기가 무시됩니다.",
  "원시 문자열의 종료 구분 기호를 찾을 수 없습니다.",
  "매개 변수 팩은 부분 특수화의 최종 템플릿 인수여야 합니다.",
  "형식이 %t인 멤버 포인터 함수는 lvalue 개체와만 사용할 수 있습니다.",
  "형식이 %t인 멤버 포인터 함수는 rvalue 개체와만 사용할 수 있습니다.",
  "기본 또는 멤버 복사 생성자 매개 변수가 비const이므로 기본값으로 설정된 복사-생성자의 매개 변수는 const일 수 없습니다.",
  "기본 또는 멤버 복사 할당 매개 변수가 비const이므로 기본값으로 설정된 이 대입 연산자의 매개 변수는 const일 수 없습니다.",
  "익명 공용 구조체에는 비정적 데이터 멤버가 하나 이상 있어야 합니다.",
  "'delegating_constructors' 옵션에는 다른 컴파일러 구성이 필요합니다.",
  "맞춤에서 환산(reduction)이 무시됩니다.",
  "rvalue 참조 형식에 대한 const_cast의 피연산자는 비클래스 prvalue일 수 없습니다.",
  "식은 lvalue 또는 xvalue여야 합니다.",
  "변환으로 값이 변경될 수 있습니다.",
  "문자열 리터럴에서 'char *'으로의 변환은 사용되지 않습니다.",
  "문자열 리터럴에서 pointer-to-character(비const)로의 변환은 사용되지 않습니다.",
  "'override' 및 'final'은 C++11 기능입니다.",
  "rvalue 참조는 예외 사양 형식으로 사용할 수 없습니다.",
  "%sq 특성이 처리기 매개 변수에 적용되지 않았습니다.",
  "%sq 특성에는 처리기 매개 변수가 필요합니다.",
  "alignas는 여기에 적용되지 않습니다.",
  "표준 'alignof' 연산자에는 식 인수가 사용되지 않으며 대신 형식이 사용됩니다.",
  "%t에 대한 한정자가 잘못되었습니다(여기에는 파생 클래스를 사용할 수 없음).",
  "'always_inline' 특성이 인라인 함수가 아닌 함수에서 무시되었습니다.",
  "상속 생성자는 직접 기본 클래스에서 상속되어야 합니다.",
  null,
  "레이블이 필요합니다.",
  "'%%l' 다음에는 피연산자 숫자가 필요합니다.",
  "'%%l'의 피연산자 숫자가 올바른 레이블 인수를 참조하지 않습니다.",
  "와이드 문자열은 'asm' 문에서 유효하지 않습니다.",
  "특성이 비표준입니다.",
  "%t 클래스의 기본 클래스가 아닙니다.",
  "사용자 정의 리터럴 접미사에 비식별자 문자가 있습니다.",
  "다중 문자 리터럴은 사용자 정의 리터럴의 일부일 수 없습니다.",
  "사용자 정의 리터럴 접미사가 이전의 %sq과(와) 일치하지 않습니다.",
  "잘못된 리터럴 연산자 이름입니다.",
  "사용자 정의 리터럴 연산자가 없습니다.",
  "모호한 리터럴 연산자 및/또는 리터럴 연산자 템플릿:",
  "리터럴 연산자는 클래스의 멤버일 수 없습니다.",
  "리터럴 연산자에는 extern 'C' 이름 연결이 포함될 수 없습니다.",
  "리터럴 연산자에는 매개 변수가 하나 이상 있어야 합니다.",
  "이 리터럴 연산자의 매개 변수가 너무 많습니다.",
  "리터럴 연산자의 매개 변수 형식 %t이(가) 잘못되었습니다.",
  "리터럴 연산자의 정수 매개 변수 형식(%t)이 잘못되었습니다. 문자 형식 또는 unsigned long long 형식이어야 합니다.",
  "리터럴 연산자의 부동 소수점 매개 변수 형식(%t)이 잘못되었습니다. long double 형식이어야 합니다.",
  "리터럴 연산자의 첫 번째 매개 변수 형식(%t)이 잘못되었습니다. 비const 형식에 대한 포인터는 사용할 수 없습니다.",
  "리터럴 연산자의 두 번째 매개 변수 형식(%t)이 잘못되었습니다. size_t여야 합니다.",
  "리터럴 연산자의 포인터 매개 변수 형식(%t)이 잘못되었습니다. 문자 형식에 대한 포인터여야 합니다.",
  "리터럴 연산자에는 줄임표 매개 변수가 포함될 수 없습니다.",
  "리터럴 연산자 템플릿에는 매개 변수가 포함될 수 없습니다.",
  "리터럴 연산자 템플릿에는 '<char ...>'에 해당하는 템플릿 매개 변수 목록이 있어야 합니다.",
  "스레드 로컬 스토리지 클래스는 여기에서 유효하지 않습니다.",
  "스레드 로컬 선언은 비스레드 로컬 선언 뒤에 옵니다(%p(으)로 선언됨).",
  "비스레드 로컬 선언은 스레드 로컬 선언 뒤에 옵니다(%p(으)로 선언됨).",
  "리터럴 연산자에는 기본 인수가 포함될 수 없습니다.",
  "스레드 로컬 변수의 특성이 무시됩니다.",
  "사용자 제공 리터럴 접미사는 '_'으로 시작해야 합니다.",
  "rvalue 참조는 C++11 기능입니다.",
  "람다 식은 C++11 기능입니다.",
  "표준 특성 구문은 C++11 기능입니다.",
  "위임 생성자는 C++11 기능입니다.",
  "상속 생성자는 C++11 기능입니다.",
  "필드 이니셜라이저는 C++11 기능입니다.",
  "삭제된 함수는 C++11 기능입니다.",
  "기본값으로 설정된 함수는 C++11 기능입니다.",
  "스토리지 클래스는 명시적 특수화에 사용할 수 없습니다.",
  null,
  "특수화하려면 범위가 지정되지 않은 열거형이 불투명해야 합니다.",
  "열거형 템플릿 선언은 이전에 선언된 클래스 템플릿의 멤버를 참조해야 합니다.",
  "벡터 피연산자가 필요합니다.",
  "순서 섞기 소스 피연산자의 형식 %t1 및 %t2이(가) 호환되지 않습니다.",
  "순서 섞기 마스크(형식 %t)가 정수 벡터가 아닙니다.",
  "순서 섞기 마스크(형식 %t1)의 길이가 소스 피연산자(형식 %t2)와 다릅니다.",
  "주소 값을 사용하여 정적 초기화를 수행하려면 주소와 같은 크기의 대상이 필요합니다.",
  "기능 테스트 매크로의 인수는 단순 식별자여야 합니다.",
  "기본 소스 파일에는 __has_include_next를 사용할 수 없습니다.",
  "__has_include_next에 절대 파일 이름이 사용되었습니다.",
  "%sq 특성을 함수 형식에 적용해야 합니다.",
  null,
  "여기에는 _Noreturn을 사용할 수 없습니다.",
  "%t이(가) 아닌 실수 부동 소수점 형식의 피연산자가 필요합니다.",
  "__builtin_complex에는 호환되는 형식의 피연산자가 필요합니다(%t1 및 %t2과(와) 다름).",
  "이 _Generic 선택에는 기본 연결이 이미 있습니다.",
  "여기에는 가변 길이 배열과 관련된 형식을 사용할 수 없습니다.",
  "_Generic 선택의 중복 연결 형식(%t)",
  "%t 선택기 형식과 일치하는 연결이 없습니다.",
  "%n (%t) 형식이 ifunc 확인자 형식과 호환되지 않습니다.",
  "한 함수에 ifunc 및 alias 특성을 모두 사용할 수 없습니다.",
  "한 함수에 ifunc 및 weak 특성을 모두 사용할 수 없습니다.",
  "호출하려면 문자열 리터럴 피연산자가 필요합니다.",
  "중복된 상속 생성자 선언(이전 %p)",
  "'decltype(auto)'는 완전한 변수 형식에 대한 구성 요소가 아니라 자리 표시자여야 합니다.",
  "여기에는 decltype(auto)을 사용할 수 없습니다.",
  "'decltype(auto)'을 추론할 수 없습니다(이니셜라이저 필요).",
  "'decltype(auto)' 형식을 추론할 수 없습니다.",
  "블록 범위 스레드 로컬 선언에는 staic 또는 extern이 포함되어야 합니다.",
  "추론된 반환 형식 %t1이(가) 이전에 추론된 형식 %t2과(와) 충돌합니다.",
  "반환 형식 %nd;을(를) 추론할 수 없습니다. 정의되지 않았습니다.",
  "가상 함수에는 추론된 반환 형식을 사용할 수 없습니다.",
  "%n은(는) 이 시점부터 대/소문자 구분 키워드로 취급됩니다.",
  "전역 네임스페이스에 실제 멤버 %sq이(가) 없습니다.",
  "두 개의 다른 열거형 형식(%t1, %t2) 간 비교",
  "대상 특성을 인식할 수 없습니다.",
  "'default' 대상 함수가 없습니다.",
  "arch= target을 하나만 지정할 수 있습니다.",
  "제네릭 클래스는 사용자 지정 특성일 수 없습니다.",
  "잘못된 특성 대상 %sq입니다.",
  "모호한 특성입니다. %t1과(와) %t2을(를) 모두 사용할 수 있습니다.",
  "명명된 특성 인수는 public 비정적 읽기/쓰기 필드 또는 스칼라 속성만 참조할 수 있습니다.",
  "명명된 특성 인수는 특성 매개 변수 형식의 비정적 필드 또는 스칼라 속성만 참조할 수 있습니다.",
  "잘못된 특성 인수입니다. 식은 특성 매개 변수 형식의 상수여야 합니다.",
  "특성 인수에는 제네릭 형식 매개 변수를 사용할 수 없습니다.",
  "%t은(는) 독립 실행형 특성으로만 사용할 수 있습니다.",
  "'field' 특성 대상은 특수한 속성/이벤트에 사용할 수 없습니다.",
  "독립 실행형 특성에 대해 잘못된 특성 대상입니다.",
  "이 컨텍스트에 대해 잘못된 특성 대상입니다.",
  "여기에는 %t 특성을 사용할 수 없습니다.",
  "%t은(는) 사용되지 않습니다. 매개 변수 배열을 지정하려면 '...'을 사용하세요.",
  "기본 네임스페이스는 확장할 수 없습니다.",
  "boxed 형식은 값 클래스 또는 열거형이어야 합니다.",
  "값 클래스에 대한 추적 참조는 사용할 수 없습니다.",
  "값 클래스에 대한 핸들은 사용할 수 없습니다.",
  "열거형에 대한 추적 참조는 사용할 수 없습니다.",
  "열거형에 대한 핸들은 사용할 수 없습니다.",
  "public 네이티브 형식은 사용할 수 없습니다.",
  "public 중첩 형식은 사용할 수 없습니다.",
  "C++/CX에서 제네릭 형식은 허용되지 않습니다.",
  "C++/CX에서 제네릭 메서드는 허용되지 않습니다.",
  "제네릭 제약 조건은 사용할 수 없습니다.",
  "public C++/CX 값 형식에서는 public이 아닌 데이터 멤버를 사용할 수 없습니다.",
  "public C++/CX 값 형식에서는 public 비데이터 멤버를 사용할 수 없습니다.",
  "public C++/CX 값 형식에서는 생성자를 사용할 수 없습니다.",
  "'add' 접근자의 반환 형식은 Windows::Foundation::EventRegistrationToken이어야 합니다.",
  "'remove' 접근자의 반환 형식은 void이어야 합니다.",
  "'remove' 접근자의 매개 변수 형식은 Windows::Foundation::EventRegistrationToken이어야 합니다.",
  "제네릭 매개 변수 형식에 대한 핸들 또는 참조는 사용할 수 없습니다.",
  "public 데이터 멤버는 값이 아닌 형식에서 사용할 수 없습니다.",
  "C++/CX는 Microsoft C++ 모드에서만 사용할 수 있습니다.",
  "C++/CLI 및 C++/CX 모드는 함께 사용할 수 없습니다.",
  "%sq을(를) 사용하려면 C++/CX 모드여야 합니다.",
  "C++/CX 모드에서는 microsoft_version이 1,600보다 크거나 같아야 합니다.",
  "C++/CX에서는 리터럴 필드를 사용할 수 없습니다.",
  "표준 참조는 C++/CX 형식에 바인딩할 수 없습니다.",
  "형식은 Platform::Boolean, default::uint8, default::int8, default::int16, default::uint16, default::int32, default::uint32, default::int64 또는 default::uint64와 일치해야 합니다.",
  "C++/CX 값 형식에는 이벤트를 사용할 수 없습니다.",
  "핸들 형식에 대한 dynamic_cast는 완전한 클래스 형식을 참조해야 합니다.",
  "Platform::Array는 1차원이어야 합니다.",
  "표준 클래스 형식에 대한 참조는 추적할 수 없습니다.",
  "C++/CX 값 형식은 인터페이스에서 상속할 수 없습니다.",
  "C++/CX 값 형식은 가상 함수를 포함할 수 없습니다.",
  "'partial'은 전역 범위 또는 네임스페이스 범위에서 'ref class' 또는 'ref struct'에만 적용할 수 있습니다.",
  "'set' 접근자의 매개 변수는 'const Platform::Array<T>^' 형식이어야 합니다.",
  "공용 C++/CX 형식의 정의는 전역 범위에서 사용할 수 없습니다.",
  "공용 'get' 또는 'set' 접근자를 포함한 인덱싱된 속성은 사용할 수 없습니다.",
  "공용 중첩 대리자 형식은 사용할 수 없습니다.",
  "잘못된 대리자 이니셜라이저입니다. '(<function-address 또는 functor-object> [, Platform::CallbackContext])' 또는 '(<object handle>, <member-address> [, Platform::CallbackContext [, bool]])'이 필요합니다.",
  "잘못된 대리자 이니셜라이저입니다. 개체가 %[managed] 클래스에 대한 핸들이어야 합니다.",
  "C++/CX에서 'in/out' 배열을 지원하지 않습니다. 공용 API에서는 'in'에 'const Platform::Array<T>^'를 'out'에 'Platform::WriteOnlyArray<T>^' 또는 'Platform::Array<T>^*'를 사용하세요.",
  "%nd에 대한 'target' 특성이 없습니다.",
  "선언된 멤버 함수가 %n의 'target' 특성과 일치하지 않습니다.",
  "이 위치의 Microsoft 특성은 인터페이스 형식에만 허용됩니다.",
  "GNU 함수 다중 버전 확인자 루틴이 필요합니다.",
  "관리되는 클래스에서 선언된 열거형 형식에는 정의가 포함되어야 합니다.",
  "decltype 정규화된 이름은 이 선언 컨텍스트에서 표준이 아닙니다.",
  "비가상 함수는 '최종' 한정자를 사용하여 선언할 수 없습니다.",
  "특수 함수의 '대상' 특성은 지원되지 않습니다.",
  "반각 문자열 리터럴이어야 함",
  "짝이 맞지 않는 괄호",
  "해당하는 'push_options'가 없음",
  "이 pragma는 함수 내에서 사용할 수 없습니다.",
  "new 또는 delete 연산자 'inline'의 선언은 표준이 아닙니다.",
  "데이터 멤버에 대한 mem-initializer는 팩 확장일 수 없습니다.",
  "일반 람다 식은 이 모드에서 캡처 기본값을 가질 수 없습니다.",
  "friend 선언의 기본 템플릿 인수는 정의에만 지정될 수 있습니다.",
  "기본 템플릿 인수가 있는 friend 템플릿 선언이 유일한 선언이어야 합니다(첫 번째 선언된 %p).",
  "불투명 열거형 선언은 다른 선언의 일부일 수 없습니다.",
  "불투명 열거형 선언은 이 컨텍스트에서 표준이 아닙니다.",
  "확장된 friend 구문은 C++11 기능입니다.",
  "숫자 구분 기호를 사용할 수 없고 아포스트로피는 문자 리터럴을 시작합니다.",
  "숫자 구분 기호는 여기에 표시될 수 없습니다.",
  "'constexpr'은 여기 Microsoft 모드에서는 무시됩니다.",
  "문 식 결과에 대한 식이 잘못되었습니다.",
  "식별자가 매크로이며 리터럴 접미사가 아닙니다.",
  "%nd은(는) lvalue에서 호출할 수 없습니다.",
  "%nd은(는) rvalue에서 호출할 수 없습니다.",
  "멤버 함수는 lvalue에서 호출할 수 없습니다.",
  "멤버 함수는 rvalue에서 호출할 수 없습니다.",
  "템플릿 매개 변수 목록이 너무 깁니다.",
  "별칭 템플릿 형식 %t1은(는) %nfd의 재선언에 있는 이전 형식 %t2과(와) 호환되지 않습니다.",
  "%nd에 대한 필드 이니셜라이저가 상수 식이 아닙니다.",
  "각 제약 조건 문자열의 피연산자 제약 조건 수가 같아야 합니다.",
  "제약 조건 문자열에 대체 제약 조건이 너무 많이 포함되어 있습니다. 일부 제약 조건이 확인되지 않았습니다.",
  "불완전한 클래스 %t을(를) 통한 호출을 인스턴스화하면 항상 오류가 생성됩니다.",
  "decltype(auto)는 형식 한정자를 추가할 수 없습니다.",
  "init-capture %nod은(는) 여기서 캡처할 수 없습니다.",
  "%t 형식의 잘못된 비형식 템플릿 인수",
  "abi_tag 특성은 C 모드에서 의미가 없으므로 무시됩니다.",
  "재선언에서 abi_tag 특성 '%s'을(를) 추가합니다.",
  "abi_tag 특성은 later abi_tag 특성으로 대체되므로 무시됩니다.",
  "%nd의 이전 선언에 abi_tag 특성이 없습니다.",
  "(이전 선언 %p 참조)",
  "abi_tag 특성은 특수화에서 무시됩니다.",
  "decltype(auto)는 포인터, 참조 또는 멤버 포인터 구문 아래에 표시될 수 없습니다.",
  "'class' 또는 'typename' 필요",
  "배치 'new' 식은 비배치 %nd를 참조합니다.",
  "런타임 라이브러리를 빌드할 때는 C++14 모드를 지정해야 합니다.",
  "%s",
  "명령줄 경고",
  "명령줄 경고",
  "C++14에서는 constexpr 비정적 멤버 함수가 암시적으로 'const'하지 않습니다.",
  "constexpr 함수의 변수 형식 %t이(가) 리터럴 형식이 아닙니다.",
  "constexpr 함수의 변수에 자동 저장 기간이 없습니다.",
  "constexpr 함수에 있는 변수의 초기화가 취소되었습니다.",
  "자리 표시자 형식은 있으나 `=`는 없이 선언된 변수의 중괄호 초기화에서는 중괄호 안에 정확히 하나의 요소가 있어야 합니다.",
  "'%s' 없음 --대상 구성이 존재함",
  "64비트 x86 구성에서 지원되지 않는 특성",
  "'%s'에 인수 필요",
  "생성자 또는 소멸자는 코루틴일 수 없습니다.",
  "%n은(는) 코루틴일 수 없습니다.",
  "catch 절에서는 co_yield 식이 허용되지 않습니다.",
  null,
  null,
  null,
  null,
  "%sq 클래스 템플릿이 없음",
  "'typename' 키워드를 사용하여 %n을(를) 종속 컨텍스트에서 형식으로 취급",
  "인수 값이 벡터 요소의 합계보다 작아야 함",
  "%t에 멤버 %sq이(가) 없음",
  "중괄호로 묶인 목록이 반환 형식을 제공하지 않음",
  "co_await 식은 함수 범위에 있어야 합니다.",
  "co_await 식은 catch 절 내부에 허용되지 않습니다.",
  "코루틴에는 가변 매개 변수(...)가 있을 수 없습니다.",
  "C++14-style constexpr을 사용하려면 'bool'을 지원해야 합니다.",
  "constexpr %nd이(가) 정의되지 않음",
  "대상 함수 %nd이(가) constexpr이 아니거나 아직 완전히 정의되지 않아 이 호출을 확인할 수 없습니다.",
  "참고",
  "참고",
  "잘못된 익명 공용 구조체 -- 별칭 멤버 템플릿을 사용할 수 없습니다.",
  "UTF-8 문자 리터럴 값은 코드 단위 둘 이상에 지정할 수 없습니다.",
  "%nd 값을 상수로 사용할 수 없습니다.",
  "%nd에 대한 포인터 또는 참조를 상수로 사용할 수 없습니다.",
  "배열이 아닌 개체의 0이 아닌 첨자",
  "%d2개 요소의 배열에서 %d1 위치에 액세스할 수 없습니다.",
  "호출한 위치:",
  "비활성 공용 구조체 %n1에 대한 액세스가 잘못되었습니다(%n2이(가) 활성).",
  "constexpr 컨텍스트에서는 'goto'를 실행할 수 없습니다.",
  "반환 값 없음",
  "호출 수신자가 null입니다.",
  "null 포인터를 역참조하려고 합니다.",
  "%d개 요소의 배열 끝에서 한 위치 이전에 있는 스토리지에 액세스하려고 합니다.",
  "만료된 스토리지에 액세스하려고 합니다.",
  "런타임 스토리지에 액세스하려고 합니다.",
  null,
  "constexpr이 아닌 %nd을(를) 호출할 수 없습니다.",
  "constexpr 평가 중 가변 길이 배열을 사용할 수 없습니다.",
  "음의 이동을 수행할 수 없습니다.",
  "이동 크기(%d)가 너무 큽니다.",
  "값이 %t의 범위를 초과합니다.",
  "부동 소수점 오류",
  "null 멤버 포인터(데이터 멤버)를 역참조하려고 합니다.",
  "void에 대한 포인터 및 함수에 대한 포인터 비교가 표준이 아닙니다.",
  "메타데이터 초기화 실패",
  "기본에서 파생으로의 캐스트가 잘못되었습니다(완전한 클래스 형식은 %t임).",
  "완전한 형식 %t의 개체에서 %n에 대한 액세스가 잘못되었습니다.",
  "'__auto_type'은 여기에 사용할 수 없습니다.",
  "'__auto_type'에는 선언자를 여러 개 사용할 수 없습니다.",
  "'__auto_type'에는 '{...}'를 사용한 초기화를 사용할 수 없습니다.",
  "'__auto_type'은 완전한 변수 형식에 대한 구성 요소가 아니라 자리 표시자여야 합니다.",
  "'__auto_type'으로 선언된 변수에는 이니셜라이저가 필요합니다.",
  "정수 상수는 0보다 크거나 같아야 합니다.",
  "형식은 정수 형식이어야 합니다.",
  "식을 해석할 수 없습니다.",
  "문을 해석할 수 없습니다.",
  "해석기 스토리지의 주소를 잘못 사용했습니다.",
  "상수 식의 상수 종류가 잘못되었습니다.",
  "%t 형식이 너무 커서 상수 식을 계산할 수 없습니다.",
  "%t 형식이 잘못되어 상수 식을 계산할 수 없습니다.",
  "상수 식 계산에서 %t1에서 %t2(으)로의 변환이 잘못되었습니다.",
  "부동 소수점을 변환하지 못했습니다.",
  null,
  "추론된 반환 형식은 C++14 기능입니다.",
  "연결된 소멸자가 있는 생성자는 평가할 수 없습니다.",
  "constexpr 평가 중 %n이(가) 초기화되지 않았습니다.",
  "constexpr 평가에 잘못된 포인터 차이가 있습니다.",
  "비배열 포인터에 대한 잘못된 산술 연산",
  "첫 번째 배열 요소 앞에 포인터를 설정할 수 없습니다.",
  "추론된 반환 형식의 코루틴이 잘못되었습니다.",
  "확인되지 않은 컨텍스트에서는 식이 허용되지 않습니다.",
  null,
  null,
  "코루틴에서는 'return'이 허용되지 않습니다(대신 'co_return' 사용).",
  "'co_return'은 코루틴에서만 허용됩니다.",
  "부동 소수점 값은 비교할 수 없습니다.",
  "포인터 값이 동일한 완전 개체를 가리키지 않거나 접근성이 다른 하위 개체를 가리키므로 값을 비교할 수 없습니다.",
  "인라인이 아닌 네임스페이스에서는 abi_tag 특성을 무시합니다.",
  "익명 네임스페이스에서는 abi_tag 특성을 무시합니다.",
  "복합 또는 가상 템플릿 매개 변수 형식은 표준이 아닙니다.",
  "함수 범위 밖에서는 co_yield 식이 허용되지 않습니다.",
  "익명 공용 구조체에서는 스레드 로컬 표시를 무시합니다.",
  null,
  "변수 템플릿",
  "초기화되지 않은 개체에 액세스합니다.",
  "휘발성 스토리지에서 읽으려고 합니다.",
  "비활성 공용 구조체 %n1에 대한 액세스가 잘못되었습니다(활성화된 필드 없음).",
  "constexpr 함수에 레이블 정의가 나타날 수 없습니다.",
  "배열 끝을 지난 포인터를 다른 완전한 개체에 대한 포인터와 비교할 수 없습니다.",
  "함수 형식 %t은(는) 변수 템플릿 인스턴스화에서 잘못된 형식입니다.",
  "변수가 불완전한 형식 %t일 수 없습니다.",
  "초기화되지 않은 하위 개체(%n)에 액세스합니다.",
  "초기화되지 않은 하위 개체에 액세스합니다(기본 클래스 %t).",
  "상수 식에는 의사(pseudo) 소멸자 호출을 사용할 수 없습니다.",
  "const 스토리지를 수정하려고 합니다.",
  null,
  null,
  "한 요소의 배열로 처리되는 개체를 지난 한 위치에 있는 스토리지에 액세스하려고 합니다.",
  "constant-expression 실행에서 reinterpret_cast를 사용할 수 없습니다.",
  "null 포인터에서 연산을 사용할 수 없습니다.",
  "*this의 값은 상수로 사용할 수 없습니다.",
  "'인라인' 키워드는 중첩된 네임스페이스 선언에 사용할 수 없습니다.",
  "'carries_dependency' 특성은 무시됩니다.",
  "'__event __interface'에는 정의를 포함할 수 없습니다.",
  "이벤트 처리기의 반환 형식은 void 또는 정수여야 합니다.",
  "'__event __interface'가 이전에 정의되어 있어야 합니다.",
  "%n에 대한 템플릿 인수가 너무 많습니다.",
  "열거자가 이미 선언되었습니다(%nd 참조).",
  "에뮬레이트되는 Microsoft 버전이 1903 이상이어야 '--ms_c++14'를 사용할 수 있습니다.",
  "'--ms_c++latest'를 사용하려면 에뮬레이트되는 Microsoft의 버전이 1903 이상이어야 합니다.",
  "%t 형식은 배열 또는 함수 형식이므로 _Atomic일 수 없습니다.",
  "정규화된 형식 %t에는 _Atomic(...) 지정자를 적용할 수 없습니다.",
  "_Atomic 개체의 멤버에 액세스",
  "비트 필드에는 _Atomic 형식을 사용할 수 없습니다.",
  "_Atomic 클래스 형식을 사용할 수 없습니다.",
  "constexpr 생성자는 하위 개체 초기화를 위해 constexpr이 아닌 생성자를 호출합니다.",
  "쉼표가 필요합니다(static_assert의 1개 인수 버전은 이 모드에서 사용할 수 없도록 설정됨).",
  "정적 어설션이 실패했습니다.",
  "최대 하나의 _Nullable, _Nonnull 및 _Null_unspecified 한정자가 형식을 수정할 수 있습니다.",
  "null 허용 여부 한정자는 포인터 및 멤버 포인터 형식에서만 사용할 수 있습니다.",
  "벡터 길이가 너무 깁니다.",
  "벡터 요소 형식은 정수, 열거형 또는 실수 부동 소수점 형식이어야 합니다.",
  "128비트 정수가 지원되지 않으므로 기본 제공 함수를 사용할 수 없습니다.",
  "벡터 형식이 지원되지 않으므로 기본 제공 함수를 사용할 수 없습니다.",
  "연속하는 두 개의 왼쪽 대괄호에는 항상 특성 목록이 들어가지만 특성 목록을 여기에 표시할 수 없음",
  "인식할 수 없는 '대상' 특성은 확인자 루틴에서 사용하지 못하도록 이 루틴의 자격을 취소합니다.",
  "%t은(는) 벡터 형식이 아닙니다.",
  "벡터 형식 %t1 및 %t2의 길이가 같아야 합니다.",
  "추가한 기본 인수로 기본 또는 복사 생성자를 선언할 수 없습니다.",
  "참조 형식의 비형식 템플릿 인수는 함수 또는 전체 개체에 바인딩해야 합니다.",
  "여기에서 %t을(를) 사용할 수 없습니다.",
  "'register' 스토리지 클래스 지정자를 사용할 수 없습니다.",
  "'register' 스토리지 클래스 지정자를 사용할 수 없습니다.",
  "bool 값 증분을 사용할 수 없습니다.",
  "범위 기반 'for' 문의 반복기로 선언된 %sq은(는) 이 범위에서 다시 선언할 수 없습니다.",
  "특성 네임스페이스를 여기에 사용할 수 없습니다('using' 접두사가 지정되었기 때문에).",
  "%sq 특성 네임스페이스를 인식할 수 없습니다.",
  "기본 멤버 이니셜라이저를 값 클래스에서 사용할 수 없습니다.",
  "'--implicit_noexcept'에는 noexcept를 사용할 수 있는 모드가 필요합니다.",
  "가상 기본 클래스(%t)와 관련된 작업을 접을 수 없습니다.",
  "초기화가 상수가 아닙니다.",
  "불완전한 %t의 값을 평가할 수 없습니다.",
  "'nodiscard' 특성으로 선언된 루틴의 반환 값을 무시합니다.",
  "'nodiscard' 특성이 있는 반환 값 형식을 무시합니다.",
  "'nodiscard' 특성은 void 반환 형식을 사용하는 소멸자 또는 루틴에 적용되지 않습니다.",
  "'fallthrough' 특성은 null 문에만 적용됩니다.",
  "'fallthrough' 특성은 바깥쪽 switch 문에만 사용할 수 있습니다.",
  "fallthrough 문은 switch case label 또는 default 앞에 와야 합니다.",
  "수명이 제한된 임시 변수에 대한 참조 또는 포인터입니다.",
  "조건이 무조건 true가 아닌 'enable_if' 특성이 있는 함수의 주소를 사용할 수 없습니다.",
  "상수 값이 아닌 조건이 있는 'enable_if' 특성은 현재 지원되지 않습니다.",
  "여기서 특성이 선언되었습니다.",
  "__has_include는 #if 외부에 사용할 수 없습니다.",
  "CComCoClass 기본 클래스를 추가할 수 없습니다.",
  "null로 종료되는 문자열 아님",
  "스칼라가 아닌 형식 %t은(는) 의사(pseudo) 소멸자 호출에서 사용할 수 없습니다.",
  "'weak' %n의 주소가 상수가 아닙니다.",
  "함수 템플릿 시그니처의 재귀적 대체가 너무 많습니다.",
  "구조적 바인딩 선언에 대해 잘못된 지정자입니다.",
  "잘못된 구조적 바인딩 구문입니다.",
  "이니셜라이저가 없습니다.",
  "%t 형식에 바인딩할 구성 요소가 없습니다.",
  "식별자가 너무 많습니다.",
  "바인딩 이름보다 요소가 더 많습니다.",
  "'std::tuple_element'가 정의되지 않습니다.",
  "<%s, %t>에 대해 'std::tuple_element'를 인스턴스화할 수 없습니다.",
  "%t 형식에 대해 멤버 함수 'get<%s>()'을 호출할 수 없습니다.",
  "인수 목록이 일치하는 %no의 인스턴스가 없습니다.",
  "이 구조적 바인딩에는 적합한 %sq 함수가 필요하지만 아무것도 검색되지 않았습니다.",
  "구조적 바인딩에서는 'inline'을 선언할 수 없습니다.",
  "구조적 바인딩에서는 'constexpr'을 선언할 수 없습니다.",
  "구조적 바인딩은 명시적 스토리지 클래스를 선언할 수 없습니다.",
  "std::tuple_size<%t>::값은 유효한 정수 계열 상수 식이 아닙니다.",
  "조건 선언은 변수를 선언해야 합니다.",
  "조건 선언에 이니셜라이저가 포함되어야 합니다.",
  "괄호로 묶인 이니셜라이저는 조건 선언에 허용되지 않습니다.",
  "조건 선언은 하나의 변수만 선언할 수 있습니다.",
  "구조적 바인딩은 Closure 형식에 바인딩할 수 없습니다.",
  "public이 아닌 %n에 바인딩할 수 없습니다.",
  "불완전한 형식 %t에 바인딩할 수 없습니다.",
  "여기에서 이 선언은 잘못되었습니다.",
  "constexpr 함수의 본문은 함수 try 블록일 수 없습니다.",
  "블록이 허용되지 않는 경우 constexpr로 컨트롤을 전송합니다.",
  "구조적 바인딩에서는 캡처할 수 없습니다.",
  "에뮬레이트되는 Microsoft 버전이 1911 이상이어야 '--ms_c++17'을 사용할 수 있습니다.",
  "개체 끝을 넘어 읽으려고 합니다.",
  "이 모드에서 constexpr 람다를 사용할 수 없습니다.",
  "상수 식에 람다 식을 포함할 수 없습니다.",
  "값이 템플릿 인수 개수를 초과합니다.",
  "이진 fold 식의 두 번째 연산자가 첫 번째 연산자와 일치하지 않습니다.",
  "잘못된 fold 식 연산자",
  "두 개의 매개 변수 팩에 이진 fold 식을 적용할 수 없습니다.",
  "빈 확장은 이 fold 식에 유효하지 않습니다.",
  "비정적 데이터 멤버는 인라인으로 선언할 수 없습니다.",
  "fold 식이 매개 변수 팩을 참조하지 않습니다.",
  "매개 변수 형식은 같지만 예외 사양이 다른 두 개의 함수를 오버로드할 수 없습니다.",
  "이 모드에서는 동적 예외 사양이 허용되지 않습니다.",
  null,
  "noexcept 지정자에 유효하지 않은 피연산자",
  "템플릿의 noexcept 지정자에 람다 식을 사용할 수 없습니다.",
  "%nfd에 액세스할 수 없습니다.",
  "열거형 템플릿 선언에 잘못된 지정자가 있습니다.",
  "이 구성에서는 80비트 부동 소수점 형식이 지원되지 않습니다.",
  "이 구성에서는 128비트 부동 소수점 형식이 지원되지 않습니다.",
  "잘못된 열거자 값",
  "_Atomic 정규화된 형식이어야 합니다.",
  "배열 요소의 형식이 완전해야 합니다.",
  "이 함수에 대해 always_inline 특성이 표시되지 않았습니다.",
  "여기에 음수 값을 사용할 수 없습니다.",
  "정수 팩 요소가 %n과(와) 일치할 수 없습니다.",
  "정수 팩 요소가 %n과(와) 일치할 수 없습니다.",
  "예기치 않은 지정자",
  "__builtin_offsetof를 평가할 수 없습니다.",
  "추론 가이드 %t을(를) 정의할 수 없습니다.",
  "추론 가이드를 %n과(와) 같은 범위에서 선언해야 합니다.",
  "추론 가이드 선언에 대해 잘못된 지정자입니다('explicit'만 허용됨).",
  "상수의 변경 가능한 %n은(는) 상수 식에서 액세스할 수 없습니다.",
  "함수 한정자는 정적 멤버 선언에 적용되지 않습니다.",
  "'overloadable' 특성에는 프로토타입화된 함수 선언이 필요합니다.",
  "%t2에서 'auto' 템플릿 매개 변수 형식 %t1을(를) 추론할 수 없습니다.",
  "클래스 템플릿 이름은 초기화되는 완전한 형식에 대한 구성 요소가 아니라 자리 표시자여야 합니다.",
  "별칭 선언은 C++11 기능입니다.",
  "별칭 템플릿은 C++11 기능입니다.",
  "반환 형식은 연결된 클래스 템플릿의 특수화를 직접 지정해야 합니다.",
  "copy-list-initialization은 'explicit' %n을(를) 사용할 수 없습니다.",
  "추론 가이드",
  "사용자 정의 리터럴 연산자에 대한 잘못된 값",
  "__has_cpp_attribute는 #if 또는 #elif 외부에 표시될 수 없습니다.",
  "추론 가이드를 %n과(와) 같은 접근성으로 선언해야 합니다.",
  "이 컨텍스트에서는 람다가 허용되지 않습니다.",
  "지정한 맞춤이 이전 선언과 일치하지 않습니다.",
  "정의에 지정된 맞춤이 없습니다. 이전 선언에서 맞춤을 지정했습니다.",
  "128비트 부동 소수점 형식이 지원되지 않으므로 기본 제공 함수를 사용할 수 없습니다.",
  "음수 값의 왼쪽 시프트에 정의되지 않은 동작이 있습니다.",
  "C++에서는 배열 지정자가 표준이 아닙니다.",
  "C++에서는 연결된 지정자가 표준이 아닙니다.",
  "지정되거나 지정되지 않은 이니셜라이저를 함께 사용하는 것은 C++의 표준이 아닙니다.",
  "잘못된 순서 이니셜라이저는 C++에서 표준이 아닙니다.",
  "문자열 리터럴 연산자 템플릿에는 '<typename T, T ...>'에 해당하는 템플릿 매개 변수 목록이 있어야 합니다.",
  "중복된 지정자를 사용할 수 없습니다.",
  "특성이 이전 likely/unlikely 특성과 충돌합니다.",
  "'this'의 암시적 by-copy 캡처는 사용되지 않습니다.",
  "람다 식에 빈 템플릿 매개 변수 목록을 사용할 수 없습니다.",
  "에뮬레이트되는 Microsoft 버전이 1920 이상이어야 '--ms_c++20'을 사용할 수 있습니다.",
  "STDC pragma 인수는 이 모드에서 사용할 수 없습니다.",
  "문이 C++17 기능인 경우 constexpr",
  "팩 확장은 지정된 이니셜라이저 목록에서 허용되지 않습니다.",
  "필드 지정자에 값이 없습니다.",
  "공용 구조체에는 하나의 필드 이니셜라이저만 사용할 수 있습니다.",
  "유효한 std 없음::%s 형식이 있음(<compare>를 포함해야 함)",
  "기본 제공 연산자 <=>의 잘못된 형식(%t1 및 %t2)",
  "fold 식은 이 모드에서 표준이 아닙니다.",
  "--current_directory 옵션을 통해 지정된 디렉터리는 %s 디렉터리가 아닙니다.",
  "PCH 경고",
  "전역 범위에 헤더 중지가 있어야 합니다. IntelliSense PCH 파일이 생성되지 않았습니다.",
  "매크로 호출이 진행 중입니다. IntelliSense PCH 파일이 생성되지 않았습니다.",
  "헤더 중지가 파일 범위가 아닙니다. IntelliSense PCH 파일이 생성되지 않았습니다.",
  "헤더 중지가 매크로 또는 #if 블록에 있으면 안 됩니다. IntelliSense PCH 파일이 생성되지 않았습니다.",
  "헤더 중지가 연결 블록에 있으면 안 됩니다. IntelliSense PCH 파일이 생성되지 않았습니다.",
  "알맞은 헤더 중지 위치를 찾을 수 없습니다. IntelliSense PCH 파일이 생성되지 않았습니다.",
  "line 지시문을 PCH에 사용할 수 없습니다. IntelliSense PCH 파일이 생성되지 않았습니다.",
  "제한 지정자가 잘못되었습니다.",
  "amp 제한 함수 %nfd은(는) amp 제한 함수에서 호출해야 합니다.",
  "함수 %nfd1에는 호출 함수 %nfd2과(와) 호환되지 않는 제한 지정자가 있습니다.",
  "올바른 제한 지정자가 있는 오버로드 후보가 없습니다.",
  "amp 제한 함수 %nfd에는 %t을(를) 사용할 수 없습니다.",
  "amp 제한 멤버 함수 %nfd에 대한 this 포인터의 %t 형식이 잘못되었습니다.",
  "amp 제한 함수 %nfd의 반환 형식 %t이(가) 잘못되었습니다.",
  "amp 제한 함수 %nfd의 매개 변수 형식 %t이(가) 잘못되었습니다.",
  null,
  "잘못된 스토리지 클래스 %s(amp 제한 함수 %nfd 내)",
  "%s은(는) amp 제한 함수 %nfd에서 사용할 수 없습니다.",
  "amp 제한 함수의 캐스트가 잘못되었습니다.",
  "amp 제한 함수에는 예외 사양을 사용할 수 없습니다.",
  "amp 제한 함수 %nfd의 간접 참조가 잘못되었습니다.",
  "amp 제한 함수 %nfd에서 가상 함수 호출이 잘못되었습니다.",
  "amp 제한 함수 %nfd의 간접 함수 호출이 잘못되었습니다.",
  "여기에는 tile_static 스토리지 클래스를 사용할 수 없습니다.",
  "amp 제한 함수 %nfd의 레이블이 잘못되었습니다.",
  "amp 제한 함수 %nfd의 비트 필드가 잘못되었습니다.",
  "amp 제한 함수 %nfd의 줄임표가 잘못되었습니다.",
  "amp 호환 형식 %nfd의 가상 기본이 잘못되었습니다.",
  "amp 제한 함수 %nfd의 외부 참조가 잘못되었습니다.",
  "상수 값이 amp 제한 함수 %nfd의 지원되는 범위를 벗어납니다.",
  "amp 제한 함수의 pragma pack 값 %s이(가) 잘못되었습니다.",
  "겹치는 제한 지정자는 사용할 수 없습니다.",
  "소멸자의 제한 지정자는 모든 생성자에 대한 제한 지정자의 공용 구조체를 지정해야 합니다.",
  null,
  "nostdlib에는 한 번 이상의 강제 사용이 필요합니다.",
  null,
  null,
  null,
  null,
  "extern \"C\" 함수에서 여러 제한 지정자가 지원되지 않습니다.",
  "멤버 함수에 대한 포인터, 함수 포인터, 'amp' 제한 지정자를 가진 함수에 대한 참조는 사용할 수 없습니다.",
  "amp 제한 함수 %nfd의 기본 클래스, 데이터 멤버 또는 배열 요소에는 최소한 4바이트가 할당되어야 합니다.",
  "amp 제한 함수 %nfd의 데이터 멤버 오프셋은 해당 일반 맞춤의 배수여야 합니다.",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "tile_static 변수에는 이니셜라이저가 있을 수 없습니다.",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "/clr:nostdlib를 사용하려면 mscorlib.dll이 강제 사용 목록에 있어야 합니다.",
  "/clr:nostdimport와 함께 /clr:netcore를 사용하려면 System.Runtime.dll, System.Runtime.Extensions.dll, System.Runtime.InteropServices.dll 및 System.Runtime.CompilerServices.VisualC.dll이 적용된 using 목록에 있어야 합니다.",
  null,
  null,
  null,
  null,
  null,
  "<진단 내보내기 실패>",
  "IntelliSense 엔진이 오류가 너무 많아 제대로 작동할 수 없으며, 오류 중 일부는 편집기에 표시되지 않을 수 있습니다.",
  "'this'에 대한 할당(오래된 구문)은 C++11 모드와 호환되지 않습니다.",
  "알 수 없는 오류가 발생했습니다. IntelliSense PCH 파일이 생성되지 않았습니다.",
  "하나 이상의 원격 경로를 기존 로컬 경로에 매핑할 수 없습니다. IntelliSense 성능이 저하될 수 있습니다.",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "'>>>'가 필요함",
  "__cudaPushCallConfiguration 선언을 찾을 수 없습니다. CUDA 도구 키트 설치가 손상되어 있을 수 있습니다.",
  "C++17 스타일 이니셜라이저는 이 모드에서 표준이 아닙니다.",
  "*this 캡처는 이 모드에서 표준이 아닙니다.",
  "C++17 스타일 'using' 특성 접두사는 이 모드에서 표준이 아닙니다.",
  "C++17 스타일 중첩 네임스페이스는 이 모드에서 표준이 아닙니다.",
  "선언에 'constexpr', 'consteval' 및 'constinit' 중 하나만 나타날 수 있습니다.",
  "이 모드에서 함수가 동시에 consteval 및 virtual일 수는 없습니다.",
  "'consteval'은 명시적 인스턴스화 지시문에서 사용할 수 없습니다.",
  "'consteval'은 여기에 유효하지 않습니다.",
  "소멸자는 consteval일 수 없습니다.",
  "가상 기본이 있는 클래스의 생성자는 consteval일 수 없습니다.",
  "'consteval'은 변수 또는 정적 데이터 멤버의 선언에서 사용할 수 없습니다.",
  "%nd이(가) 이전에 consteval로 선언되었습니다.",
  "%nd이(가) 이전에 consteval로 선언되지 않았습니다.",
  "'main' 함수는 consteval로 선언할 수 없습니다.",
  "consteval %n 호출에서 유효한 상수 식이 생성되지 않았습니다.",
  "상수 식 결과의 consteval %n 주소",
  "consteval 멤버는 consteval이 아닌 %n을(를) 재정의할 수 없습니다.",
  "consteval이 아닌 멤버는 consteval %n을(를) 재정의할 수 없습니다.",
  "구조적 바인딩",
  "%t1 형식의 하위 개체에 대한 dynamic_cast가 유효하지 않습니다(가장 많이 파생된 형식은 %t2임).",
  "식별자 __VA_OPT__은 variadic 매크로의 대체 목록에만 나타날 수 있습니다.",
  "__VA_OPT__는 __VA_OPT__ 피연산자에 나타날 수 없습니다.",
  "__VA_OPT__의 닫는 괄호 없음",
  "__VA_OPT__ 뒤에 '('가 나타나야 합니다.",
  "'##'은 __VA_OPT__ 피연산자의 처음에 나타날 수 없습니다.",
  "'##'은 __VA_OPT__ 피연산자의 마지막에 나타날 수 없습니다.",
  "C++20 스타일 중첩 인라인 네임스페이스는 이 모드에서 표준이 아닙니다.",
  "기본 클래스 %t2의 포인터를 파생 클래스 %t1의 포인터로 변환할 수 없음 -- 최다 파생 개체 이상을 가리키도록 시도",
  null,
  "'main'은 전역 변수 이름 또는 지정된 C 언어 연결로 사용할 수 없습니다.",
  "'main' 함수는 연결 사양에서 선언할 수 없습니다.",
  "조건에 구조적 바인딩은 허용되지 않습니다.",
  "'::' 앞에 특성 네임스페이스 식별자가 필요합니다.",
  "하나의 특성 네임스페이스만 허용됩니다.",
  "'return'은 여기에서 허용되지 않습니다.",
  "구조적 바인딩은 다른 선언자와 함께 사용할 수 없습니다.",
  "상수 계산 컨텍스트 밖으로 분기할 수 없습니다.",
  "구조적 바인딩 템플릿은 허용되지 않습니다.",
  "괄호로 묶인 이니셜라이저는 중괄호로 묶인 목록이 아니라 식이어야 합니다.",
  "클래스 템플릿 인수를 추론할 수 없습니다.",
  "new 또는 delete 연산자는 'consteval'로 선언할 수 없습니다.",
  "consteval 함수의 주소는 여기에 사용할 수 없습니다.",
  "함수 형식(%t)의 맞춤이 비표준입니다.",
  "경계가 지정되지 않은 배열의 맞춤은 C에서 비표준입니다.",
  "변수에 'common' 및 'internal_linkage' 특성을 둘 다 사용할 수는 없습니다.",
  "'internal_linkage' 특성이 이전 선언에 나타나지 않았습니다.",
  "%n에 대한 실행 가능한 템플릿 인수 추론 후보를 찾을 수 없음",
  "정규화된 생성자 호출은 허용되지 않습니다.",
  "기본 비교 연산자는 적용되는 클래스의 멤버 또는 friend여야 합니다.",
  "기본 비교 연산자의 매개 변수에 대한 잘못된 형식 %t('const X에 대한 참조'여야 함, 여기서 X는 바깥쪽 클래스 형식임)",
  "기본 비교 연산자의 반환 형식은 'bool'이어야 합니다.",
  "기본 멤버 비교 연산자는 'cost'여야 합니다.",
  null,
  "코루틴의 프라미스 형식 %t에 'return_void' 및 'return_value' 세트를 둘 다 사용할 수는 없습니다.",
  "'return_value'이(가) %p을(를) 선언함",
  "'return_void'이(가) %p을(를) 선언함",
  "%t의 %n 끝에 'return_void'가 없지만 co_return 문이 없음",
  "코루틴 상태 할당에 대한 전역 'operator new'의 nothrow variant를 찾을 수 없음",
  "코루틴 상태 할당 해제에 대한 실행 가능한 'operator delete'를 찾을 수 없음",
  "constexpr 함수는 코루틴일 수 없습니다.",
  "이 %s 식의 피연산자가 비클래스 %t(으)로 확인됩니다.",
  "정적 이니셜라이저에는 co_await 식을 사용할 수 없습니다.",
  "%n을(를) 호출하는 co_await 식은 throw되지 않아야 합니다.",
  "재귀적 비교 재작성 작업이 너무 많음",
  "기본 연산자 <=>의 추론 가능한 반환 형식은 'auto'여야 합니다.",
  "비상수 소스의 암시적 복사본",
  "구조적 바인딩은 static 또는 thread_local 이외의 명시적 스토리지 클래스를 선언할 수 없습니다.",
  "기본 비교 연산자는 nontrivial Microsoft 속성 필드에서 지원되지 않습니다.",
  "표준 비교 형식(%t)은 정수 형식의 단일 비정적 데이터 멤버를 포함하는 클래스 형식이어야 합니다.",
  "%t에서 constexpr 정적 데이터 멤버 %sq을(를) 찾을 수 없음",
  "동적 할당을 위한 요소 수(%d개)가 너무 많습니다.",
  "constexpr 동적 할당 요청이 너무 큽니다.",
  "동적으로 할당되지 않은 스토리지 할당 해제",
  "할당 해제 크기(%d1)가 할당된 크기(%d2)와 일치하지 않습니다.",
  "여기서 할당이 발생했습니다.",
  "할당 해제 형식(%t1)이 할당 형식(%t2)과 일치하지 않습니다.",
  "일부 동적 할당(총수 = %d개)의 할당이 취소되지 않았습니다.",
  "내장 %n이(가) 예기치 않은 시그니처(%t 유형)로 선언되었습니다.",
  ">> std::__report_constexpr_value의 출력",
  ">> std::__report_constexpr_value의 출력 종료",
  "constexpr 평가에 종속 배열 크기를 포함하는 배열을 사용할 수 없습니다.",
  "'nodiscard' 특성(%sq)으로 선언된 루틴의 반환 값을 무시합니다.",
  "'nodiscard' 특성(%sq)이 있는 반환 값 형식을 무시합니다.",
  "삭제된 개체를 만드는 데 사용되는 생성자에 'nodiscard' 특성이 있습니다.",
  "삭제된 개체를 만드는 데 사용되는 생성자에 'nodiscard' 특성(%sq)이 있습니다.",
  "삭제된 개체의 형식에 'nodiscard' 특성이 있습니다.",
  "삭제된 개체의 형식에 'nodiscard' 특성(%sq)이 있습니다.",
  "의사(pseudo) 소멸자 참조는 의사 소멸자 호출에만 사용할 수 있습니다.",
  "상수 식에는 명시적 소멸자 호출을 사용할 수 없습니다.",
  "배열 첨자 식의 괄호로 묶이지 않은 쉼표 연산자는 사용되지 않습니다.",
  "동적으로 할당된 요소 수(%d개)가 이니셜라이저에 비해 너무 적습니다.",
  "%s 식에 대한 volatile 피연산자는 사용되지 않습니다.",
  "volatile 스칼라 개체에 할당한 결과는 사용되지 않습니다.",
  "복합 대입 식에 대한 volatile 대상 형식은 사용되지 않습니다.",
  "volatile 함수 매개 변수는 사용되지 않습니다.",
  "volatile 반환 형식은 사용되지 않습니다.",
  "volatile 한정자는 구조적 바인딩에 사용되지 않습니다.",
  "'ext_vector_type' 인수는 1~2047 사이여야 합니다.",
  "'ext_vector_type' 특성은 typedef에만 사용할 수 있습니다.",
  "'ext_vector_type' 특성은 정수나 부동 소수점 형식에만 적용됩니다.",
  "이 기능 테스트 매크로는 현재 컴파일 모드에서 무시되고 0을 반환합니다.",
  "공용 구조체에 대해 여러 요소가 포함된 집합체 이니셜라이저를 평가할 수 없습니다.",
  "연산자 재작성을 위해 선택한 %nd은(는) bool 형식을 반환하지 않습니다.",
  "클래스 관련 할당 함수를 호출하는 new-expression은 상수로 계산할 수 없습니다.",
  "배치 new-expression은 상수를 계산할 수 없습니다.",
  "하위 개체 포인터를 통해 삭제하려면 가상 소멸자가 필요합니다.",
  "%npTd, 역 인수 포함",
  "__INTADDR__의 피연산자는 Null 포인터에서 오프셋되어야 합니다.",
  "_Generic 구문이 여러 형식과 일치합니다.",
  "다른 일치 항목은 %t입니다.",
  "여기에 사용된 'availability' 특성은 무시됩니다.",
  "범위 기반의 'for' 문에서 C++20 스타일 이니셜라이저 문은 이 모드에서 표준이 아닙니다.",
  "co_await는 범위 기반의 for 문에만 적용할 수 있습니다.",
  "범위 기반의 'for' 루프에서 범위 형식을 추론할 수 없습니다.",
  "인라인 변수는 C++17 기능입니다.",
  "destroying operator delete에는 첫 번째 매개 변수로 %t이(가) 필요합니다.",
  "destroying operator delete는 std::size_t 및 std::align_val_t 이외의 매개 변수를 가질 수 없습니다.",
  "낮은 수준의 추상 클래스 옵션은 C++를 컴파일할 경우에만 사용할 수 있습니다.",
  "requires 절에서 식의 시작이 잘못되었습니다.",
  "requires 절의 캐스트 식은 괄호로 묶어야 합니다.",
  "이 연산자는 괄호 없이 requires 절의 최상위 수준에 표시될 수 없습니다.",
  "원자성 제약 조건에는 bool 형식이 있어야 합니다.",
  "원자성 제약 조건이 대체에 실패했습니다.",
  "원자성 제약 조건이 상수가 아닙니다.",
  "원자성 제약 조건이 false로 평가됩니다.",
  "템플릿 제약 조건이 충족되지 않습니다.",
  "이 범위에는 개념 정의가 표시될 수 없습니다.",
  "%nd의 재선언이 잘못되었습니다.",
  "개념 ID의 %T 인수를 대체하지 못했습니다.",
  "%T 인수의 개념이 false입니다.",
  "requires 절은 여기에서 허용되지 않습니다(템플릿 기반 함수가 아님).",
  "개념 템플릿",
  "requires 절이 %nfd과(와) 호환되지 않습니다.",
  "특성이 필요합니다.",
  null,
  "형식 이름이 필요합니다.",
  "requires 식에는 가변 매개 변수(...)를 사용할 수 없습니다.",
  "requires 식의 명명되지 않은 매개 변수는 영향을 주지 않습니다.",
  "개념 이름이 필요합니다.",
  "상수 식에 표시되는 %s 호출은 항상 'true'를 생성합니다.",
  "consteval 컨텍스트에 표시되는 %s 호출은 항상 'true'를 생성합니다.",
  "비 constexpr 함수에 표시되는 %s 호출은 항상 'false'를 생성합니다.",
  "%t에 대한 형식 제약 조건이 실패했습니다.",
  "C++ 모듈을 사용할 수 있는 모드에서는 'export' 옵션을 사용할 수 없습니다.",
  "전역 모듈 조각 선언은 다른 선언 앞에 와야 합니다.",
  "모듈 선언은 전역 모듈 조각 뒤에 와야 합니다.",
  "프라이빗 모듈 조각은 모듈 선언 뒤에 와야 합니다.",
  "%s 모듈 조각을 내보낼 수 없습니다.",
  "둘 이상의 모듈을 선언할 수 없습니다.",
  "둘 이상의 %s 모듈 조각을 선언할 수 없습니다.",
  "모듈은 비어 있지 않은 이름으로 선언해야 합니다.",
  "%sq은(는) 가져올 수 있는 헤더가 아닙니다.",
  "이름이 없는 모듈을 가져올 수 없습니다.",
  "모듈은 자신에 대한 인터페이스 종속성을 포함할 수 없습니다.",
  "%sq 모듈을 이미 가져왔습니다.",
  "모듈 파일",
  "모듈 %sq의 모듈 파일을 찾을 수 없습니다.",
  "모듈 파일 %sq을(를) 가져올 수 없습니다.",
  "%s1이(가) 필요한데, %s2이(가) 발견되었습니다.",
  "%sq 모듈 파일을 열 때",
  "알 수 없는 파티션 이름 %sq",
  "알 수 없는 모듈 파일",
  "가져올 수 있는 헤더 모듈 파일",
  "EDG 모듈 파일",
  "IFC 모듈 파일",
  "예기치 않은 모듈 파일",
  "두 번째 피연산자 %t2의 형식은 %t1과(와) 크기가 같아야 합니다.",
  "형식은 일반적으로 복사할 수 있어야 합니다.",
  "%t 형식은 현재 __builtin_bit_cast의 constexpr 평가에서 지원되지 않습니다.",
  "비트 필드 %t을(를) 사용하는 클래스 형식은 현재 __builtin_bit_cast의 constexpr 평가에서 지원되지 않습니다.",
  "참조 형식 %t의 비정적 데이터 멤버는 __builtin_bit_cast의 constexpr 평가를 차단합니다.",
  "volatile 형식 %t은(는) __builtin_bit_cast의 constexpr 평가를 차단합니다.",
  "공용 구조체, 포인터 또는 멤버 포인터 형식 %t은(는) __builtin_bit_cast의 constexpr 평가를 차단합니다.",
  "%npTd, decl %p 사용을 통해 상속됨",
  "생성자를 상속하기 위해 %t의 하위 개체를 생성할 수 없습니다. 암시적 기본 생성자가 삭제됩니다.",
  "%n은(는) void를 반환해야 합니다.",
  "잘못된 멤버 선언 시작",
  "'auto'가 필요합니다.",
  "이 시점에 이 연산자를 사용할 수 없습니다. 앞의 새 식을 괄호로 묶으세요.",
  "잘못된 개념 사용",
  "기본 멤버 비교 연산자는 '&&'-qualified일 수 없습니다.",
  "기본 constexpr 비교 함수에서 비 constexpr 함수 %nd 호출",
  "constexpr 메모리 비교는 정수 또는 정수 배열 개체에 대해서만 지원됩니다.",
  "개념 템플릿에는 관련된 제약 조건이 있을 수 없습니다.",
  "'export'는 허용되지 않습니다.",
  "개별 클래스 멤버를 내보낼 수 없습니다.",
  "내보낸 선언은 이름이 있어야 합니다.",
  "내보내기 선언은 내보내기 선언(이전 선언 %p)을 포함할 수 없습니다.",
  "내보내기 선언은 모듈 가져오기 선언을 포함할 수 없습니다.",
  "내보내기 선언은 모듈 인터페이스 단위에만 나타날 수 있습니다.",
  "내보내기 선언은 내부 링크가 있는 이름을 내보낼 수 없습니다.",
  "using 선언에 %nfd가 포함되어 있습니다.",
  "__fp16 부동 소수점 형식이 지원되지 않으므로 기본 제공 함수를 사용할 수 없습니다.",
  "requires 식은 하나 이상의 요구 사항을 지정해야 합니다.",
  "'constinit'는 여기에 유효하지 않습니다.",
  "'constinit'는 정적 또는 스레드 저장 기간을 사용하는 변수 선언에만 유효합니다.",
  "constinit 변수에는 동적 초기화가 필요합니다.",
  "변수가 이전에 'constinit'(%p)로 선언되었습니다.",
  "프로토타입 함수가 아닌 함수 선언자를 사용합니다.",
  "인수에는 const 한정 형식을 사용할 수 없습니다.",
  "불완전한 형식 %t의 멤버 포인터는 사용할 수 없습니다.",
  "init-capture의 팩 확장은 이 모드에서 사용할 수 없습니다.",
  "init-capture의 팩 확장은 C++20 기능입니다.",
  "클래스 정의의 기본 비교 연산자는 해당 비교 연산자(%nd)의 첫 번째 선언이어야 합니다.",
  "init-capture의 팩 확장은 가변 인자 템플릿에서만 사용할 수 있습니다.",
  "형식 제약 조건이 형식 개념(즉, 첫 번째 매개 변수가 형식 매개 변수인 개념 템플릿)이 아닌 %nd를 사용합니다.",
  "추론된 자리 표시자 형식 %t이(가) 형식 제약 조건에 실패했습니다.",
  "%t의 기본 생성자가 적합하지 않습니다.",
  "순서가 지정되지 않은 제약 조건으로 인해 %t의 소멸자가 모호합니다.",
  "실패한 제약 조건으로 인해 %t의 소멸자가 부적합합니다.",
  "모호한 소멸자 후보",
  "가상 함수에는 후행 requires 절을 사용할 수 없습니다.",
  "%nd이(가) 해당 제약 조건을 충족하지 않습니다.",
  "decltype 한정자 %t의 결과가 클래스 또는 열거형이 아닙니다.",
  "역 매개 변수를 사용하는 암시적 비교 연산자는 동일하게 적절한 일치 항목이므로 표준 C++20에서 비교는 모호합니다. 이 문제는 일반적으로 비교 연산자에 'const' 한정자가 없어서 발생합니다. %nod를 참조하세요.",
  "잘못된 개념 ID",
  "requires 절의 %T 인수를 대체하지 못했습니다.",
  "%nd에 대한 제약 조건을 충족하지 않습니다.",
  "constexpr 함수의 변수 형식 %t에는 가상 기본 클래스가 있습니다.",
  "상수 식은 가상 기본 하위 개체(%t 형식)를 할당할 수 없습니다.",
  "클래스 형식의 템플릿 매개 변수는 구조적 클래스 형식이어야 합니다.",
  "UTF-8 리터럴에 대한 지원에는 u-리터럴 지원이 필요합니다.",
  "'%s'에 대한 모듈 파일 매핑이 두 번 이상 지정되었습니다.",
  "'%s'에 대한 헤더 단위 매핑이 두 번 이상 지정되었습니다.",
  "'%s'에 대한 매핑이 지정되지 않았습니다.",
  "'%s'에 대한 모듈 파일 매핑이 잘못되었습니다.",
  "가져올 '%s' 헤더를 찾을 수 없습니다.",
  "모듈 파일 목록에 있는 두 개 이상의 파일이 '%s'과(와) 일치합니다.",
  "'%s'에 대해 찾은 모듈 파일이 다른 모듈에 대한 것입니다.",
  "모든 종류의 모듈 파일",
  "모듈 파일을 읽을 수 없음",
  "char8_t 형식이 현재 옵션에서 지원되지 않기 때문에 기본 제공 함수를 사용할 수 없습니다.",
  "C++20 코루틴을 사용하도록 설정한 경우 --ms_await 명령줄 옵션을 지정할 수 없습니다.",
  "기본 집계 요소 초기화에 명시적 생성자 %nod의 비표준 사용",
  "memcpy 유사 내장의 소스 또는 대상이 개체를 가리키지 않음",
  "memcpy 유사 내장이 대표적으로 차별화된 형식 %t1 및 %t2을(를) 복사하려고 시도함",
  "memcpy 유사 내장이 중요하게 복사 가능한 형식 %t을(를) 복사하려고 시도함",
  "memcpy 유사 내장이 부분 개체를 복사하려고 시도함",
  "memcpy 유사 내장이 과거 배열 경계를 복사하려고 시도함",
  "memcpy 유사 내장이 겹치는 바이트 범위를 복사하려고 시도함(대신 해당 memmove 작업 사용)",
  "trailing-requires 절이 있는 friend 선언이 정의여야 함",
  "식에 산술 또는 포인터 형식이 있어야 하는데 %t 형식이 있음",
  "식에 산술, 열거형 또는 포인터 형식이 있어야 하는데 %t 형식이 있음",
  "식에 산술, 범위가 지정되지 않은 열거형 또는 포인터 형식이 있어야 하는데 %t 형식이 있음",
  "식에 포인터 형식이 있어야 하는데 %t 형식이 있음",
  "연산자 -> 또는 ->*가 포인터 형식 대신 %t에 적용됨",
  "불완전한 클래스 형식 %t을(를) 사용할 수 없음",
  "이 컴파일 대상의 비트 레이아웃을 해석할 수 없음",
  "IFC 연산자 %sq에 해당하는 연산자가 없음",
  "IFC 호출 규칙 %sq에 해당하는 호출 규칙이 없음",
  "모듈 %sq에 지원되지 않는 구문이 포함되어 있음",
  "지원되지 않는 IFC 구문: %sq",
  "__is_signed는 이 시점부터 더 이상 키워드가 아님",
  "배열 차원에는 상수인 부호 없는 정수 값이 있어야 함",
  "IFC 파일 %sq에 지원되지 않는 버전 %d1.%d2이(가) 있음",
  "이 모드에서 모듈을 사용할 수 없음",
  "'import'는 모듈 이름에 사용할 수 없습니다.",
  "'module'은 모듈 이름에 사용할 수 없습니다.",
  null,
  null,
  "%n은(는) 열거형 형식이 아닙니다.",
  "열거자 %no2이(가) %n1과(와) 충돌합니다.",
  "열거자 %no은(는) 이미 이 범위 %p에 선언되었습니다.",
  "'throw()' 사양은 C++20 이상에 포함되지 않습니다.",
  "헤더 단위 맵의 입력보다 많은 항목이 '%s'과(와) 일치합니다.",
  "#pragma 진단에 'push' 또는 'pop' 인수가 있어야 합니다.",
  "이 '진단 팝업'과 일치하는 '#pragma 진단 푸시'가 없음",
  "가져오기 또는 모듈 지시문에 사용된 경우 %sq은(는) 매크로일 수 없습니다.",
  "이 지시문은 전역 네임스페이스 범위에만 표시될 수 있습니다.",
  "'내보내기' 선언은 전역 또는 네임스페이스 범위에만 나타날 수 있습니다.",
  "%sq는 뒤에 오는 토큰이 전처리기 지시문의 토큰과 일치하지 않으므로 키워드가 아닌 식별자로 구문 분석됩니다.",
  "이것은 전처리기 지시문의 시작인 것처럼 보이지만 ';'가 없습니다. 바로 뒤에 줄 바꿈이 있으면",
  "이는 모듈 전처리기 지시문으로 보이지만 이러한 지시문은 매크로 확장 내에 나타날 수 없습니다.",
  "'모듈' 지침은 조건부 포함 범위 내에 나타날 수 없습니다(예: #if, #else, #elseif 등).",
  "%sq 가져오기를 건너뜀",
  "promise 형식 %t은(는) 인수가 필요하지 않은 정적 멤버 함수로 get_return_object_on_allocation_failure를 선언해야 합니다.",
  "별칭 템플릿은 명시적으로 특수화할 수 없습니다.",
  "다음에 일치하려면 '{'",
  "이 매크로 호출에서",
  "호출에는 애매한 인수 변환이 필요합니다.",
  "%s 모듈이 소유한 선언이 %nd과(와) 충돌합니다.",
  "전역 모듈이 소유한 선언이 명명된 모듈이 소유한 %nd과(와) 충돌합니다.",
  "'malloc' 특성에 대한 첫 번째 인수는 함수여야 합니다.",
  "%nod을(를) 캡처할 수 없습니다.",
  "'this'를 캡처할 수 없습니다.",
  "이미 consteval 컨텍스트에 있습니다.",
  "'if consteval' 및 'if not consteval'에는 중괄호가 있는 종속 문이 필요합니다.",
  "비 constexpr 함수에서는 'if consteval' 및 'if not consteval'이 의미가 없습니다.",
  "컨트롤을 'if consteval' 또는 'if not consteval' 문으로 전송할 수 없습니다.",
  "상수 평가는 정적 또는 스레드 스토리지 기간이 있는 변수 선언을 통과할 수 없습니다.",
  "명시적 'this' 매개 변수가 있는 람다에서는 변경 가능한 한정자를 사용할 수 없습니다.",
  "'static'으로 선언된 멤버 함수에는 명시적 'this' 매개 변수를 사용할 수 없습니다.",
  "명시적 'this' 매개 변수는 첫 번째 선언된 매개 변수여야 합니다.",
  "여기서는 'this'를 사용할 수 없습니다.",
  "명시적 'this'를 사용하는 비교 함수는 기본값으로 사용할 수 없습니다.",
  "명시적 'this' 함수에는 선택기 피연산자가 필요합니다.",
  "'if consteval' 및 'if not consteval'은 이 모드에서 표준이 아닙니다.",
  "람다 선언자에서 '()'를 생략하는 것은 이 모드에서 표준이 아닙니다.",
  "람다 매개 변수 목록을 생략하면 후행-requires 절이 허용되지 않습니다.",
  "모듈 %sq 잘못된 파티션이 요청됨",
  "모듈 %sq1 정의되지 않은 파티션(%sq2로 추정됨) 요청됨",
  "%sq1 모듈 파일 위치 %d1(상대 위치 %d2)이(가) %sq2 파티션에 대해 요청되었습니다. 이 위치는 비어 있습니다.",
  "%sq1 모듈 파일 위치 %d1(상대 위치 %d2)이(가) 파티션 %sq2에 대해 요청되었습니다. 이는 파티션의 시작을 선행합니다.",
  "모듈 %sq1 파일 위치 %d1(상대 위치 %d2)이(가) 파티션의 끝을 오버플로하는 파티션 %sq2에 대해 요청되었습니다.",
  "모듈 %sq1 파일 위치 %d1(상대 위치 %d2)이(가) 파티션 요소가 잘못 정렬된 파티션 %sq2에 대해 요청되었습니다.",
  "하위 필드 %sq(노드 %d에 대한 상대 위치)에서",
  "파티션 %sq 요소 %d1(파일 위치 %d2, 상대 위치 %d3)에서",
  "여기서 람다 특성은 표준이 아닙니다.",
  "식별자 %sq은(는) 시각적으로 유사한 식별자와 혼동될 수 있습니다. %p",
  "이 주석에는 의심스러운 유니코드 서식 지정 제어 문자가 포함되어 있습니다.",
  "이 문자열에는 예기치 않은 런타임 동작이 발생할 수 있는 유니코드 서식 지정 컨트롤 문자가 포함되어 있습니다.",
  "%d1 모듈 %sq1을(를) 처리하는 동안 표시되지 않는 경고가 발생했습니다.",
  "%d1 모듈 %sq1을(를) 처리하는 동안 표시되지 않는 경고가 발생했습니다.",
  "%d1 모듈 %sq1을(를) 처리하는 동안 오류가 표시되지 않았습니다.",
  "%d1 모듈 %sq1을(를) 처리하는 동안 오류가 표시되지 않았습니다.",
  "포함",
  "표시 안 함",
  "가상 멤버 함수에는 명시적 'this' 매개 변수를 사용할 수 없습니다.",
  "명시적 'this' 함수의 주소를 사용하려면 정규화된 이름이 필요합니다.",
  "명시적 'this' 함수의 주소를 구성하려면 '&' 연산자가 필요합니다.",
  "가변 배열 멤버를 초기화하는 데 문자열 리터럴을 사용할 수 없습니다.",
  "함수 %sq의 정의에 대한 IFC 표현이 잘못되었습니다.",
  "암시적 'this' 매개 변수를 삭제하도록 수정되었습니다.",
  "매개 변수를 지정하는 데 UniLevel IFC 차트가 사용되지 않았습니다.",
  "%d1 매개 변수는 IFC 매개 변수 정의 차트에 의해 지정되었지만 %d2 매개 변수는 IFC 선언에 의해 지정되었습니다.",
  "%d1 매개 변수는 IFC 매개 변수 정의 차트에 의해 지정되었지만 %d2 매개 변수는 IFC 선언에 의해 지정되었습니다.",
  "%d1 매개 변수는 IFC 매개 변수 정의 차트에 의해 지정되었지만 %d2 매개 변수는 IFC 선언에 의해 지정되었습니다.",
  "%sq 함수 정의의 IFC 표현이 없습니다.",
  "함수 한정자는 멤버 템플릿 선언에 적용되지 않습니다.",
  "멤버 선택에 너무 많은 중첩된 익명 형식이 포함됩니다.",
  "피연산자 사이에 공통 형식이 없습니다.",
  "멤버 포인터가 필요합니다.",
  "유연한 배열 멤버는 비어 있는 형식으로 선언할 수 없습니다.",
  "예상되는 'std::source_location::__impl'이 '_M_function_name', '_M_file_name', '_M_column', '_M_line'의 데이터 멤버만을 포함하는 클래스에 정의되어야 함",
  "'std::source_location::__impl' 초기화 중 열 번호가 %t 형식의 '_M_column' 멤버를 오버플로",
  "'std::source_location::__impl' 초기화 중 줄 번호가 %t 형식의 '_M_line' 멤버를 오버플로",
  "UTF-16 문자 상수는 코드 단위를 두 개 이상 사용할 수 없음; 값 잘림",
  "두 인수의 형식이 같아야 함",
  "%t 형식은 이 기본 제공의 인수로 사용할 수 없음",
  "%nd에서 호출",
  "정규화된 형식이 익명 비트 필드에 대해 표준이 아닙니다.",
  "벡터 조건의 요소 유형(%t1)은 결과의 요소 유형(%t2)과 크기가 같아야 합니다.",
  "부동 소수점 벡터 피연산자 유형(%t)에 일치하는 정수 벡터 유형이 없습니다.",
  "'requires' 식에 대한 mangling이 아직 구현되지 않았습니다.",
  "'unavailable' 특성 때문에",
  "IFC 파티션 %sq에 대한 인덱스를 사용하여 IFC 파티션 %sq에서 요소를 구성하려고 했습니다.",
  "파티션 %sq는 %d2가 예상될 때 항목 크기를 %d1로 지정했습니다.",
  "모듈 %sq1을(를) 처리하는 동안 예기치 않은 IFC 요구 사항이 발생했습니다.",
  "%d행(%s1)에서 조건 실패: %sq2",
  "원자성 제약 조건은 자체에 따라 달라집니다.",
  "'noreturn' 함수에 void가 아닌 반환 형식이 있습니다.",
  "매개 변수 %sq(상대 인덱스 %d)를 삭제하여 수정했습니다.",
  "엔터티를 재구성하는 동안 %sq라는 잘못된 IFC 식별자를 발견했습니다.",
  "엔티티를 재구성하는 동안 %sq라는 잘못된 IFC 식별자를 건너뛰었습니다.",
  "모듈 %sq 잘못된 정렬 값",
  "IFC 모듈에서 로드된 함수 템플릿이 %nd(으)로 잘못 구문 분석되었습니다.",
  "모듈 %sq에서 IFC 엔터티 참조를 로드하지 못했습니다.",
  "IFC 인덱스 정렬 = %d1, 값 = %d2"
]