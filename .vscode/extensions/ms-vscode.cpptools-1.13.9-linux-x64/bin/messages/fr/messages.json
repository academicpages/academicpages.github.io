[
  "Erreur inconnue",
  "la dernière ligne du fichier se termine sans saut de ligne",
  "la dernière ligne du fichier se termine par une barre oblique inverse",
  "le fichier #include %sq s'inclut lui-même",
  "Mémoire insuffisante",
  null,
  "commentaire non fermé à la fin du fichier",
  "jeton non reconnu",
  "guillemet fermant manquant",
  "les commentaires imbriqués ne sont pas autorisés",
  "'#' non attendu ici",
  "directive de prétraitement non reconnue",
  "l'analyse recommence ici après une syntaxe d'erreur",
  "nom de fichier attendu",
  "texte supplémentaire après la fin attendue de la directive de prétraitement",
  null,
  null,
  "']' attendu",
  "')' attendu",
  "texte supplémentaire après la fin de nombre attendue",
  "identificateur %sq non défini",
  "les qualificateurs de type n'ont pas de sens dans cette déclaration",
  "nombre hexadécimal non valide",
  "la constante Integer est trop grande",
  "chiffre octal non valide",
  "une chaîne entre guillemets doit contenir au moins un caractère",
  "la constante caractère contient trop de caractères",
  "la valeur de caractère est hors limites",
  "l'expression doit avoir une valeur de constante",
  "expression attendue",
  "la constante flottante est hors limites",
  "l'expression doit avoir un type intégral",
  "l'expression doit avoir un type arithmétique",
  "numéro de ligne attendu",
  "numéro de ligne non valide",
  "directive #error : %s",
  "le #if de cette directive est manquant",
  "le #endif de cette directive est manquant",
  "directive non autorisée -- un #else est déjà apparu",
  "Division par zéro",
  "identificateur attendu",
  "l'expression doit avoir un type arithmétique ou pointeur",
  "les types d'opérandes sont incompatibles (%t1 et %t2)",
  null,
  "l'expression doit avoir un type pointeur",
  "#undef ne doit pas être utilisé avec ce nom prédéfini",
  "%no est prédéfini ; tentative de redéfinition ignorée",
  "redéfinition incompatible de la macro %nod",
  null,
  "nom de paramètre de macro dupliqué",
  "'##' ne peut pas être le premier dans une définition de macro",
  "'##' ne peut pas être le dernier dans une définition de macro",
  "nom de paramètre de macro attendu",
  "':' attendu",
  "arguments insuffisants dans l'appel de %n",
  "trop d'arguments dans l'appel de %n",
  "l'opérande de sizeof ne peut pas être une fonction",
  "cet opérateur n'est pas autorisé dans une expression constante",
  "cet opérateur n'est pas autorisé dans une expression de prétraitement",
  "l'appel de fonction n'est pas autorisé dans une expression constante",
  "cet opérateur n'est pas autorisé dans une expression constante intégrale",
  "le résultat de l'opération entière est hors limites",
  "le compteur de décalage est négatif",
  "le compteur de décalage est trop grand",
  "la déclaration ne déclare rien",
  "';' attendu",
  "la valeur d'énumération est hors de la plage 'int'",
  "'}' attendu",
  "la conversion entière a entraîné un changement de signe",
  "la conversion entière a entraîné une troncation",
  "type incomplet non autorisé",
  "l'opérande de sizeof ne peut pas être un champ de bits",
  null,
  null,
  null,
  "l'opérande de '*' doit être un pointeur mais il a le type %t",
  "l'argument de la macro est vide",
  "cette déclaration n'a pas de classe de stockage ou de spécificateur de type",
  "une déclaration de paramètre ne peut pas avoir d'initialiseur",
  "spécificateur de type attendu",
  "impossible de spécifier une classe de stockage ici",
  "impossible de spécifier plus d'une classe de stockage",
  "la classe de stockage n'est pas la première",
  "le qualificateur de type est spécifié plusieurs fois",
  "combinaison de spécificateurs de type non valide",
  "classe de stockage non valide pour un paramètre",
  "classe de stockage non valide pour une fonction",
  "impossible d'utiliser un spécificateur de type ici",
  "tableau de fonctions non autorisé",
  "tableau de types void non autorisé",
  "une fonction qui retourne une fonction n'est pas autorisée",
  "une fonction qui retourne un tableau n'est pas autorisée",
  "les paramètres de liste d'identificateurs peuvent uniquement être utilisés dans une définition de fonction",
  "le type de fonction ne peut pas provenir d'un typedef",
  "la taille d'un tableau doit être supérieure à zéro",
  "tableau trop grand",
  "une unité de traduction doit contenir au moins une déclaration",
  "une fonction ne peut pas retourner une valeur de ce type",
  "un tableau ne peut pas contenir d'éléments de ce type",
  "une déclaration ici doit déclarer un paramètre",
  "nom de paramètre dupliqué",
  "%sq a déjà été déclaré dans la portée actuelle",
  "déclaration anticipée de type enum non standard",
  "classe trop grande",
  "struct ou union trop grande",
  "taille de champ de bits non valide",
  "type de champ de bits non valide",
  "un champ de bits de longueur nulle ne doit pas être nommé",
  "champ de bits signé de longueur 1",
  "l'expression qui précède les parenthèses de l'appel apparent doit avoir le type de fonction (pointeur-à-)",
  "définition ou nom de balise attendu",
  "instruction inaccessible",
  "'while' attendu",
  null,
  "%n a été référencé mais n'est pas défini",
  "une instruction Continue ne peut être utilisée que dans une boucle",
  "une instruction Break peut uniquement être utilisée dans une boucle ou un commutateur",
  "%n non void doit retourner une valeur",
  "une fonction void ne peut pas retourner une valeur",
  "cast vers le type %t non autorisé",
  "le type valeur de retour ne correspond pas au type de fonction",
  "une étiquette case peut uniquement être utilisée dans un commutateur",
  "une étiquette par défaut peut uniquement être utilisée dans un commutateur",
  null,
  "l'étiquette par défaut apparaît déjà dans ce commutateur",
  "'(' attendu",
  "l'expression doit être une lvalue",
  "instruction attendue",
  "boucle inaccessible",
  "une fonction avec portée de bloc ne peut avoir qu'une classe de stockage externe",
  "'{' attendu",
  "l'expression doit avoir un type pointeur vers classe mais elle a le type %t",
  "l'expression doit avoir un type pointeur vers struct ou union mais elle a le type %t",
  "nom de membre attendu",
  "nom de champ attendu",
  "%n n'a pas de membre %sq",
  "%n n'a pas de champ %sq",
  "l'expression doit être une valeur modifiable",
  "prise d'adresse d'une variable de registre non autorisée",
  "prise d'adresse d'un champ de bits non autorisée",
  "trop d'arguments dans l'appel de fonction",
  "paramètres prototypés sans nom non autorisés lorsque le corps est présent",
  "l'expression doit avoir un type pointeur vers objet mais elle a le type %t",
  "programme trop volumineux ou complexe pour être compilé",
  "impossible d'utiliser une valeur de type %t1 pour initialiser une entité de type %t2",
  "impossible d'initialiser %n",
  "trop de valeurs d'initialiseur",
  "déclaration incompatible avec %nfd",
  "%n a déjà été initialisé",
  "une déclaration de portée globale ne peut pas avoir cette classe de stockage",
  "impossible de redéclarer un nom de type en tant que paramètre",
  "impossible de redéclarer un nom de typedef en tant que paramètre",
  "conversion d'entier non nul en pointeur",
  "l'expression doit avoir un type classe mais elle a le type %t",
  "l'expression doit avoir un type struct ou union mais elle a le type %t",
  "ancien opérateur d'assignation",
  "ancien initialiseur",
  "l'expression doit avoir une expression constante intégrale",
  "l'expression doit être une lvalue ou un désignateur de fonction",
  "la déclaration est incompatible avec le %nod précédent",
  "conflit entre le nom externe et celui de %nd",
  "#pragma non reconnu",
  null,
  "impossible d'ouvrir le fichier temporaire %sq : %s2",
  "le nom du répertoire de fichiers temporaires est trop long (%sq)",
  "arguments insuffisants dans l'appel de fonction",
  "constante flottante non valide",
  "l'argument de type %t1 est incompatible avec le paramètre de type %t2",
  "type de fonction non autorisé ici",
  "déclaration attendue",
  "le pointeur pointe en dehors de l'objet sous-jacent",
  "conversion de type non valide",
  "conflit entre la liaison externe/interne et la déclaration précédente %p",
  "la valeur à virgule flottante ne peut pas être contenue dans le type intégral requis",
  "Expression sans effet",
  "Indice hors limites",
  null,
  "%n est déclaré mais n'a pas été référencé",
  "l'application de '&' à un tableau n'a aucun effet",
  "l'opérande droit de '%%' est égal à zéro",
  "argument incompatible avec le paramètre formel",
  "argument incompatible avec la conversion de chaîne de format correspondante",
  "impossible d'ouvrir le fichier source %sq (aucun répertoire dans la liste de recherche)",
  "le type de cast doit être intégral",
  "le type de cast doit être arithmétique ou pointeur",
  "initialisation dynamique dans du code inaccessible",
  "comparaison inutile d'entier non signé avec zéro",
  "l'utilisation de '=' where '==' est peut-être intentionnelle",
  "type énuméré mélangé à un autre type",
  "erreur lors de l'écriture du fichier %s",
  "fichier de langage intermédiaire non valide",
  "le qualificateur de type sur le type de cast n'a pas de sens",
  "caractère de séquence d'échappement non reconnu",
  "zéro utilisé pour l'identificateur de prétraitement non défini %sq",
  "chaîne asm attendue",
  "une fonction asm doit être prototypée",
  "une fonction asm ne peut pas avoir de points de suspension",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "erreur lors de la suppression du fichier %sq : %s2",
  "la valeur intégrale ne peut pas être contenue dans le type virgule flottante requis",
  "la valeur à virgule flottante ne peut pas être contenue dans le type virgule flottante requis",
  "le résultat de l'opération en virgule flottante est hors limites",
  "fonction %sq déclarée implicitement",
  "la chaîne de format requiert d'autres arguments",
  "la chaîne de format se termine avant cet argument",
  "conversion de chaîne de format non valide",
  "récursivité de macro",
  "virgule de fin non standard",
  "le champ de bits ne peut pas contenir toutes les valeurs du type énuméré",
  "type de champ de bits non standard",
  "déclaration non visible en dehors de la fonction",
  "ancien typedef de 'void' ignoré",
  "l'opérande gauche n'est pas un struct/union contenant ce champ",
  "le pointeur ne pointe pas vers un struct/union contenant ce champ",
  "variable %sq déclarée avec un type inachevé",
  "l'expression de contrôle est constante",
  "l'expression du sélecteur est constante",
  "spécificateur non valide sur un paramètre",
  "spécificateur non valide en dehors d'une déclaration de classe",
  "spécificateur dupliqué dans la déclaration",
  "une union ne peut pas avoir de classe de base",
  "plusieurs spécificateurs de contrôle d'accès non autorisés",
  "définition de classe ou de struct manquante",
  "le nom qualifié n'est pas membre de la classe %t ou de ses classes de base",
  "une référence de membre non statique doit être relative à un objet spécifique",
  "impossible de définir un membre de données non statique en dehors de sa classe",
  "%n a déjà été défini",
  "pointeur vers référence non autorisé",
  "référence à référence non autorisée",
  "référence à void non autorisée",
  "tableau de références non autorisé",
  "la référence %n requiert un initialiseur",
  "',' attendu",
  "nom de type non autorisé",
  "définition de type non autorisée",
  "redéclaration de nom de type %nod non valide",
  "la constante %n requiert un initialiseur",
  "'this' peut uniquement être utilisé dans une fonction membre non statique",
  "valeur de constante inconnue",
  "type explicite manquant ('int' pris par défaut)",
  "contrôle d'accès non spécifié (%sq pris par défaut)",
  "n'est pas un nom de classe ou de struct",
  "nom de la classe de base dupliqué",
  "classe de base non valide",
  "%nd est inaccessible",
  "%no est ambigu",
  "ancienne liste de paramètres (anachronisme)",
  "la déclaration ne peut pas s'afficher après l'instruction exécutable dans le bloc",
  "conversion à la classe de base inaccessible %t non autorisée",
  null,
  null,
  null,
  null,
  "arrêt incorrect d'appel de macro",
  null,
  "un nom suivi de '::' doit être un nom de classe ou d'espace de noms",
  "déclaration Friend non valide",
  "un constructeur ou destructeur ne peut pas retourner de valeur",
  "déclaration de destructeur non valide",
  "déclaration d'un membre portant le même nom que sa classe",
  "qualificateur de portée globale ('::' de début) non autorisé",
  "la portée globale n'a pas de %sq",
  "nom qualifié non autorisé",
  "référence NULL non autorisée",
  "initialisation avec '{...}' non autorisée pour un objet de type %t",
  "classe de base %t ambiguë",
  "la classe dérivée %t1 contient plusieurs instances de la classe %t2",
  "impossible de convertir un pointeur vers la classe de base %t2 en pointeur vers la classe dérivée %t1 -- la classe de base est virtuelle",
  "aucune instance du constructeur %no ne correspond à la liste d'arguments",
  "le constructeur de copie de la classe %t est ambigu",
  "il n'existe aucun constructeur par défaut pour la classe %t",
  "%sq n'est ni un membre de données non statique ni une classe de base de la classe %t",
  "classe de base non virtuelle indirecte non autorisée",
  "membre d'union non valide -- la classe %t a une fonction membre non autorisée",
  null,
  "utilisation non valide d'un tableau de valeurs non-lvalue",
  "opérateur attendu",
  "membre hérité non autorisé",
  "impossible de déterminer l'instance de %n voulue",
  "un pointeur vers une fonction liée peut uniquement être utilisé pour appeler la fonction",
  "le nom de typedef a déjà été déclaré (avec le même type)",
  "%n a déjà été défini",
  null,
  "aucune instance de %n ne correspond à la liste d'arguments",
  "la définition de type n'est pas autorisée dans la déclaration de type de retour de la fonction",
  "l'argument par défaut n'est pas situé à la fin de la liste de paramètres",
  "redéfinition de l'argument par défaut",
  "plusieurs instances de %n correspondent à la liste d'arguments :",
  "plusieurs instances du constructeur %no correspondent à la liste d'arguments :",
  "argument par défaut de type %t1 incompatible avec le paramètre de type %t2",
  "impossible de surcharger des fonctions distinguées par le type de retour uniquement",
  "il n'existe aucune conversion définie par l'utilisateur appropriée de %t1 en %t2",
  null,
  "seules les fonctions membres non statiques peuvent être virtuelles",
  "l'objet a des qualificateurs de type incompatibles avec la fonction membre",
  "programme trop volumineux pour la compilation (trop de fonctions virtuelles)",
  "le type de retour n'est ni identique à ni covariant avec le type de retour %t de la fonction virtuelle substituée %no",
  "substitution de fonction %n virtuelle ambiguë",
  "spécificateur pure ('= 0') autorisé uniquement sur les fonctions virtuelles",
  "spécificateur pure incorrect (seul '= 0' est autorisé)",
  "initialiseur de membre de données non autorisé",
  "objet de type classe abstraite %t non autorisé :",
  "une fonction qui retourne une classe abstraite %t n'est pas autorisée :",
  "déclaration Friend dupliquée",
  "spécification inline autorisée uniquement sur les déclarations de fonction",
  "'inline' n'est pas autorisé",
  "classe de stockage non valide pour une fonction inline",
  "classe de stockage non valide pour un membre de classe",
  "le membre de classe locale %n requiert une définition",
  "%nfd inaccessible",
  null,
  "la classe %t n'a pas de constructeur de copie pour copier un objet const",
  "la définition d'une fonction membre déclarée implicitement n'est pas autorisée",
  "la classe %t n'a pas de constructeur de copie approprié",
  "spécification de liaison non autorisée",
  "spécification de liaison externe inconnue",
  "spécification de liaison incompatible avec le %nod précédent",
  "plusieurs instances de la fonction surchargée %no ont une liaison 'C'",
  "la classe %t a plusieurs constructeurs par défaut",
  "valeur copiée dans le dossier temporaire, référence au dossier temporaire utilisée",
  "'operator%s' doit être une fonction membre",
  "l'opérateur ne peut pas être une fonction membre statique",
  "aucun argument autorisé sur une conversion définie par l'utilisateur",
  "trop de paramètres pour cette fonction opérateur",
  "paramètres insuffisants pour cette fonction opérateur",
  "un opérateur non membre requiert un paramètre avec un type classe",
  "argument par défaut non autorisé",
  "plusieurs conversions définies par l'utilisateur de %t1 en %t2 s'appliquent :",
  "aucun opérateur %sq ne correspond à ces opérandes",
  "plusieurs opérateurs %sq correspondent à ces opérandes :",
  "le premier paramètre de la fonction d'allocation doit être de type 'size_t'",
  "la fonction d'allocation requiert le type de retour 'void *'",
  "la fonction de désallocation requiert le type de retour 'void'",
  "le premier paramètre de la fonction de désallocation doit être de type 'void *'",
  null,
  "le type doit être un type objet",
  "la classe de base %t a déjà été initialisée",
  "nom de la classe de base requis -- %t pris par défaut (anachronisme)",
  "%n a déjà été initialisé",
  "nom de membre ou de classe de base manquant",
  "assignation à 'this' (anachronisme)",
  "mot clé 'overload' utilisé (anachronisme)",
  "union anonyme non valide -- membre non public non autorisé",
  "union anonyme non valide -- fonction membre non autorisée",
  "une union anonyme au niveau de la portée globale ou de la portée espace de noms doit être déclarée statique",
  "%nf ne fournit aucun initialiseur pour :",
  "impossible d'initialiser un constructeur généré implicitement pour la classe %t :",
  "%n ne définit aucun constructeur pour l'initialisation de :",
  "%n a un const ou un membre de référence non initialisé",
  "%n a un champ const non initialisé",
  "la classe %t n'a pas d'opérateur d'assignation pour copier un objet const",
  "la classe %t n'a pas d'opérateur d'assignation approprié",
  "opérateur d'assignation ambigu pour la classe %t",
  null,
  "la déclaration requiert un nom de typedef",
  null,
  "'virtual' non autorisé",
  "'static' non autorisé",
  "cast de fonction liée en pointeur fonction normal (anachronisme)",
  "l'expression doit avoir un type pointeur vers membre",
  "';' supplémentaire ignoré",
  "in-class initializer non standard pour un membre non statique",
  null,
  "aucune instance de %no surchargé ne correspond à la liste d'arguments",
  null,
  "aucune instance de %n ne correspond au type requis",
  "expression delete array size utilisée (anachronisme)",
  null,
  "cast en classe abstraite %t non autorisé :",
  "impossible d'appeler la fonction 'main' ou de prendre son adresse",
  "impossible de spécifier un new-initializer pour un tableau",
  "impossible de redéclarer la fonction membre %no en dehors de sa classe",
  "le pointeur vers le type classe incomplet %t n'est pas autorisé",
  "référence à une variable locale de fonction englobante non autorisée",
  "fonction à argument unique utilisée pour %sq suffixé (anachronisme)",
  null,
  "l'opérateur d'assignation généré implicitement ne peut pas copier :",
  "cast en type tableau non standard (considéré comme cast en %t)",
  "%n a un opérateur new%s(), mais pas d'opérateur delete%s() par défaut",
  "%n a un opérateur delete%s() par défaut, mais pas d'opérateur new%s()",
  "le destructeur de la classe de base %nod est non virtuel",
  null,
  "redéclaration non valide du membre %npd",
  "impossible de déclarer la fonction 'main' inline",
  "une fonction membre du même nom que sa classe doit être un constructeur",
  "utilisation de la classe %n imbriquée (anachronisme)",
  "un destructeur ne peut pas avoir de paramètres",
  "le constructeur de copie de la classe %t ne peut pas avoir de paramètre de type %t",
  "%n retourne le type incomplet %t",
  "%nd protégé inaccessible via un pointeur ou objet %t",
  "paramètre non autorisé",
  "déclaration 'asm' non autorisée ici",
  "il n'existe aucune fonction de conversion appropriée de %t1 en %t2",
  "suppression d'un pointeur vers une classe incomplète",
  "il n'existe aucun constructeur approprié pour la conversion de %t1 en %t2",
  "plusieurs constructeurs s'appliquent à la conversion de %t1 en %t2 :",
  "plusieurs fonctions de conversion de %t1 en %t2 s'appliquent :",
  "plusieurs fonctions de conversion de %t en type intégré s'appliquent :",
  "const %n",
  "référence %n",
  "%npTd",
  "opérateur intégré %sq",
  "%nod, ambigu par héritage",
  "impossible de prendre l'adresse d'un constructeur ou d'un destructeur",
  null,
  "utilisation temporaire pour la valeur initiale d'une référence à une non-constante (anachronisme)",
  "nom qualifié non autorisé dans la déclaration de membre",
  "type énuméré mélangé à un autre type (anachronisme)",
  "la taille d'un tableau dans 'new' ne doit pas être négative",
  "retour de référence à la mémoire temporaire locale",
  null,
  "déclaration 'enum' non autorisée",
  "qualificateurs supprimés dans une référence de liaison de type %t1 à un initialiseur de type %t2",
  "impossible d'initialiser une référence de type %t1 (non qualifié const) avec une valeur de type %t2",
  "impossible de supprimer un pointeur vers une fonction",
  "la fonction de conversion doit être une fonction membre non statique",
  "déclaration de modèle non autorisée ici",
  "'<' attendu",
  "'>' attendu",
  "déclaration de paramètre de modèle manquante",
  "liste d'arguments de %nf manquante",
  "arguments insuffisants pour %nf",
  "trop d'arguments pour %nf",
  null,
  "%n1 n'est pas utilisé pour la déclaration des types de paramètres de %n2",
  "deux types imbriqués ont le même nom : %no1 et %nod2 (compatibilité cfront)",
  "%no1 global déclaré après %nod2 imbriqué (compatibilité cfront)",
  null,
  "plusieurs instances de %n correspondent au type requis",
  "type 'long long' non standard",
  "omission de %sq non standard",
  "impossible de spécifier un type de retour sur une fonction de conversion",
  "détecté pendant :",
  "instanciation de %nt %p",
  "génération implicite de %nt %p",
  "récursivité excessive lors de l'instanciation de %n",
  "%sq n'est pas une fonction ou un membre de données statique",
  "l'argument de type %t1 est incompatible avec le paramètre de modèle de type %t2",
  "une initialisation nécessitant un type temporaire ou une conversion n'est pas autorisée",
  "la déclaration de %sq masque le paramètre de fonction",
  "la valeur initiale d'une référence non const doit être une lvalue",
  "définition implicite de %nt %p",
  "'template' non autorisé",
  "%t n'est pas un modèle de classe",
  null,
  "'main' n'est pas un nom valide pour un modèle de fonction",
  "référence non valide à %n (discordance union/non union)",
  "un argument template ne peut pas référencer un type local",
  "genre de balise de %s incompatible avec la déclaration de %nfd",
  "la portée globale n'a pas de balise nommée %sq",
  "%n n'a pas de membre de balise nommé %sq",
  "typedef de fonction membre (autorisé pour compatibilité cfront)",
  "%n peut être utilisé uniquement dans une déclaration de pointeur vers membre",
  null,
  "un argument template ne peut pas référencer une entité non externe",
  "un nom suivi de '::~' doit être un nom de classe ou de type",
  null,
  "le type utilisé comme nom de destructeur ne correspond pas au type %t",
  "%n redéclaré 'inline' après avoir été appelé",
  null,
  "classe de stockage non valide pour une déclaration de modèle",
  "%nd est un type inaccessible (autorisé pour compatibilité cfront)",
  null,
  "déclaration d'instanciation explicite non valide",
  "%nf n'est pas une entité instanciable",
  "impossible d'instancier explicitement %n généré par compilateur",
  "impossible d'instancier explicitement %n inline",
  null,
  "impossible d'instancier %n -- aucune définition de modèle fournie",
  "impossible d'instancier %n -- explicitement spécialisé",
  null,
  null,
  "aucune instance de %n ne correspond au type spécifié",
  "la déclaration d'une liste de paramètres void avec un typedef est non standard",
  "%n1 global utilisé à la place de %n2 (compatibilité cfront)",
  "impossible de redéclarer le paramètre de modèle %sq dans cette portée",
  "la déclaration de %sq masque le paramètre de modèle",
  "la liste d'arguments template doit correspondre à la liste de paramètres",
  null,
  "le paramètre supplémentaire de 'operator%s' suffixé doit être de type 'int'",
  "un nom d'opérateur doit être déclaré en tant que fonction",
  "nom d'opérateur non autorisé",
  "impossible de spécialiser %n dans la portée actuelle",
  "forme non standard pour la prise d'adresse d'une fonction membre",
  "paramètres de modèle insuffisants -- ne correspond pas à la déclaration précédente (%p déclaré)",
  "trop de paramètres de modèle -- ne correspond pas à la déclaration précédente (%p déclaré)",
  "modèle de fonction non autorisé pour l'opérateur delete(void *)",
  "le modèle de classe et le paramètre de modèle ont peut-être des noms différents",
  null,
  "un argument template ne peut pas référencer un type sans nom",
  "cette opération sur un type énuméré nécessite une fonction opérateur définie par l'utilisateur applicable",
  "qualificateur de type sur un type référence non autorisé",
  "impossible d'assigner une valeur de type %t1 à une entité de type %t2",
  "la comparaison d'un entier non signé avec une constante négative n'a pas de sens",
  "conversion en classe incomplète %t impossible",
  "un objet const requiert un initialiseur",
  "l'objet a un const ou un membre de référence non initialisé",
  "directive de prétraitement non standard",
  "%n ne peut pas avoir de liste d'arguments template",
  "initialisation avec '{...}' attendue pour un objet d'agrégation",
  "types de classe de sélection du pointeur vers membre incompatibles (%t1 et %t2)",
  "déclaration Friend inutile",
  "'.' utilisé à la place de '::' pour former un nom qualifié",
  "appel de fonction non const pour un objet const (anachronisme)",
  "une instruction dépendante ne peut pas être une déclaration",
  "un paramètre ne peut pas avoir le type void",
  "instanciation de %na %p",
  "traitement de la liste d'arguments template pour %na %p",
  "cet opérateur n'est pas autorisé dans une expression d'argument template",
  "un bloc try requiert au moins un gestionnaire",
  "le gestionnaire requiert une déclaration d'exception",
  "le gestionnaire est masqué par le gestionnaire par défaut",
  "le gestionnaire est potentiellement masqué par le gestionnaire précédent pour le type %t",
  "utilisation d'un type local pour spécifier une exception",
  "type redondant dans la spécification d'exception",
  "spécification d'exception incompatible avec celle du %nd%s précédent",
  "précédemment spécifié : aucune exception ne sera levée",
  "précédemment omis : %t",
  "précédemment spécifié mais omis ici : %t",
  "prise en charge de gestion d'exceptions désactivée",
  "l'autorisation de toutes les exceptions est incompatible avec le %nd précédent",
  "impossible de créer le fichier de requête d'instanciation %sq",
  "opération non arithmétique non autorisée dans un argument template sans type",
  "utilisation d'un type local pour la déclaration d'une variable non locale",
  "utilisation d'un type local pour la déclaration d'une fonction",
  "le transfert de contrôle ignore l'initialisation de :",
  "%nd",
  "transfert de contrôle dans un gestionnaire d'exceptions",
  "%n utilisé avant la définition de sa valeur",
  "%n défini mais jamais utilisé",
  "impossible de définir %n dans la portée actuelle",
  "la spécification de l'exception n'est pas autorisée",
  "conflit de liaison externe/interne pour %nfd",
  "%nf ne sera pas appelé pour des conversions implicites ou explicites",
  "le genre de balise de %s est incompatible avec le paramètre de modèle de type %t",
  "modèle de fonction non autorisé pour l'opérateur new(size_t)",
  null,
  "pointeur vers membre de type %t non autorisé",
  "points de suspension non autorisés dans la liste de paramètres de fonction de l'opérateur",
  "%no réservé pour un usage futur en tant que mot clé",
  "définition de macro non valide : %s",
  "suppression de définition de macro non valide : %s",
  null,
  null,
  "le nom de fichier IL doit être spécifié si l'entrée est ",
  null,
  null,
  null,
  null,
  "erreur dans l'argument d'option de débogage",
  "option non valide : %s",
  "le système principal requiert le nom du fichier IL",
  "impossible d'ouvrir le fichier IL %s",
  "numéro non valide : %s",
  "id d'UC hôte incorrect",
  "mode d'instanciation non valide : %s",
  null,
  "limite d'erreur non valide : %s",
  null,
  null,
  null,
  null,
  null,
  null,
  "les tables de fonctions virtuelles peuvent uniquement être supprimées lors de la compilation de C++",
  "l'option anachronisme peut uniquement être utilisée lors de la compilation de C++",
  "l'option de mode d'instanciation peut uniquement être utilisée lors de la compilation de C++",
  "le mode d'instanciation automatique peut uniquement être utilisé lors de la compilation de C++",
  "le mode d'inclusion de modèle implicite peut uniquement être utilisé lors de la compilation de C++",
  "l'option de gestion des exceptions peut uniquement être utilisée lors de la compilation de C++",
  "le mode strict est incompatible avec le mode K&R",
  "le mode strict est incompatible avec le mode cfront",
  "nom de fichier source manquant",
  "impossible de spécifier les fichiers de sortie lors de la compilation de plusieurs fichiers d'entrée",
  "trop d'arguments dans la ligne de commande",
  "un fichier de sortie a été spécifié, mais aucun n'est requis",
  "l'affichage IL requiert le nom du fichier IL",
  "un paramètre de modèle ne peut pas avoir le type void",
  "instanciation récursive excessive de %n en raison du mode d'instanciation complète",
  "le mode strict est incompatible avec l'autorisation d'anachronismes",
  "une expression Throw ne peut pas avoir le type void",
  "mode d'instanciation locale incompatible avec l'instanciation automatique",
  "paramètre de type classe abstraite %t non autorisé :",
  "tableau de classes abstraites %t non autorisé :",
  "paramètre de modèle à virgule flottante non standard",
  "ce pragma doit précéder immédiatement une déclaration",
  "ce pragma doit précéder immédiatement une instruction",
  "ce pragma doit précéder immédiatement une déclaration ou une instruction",
  "impossible d'utiliser ce genre de pragma ici",
  null,
  "la fonction virtuelle surchargée %no1 n'est que partiellement substituée dans %n2",
  "la définition spécifique de la fonction avec modèle inline doit précéder sa première utilisation",
  "balise d'erreur non valide dans l'option de contrôle de diagnostic : %s",
  "numéro d'erreur non valide dans l'option de contrôle de diagnostic : %s",
  null,
  null,
  "fonction pointeur vers membre castée en pointeur vers fonction",
  "le struct ou l'union ne déclare aucun membre nommé",
  "champ sans nom non standard",
  "membre sans nom non standard",
  null,
  null,
  null,
  "%sq n'est pas un type de nom",
  "impossible d'ouvrir le fichier d'entrée d'en-tête précompilé %sq : %s2",
  "le fichier d'en-tête précompilé %sq n'est pas valide ou n'est pas généré par cette version du compilateur",
  "le fichier d'en-tête précompilé %sq n'a pas été généré dans ce répertoire",
  "les fichiers d'en-tête utilisés pour générer le fichier d'en-tête précompilé %sq ont été modifiés",
  "les options de ligne de commande ne correspondent pas à celles utilisées lors de la création du fichier d'en-tête précompilé %sq",
  "la séquence initiale des directives de prétraitement est incompatible avec celle du fichier d'en-tête précompilé %sq",
  "impossible d'obtenir la mémoire mappée",
  "'%s' : utilisation du fichier d'en-tête précompilé '%s'",
  "'%s' : création du fichier d'en-tête précompilé '%s'",
  "conflit d'utilisation de mémoire avec le fichier d'en-tête précompilé %sq",
  "taille de mémoire PCH non valide : %s ",
  "les options PCH doivent apparaître en premier dans la ligne de commande",
  "mémoire insuffisante pour l'allocation de mémoire PCH",
  "impossible d'utiliser des fichiers d'en-tête précompilés lors de la compilation de plusieurs fichiers d'entrée",
  "mémoire préallouée insuffisante pour la génération du fichier d'en-tête précompilé (%s octets requis)",
  "une très grande entité dans le programme empêche la génération du fichier d'en-tête précompilé",
  "%sq n'est pas un répertoire valide",
  "impossible de générer un nom de fichier temporaire",
  "'restrict' non autorisé",
  "impossible de qualifier un pointeur vers un type de fonction ou une référence à ce dernier par 'restrict'",
  null,
  "impossible de spécifier un modificateur de convention d'appel ici",
  "modificateurs de convention d'appel en conflit",
  "le mode strict est incompatible avec le mode Microsoft",
  "le mode cfront est incompatible avec le mode Microsoft",
  "la convention d'appel spécifiée ici est ignorée",
  "une convention d'appel ne peut pas être suivie d'un déclarateur imbriqué",
  "convention d'appel ignorée pour ce type",
  null,
  "modificateurs de déclaration incompatibles avec la déclaration précédente",
  "modificateur %sq non autorisé sur cette déclaration",
  "transfert de contrôle dans un bloc try",
  "spécification inline incompatible avec %nod précédent",
  "accolade fermante de déclaration de modèle introuvable",
  "l'option de mot clé wchar_t peut uniquement être utilisée lors de la compilation de C++",
  "valeur d'alignement de compression non valide",
  "constante entière attendue",
  "appel de fonction virtuelle pure",
  "chaîne d'identificateur de fichier source non valide",
  "impossible de définir un modèle de classe dans une déclaration Friend",
  "'asm' non autorisé",
  "'asm' doit être utilisé avec une définition de fonction",
  "fonction 'asm' non standard",
  "des points de suspension avec des paramètres non explicites sont non standard",
  "'&...' non standard",
  "utilisation non valide de '&...'",
  null,
  "utilisation temporaire pour la valeur initiale d'une référence const volatile (anachronisme)",
  "impossible d'initialiser une référence de type %t1 avec une valeur de type %t2",
  "la valeur initiale de la référence const volatile doit être une lvalue",
  "l'option de compatibilité C SVR4 peut uniquement être utilisée lors de la compilation de C ANSI",
  "utilisation d'une déclaration hors de portée de %nd",
  "le mode strict est incompatible avec le mode C SVR4",
  "l'appel de %nd ne peut pas être inlined",
  "%n ne peut pas être inlined",
  "répertoire PCH non valide : %s",
  "__except ou __finally attendu",
  "une instruction a __leave peut uniquement être utilisée dans a __try",
  "détecté lors de l'instanciation de %nt %p",
  "détecté lors de la génération implicite de %nt %p",
  "détecté lors de l'instanciation de %na %p",
  "détecté lors du traitement de la liste d'arguments template de %na %p",
  "détecté lors de la définition implicite de %nt %p",
  "%sq introuvable dans la pile d'alignement de compression",
  "pile d'alignement de compression vide",
  "l'option RTTI peut uniquement être utilisée lors de la compilation de C++",
  "%nfd, requis pour la copie supprimée, est inaccessible",
  "%nf, requis pour la copie supprimée, ne peut pas être appelé car le paramètre de référence ne peut pas être lié à rvalue",
  "<typeinfo> doit être inclus avant l'utilisation de typeid",
  "%s ne peut pas caster une constante ou d'autres qualificateurs de type",
  "dans dynamic_cast, le type doit être un pointeur vers ou une référence à un type classe complète, ou void *",
  "l'opérande d'un dynamic_cast de pointeur doit être un pointeur vers un type classe complète",
  "l'opérande d'un dynamic_cast de référence doit être une lvalue de type classe complète",
  "l'opérande d'un dynamic_cast d'exécution doit avoir un type classe polymorphe",
  "l'option bool peut uniquement être utilisée lors de la compilation de C++",
  null,
  "type de tableau non autorisé ici",
  "'=' attendu",
  null,
  "%sq, déclaré dans la condition, ne peut pas être redéclaré dans cette portée",
  "arguments template par défaut non autorisés pour les modèles de fonction",
  "',' ou '>' attendu",
  "liste de paramètres de modèle attendue",
  "incrémentation de valeur booléenne déconseillée",
  "type booléen non autorisé",
  "offset de classe de base %no1 dans classe %no2 trop important",
  "l'expression doit avoir le type booléen (ou être convertible en booléen)",
  "l'option array new et delete peut uniquement être utilisée lors de la compilation de C++",
  "%n n'est pas un nom de variable",
  "modificateur __based non autorisé ici",
  "__based ne précède pas un opérateur de pointeur, __based ignoré",
  "la variable du modificateur __based doit avoir le type pointeur",
  "le type de const_cast doit être un pointeur, une référence ou un pointeur vers un membre de type objet",
  "const_cast peut uniquement ajuster les qualificateurs de type ; il ne peut pas modifier le type sous-jacent",
  "mutable non autorisé",
  "la redéclaration de %n ne peut pas modifier son accès",
  null,
  "l'utilisation du jeton alternatif '<:' semble involontaire",
  "l'utilisation du jeton alternatif '%%:' semble involontaire",
  "définition d'espace de noms non autorisée",
  "le nom doit être un nom d'espace de noms",
  "définition d'alias d'espace de noms non autorisée",
  "un nom qualifié par un espace de noms est requis",
  "nom d'espace de noms non autorisé",
  "combinaison d'attributs DLL non valide",
  "%n n'est pas un modèle de classe",
  "tableau avec type d'élément incomplet non standard",
  "impossible de déclarer un opérateur d'allocation dans un espace de noms",
  "impossible de déclarer un opérateur de désallocation dans un espace de noms",
  "%np1 en conflit avec la déclaration using de %np2",
  "déclaration using de %np1 en conflit avec %npd2",
  "l'option espaces de noms peut uniquement être utilisée lors de la compilation de C++",
  "déclaration using ignorée -- elle fait référence à l'espace de noms actuel",
  "un nom qualifié par une classe est requis",
  "les types d'arguments sont : (%s)",
  "les types d'opérandes sont : %s",
  null,
  "%n n'a pas de membre réel %sq",
  null,
  "attributs de mémoire incompatibles spécifiés",
  "attribut de mémoire ignoré",
  "l'attribut de mémoire ne peut pas être suivi d'un déclarateur imbriqué",
  "attribut de mémoire spécifié plusieurs fois",
  "convention d'appel spécifiée plusieurs fois",
  "qualificateur de type non autorisé",
  "%npd1 a été utilisé avant la déclaration de son modèle",
  "impossible de surcharger des fonctions membres statiques et non statiques avec les mêmes types de paramètres",
  "aucune déclaration antérieure de %np",
  "id de modèle non autorisé",
  "nom qualifié par une classe non autorisé",
  "impossible de redéclarer %n dans la portée actuelle",
  "nom qualifié non autorisé dans la déclaration de membre d'espace de noms",
  "%n n'est pas un nom de type",
  "instanciation explicite non autorisée dans la portée actuelle",
  "impossible d'instancier explicitement %n dans la portée actuelle",
  "%n instancié explicitement plusieurs fois",
  "typename peut uniquement être utilisé dans un modèle",
  "l'option special_subscript_cost peut uniquement être utilisée lors de la compilation de C++",
  "l'option typename peut uniquement être utilisée lors de la compilation de C++",
  "l'option typename implicite peut uniquement être utilisée lors de la compilation de C++",
  "caractère non standard au début d'une définition de macro de type objet",
  "spécification d'exception pour %n1 virtuel incompatible avec celle de %n2 substitué",
  "conversion de pointeur en entier plus petit",
  "spécification d'exception pour %n1 virtuel déclaré implicitement incompatible avec celle de %n2 substitué",
  "%no1, implicitement appelé à partir de %np2, est ambigu",
  "l'option 'explicit' peut uniquement être utilisée lors de la compilation de C++",
  "'explicit' non autorisé",
  "déclaration en conflit avec %sq (nom de classe réservé)",
  "seul '()' est autorisé comme initialiseur du tableau %n",
  "'virtual' non autorisé dans une déclaration de modèle de fonction",
  "union anonyme non valide -- modèle de membre de classe non autorisé",
  "la limite des niveaux d'imbrication des modèles ne correspond pas à la déclaration précédente de %n",
  "cette déclaration ne peut pas avoir plusieurs clauses 'template <...>'",
  "l'option de contrôle de la portée de for-init peut uniquement être utilisée lors de la compilation de C++",
  "%sq, déclaré dans l'initialisation for-loop, ne peut pas être redéclaré dans cette portée",
  "référence à %nd1 -- référence à %nd2 sous les anciennes règles de portée",
  "l'option de contrôle des avertissements sur les différences de for-init peut uniquement être utilisée lors de la compilation de C++",
  "définition de %n virtuel requise ici",
  "commentaire vide interprété comme opérateur de collage de jeton '##'",
  "classe de stockage non autorisée dans une déclaration Friend",
  "liste de paramètres de modèle de %no non autorisée dans cette déclaration",
  "%n n'est pas un modèle de membre de classe valide",
  "classe membre ou modèle de fonction non valide",
  "une déclaration de modèle contenant une liste de paramètres de modèle ne peut pas être suivie d'une déclaration de spécialisation explicite",
  "la spécialisation explicite de %n1 doit précéder la première utilisation de %n2",
  "spécialisation explicite non autorisée dans la portée actuelle",
  "spécialisation partielle de %n non autorisée",
  "%nf n'est pas une entité pouvant être explicitement spécialisée",
  "la spécialisation explicite de %n doit précéder sa première utilisation",
  "impossible d'utiliser le paramètre de modèle %sq dans un spécificateur de type élaboré",
  "la spécialisation de %n requiert la syntaxe 'template<>'",
  null,
  null,
  "l'option 'old_specializations' peut uniquement être utilisée lors de la compilation de C++",
  "spécialisation de %n sans syntaxe 'template<>' non standard",
  "cette déclaration ne peut pas avoir de liaison 'C' externe",
  "%sq n'est pas un nom de classe ou de modèle de fonction dans la portée actuelle",
  "la spécification d'un argument par défaut lors de la redéclaration d'un modèle de fonction non référencé est non standard",
  "la spécification d'un argument par défaut lors de la redéclaration d'un modèle de fonction déjà référencé n'est pas autorisée",
  "impossible de convertir un pointeur vers un membre de la classe de base %t2 en pointeur vers un membre de la classe dérivée %t1 -- la classe de base est virtuelle",
  "spécification d'exception incompatible avec celle de %nd%s",
  "l'autorisation de toutes les exceptions est incompatible avec %nd",
  "fin inattendue d'expression d'argument par défaut",
  "initialisation par défaut de référence non autorisée",
  "%n non initialisé a un membre const",
  "la classe de base non initialisée %t a un membre const",
  "const %n requiert un initialiseur -- la classe %t n'a pas de constructeur par défaut fourni par l'utilisateur",
  "un objet const requiert un initialiseur -- la classe %t n'a pas de constructeur par défaut fourni par l'utilisateur",
  "l'option 'implicit_extern_c_type_conversion' peut uniquement être utilisée lors de la compilation de C++",
  "mode strict incompatible avec les règles de conservation long",
  "un qualificateur de type sur le type de retour n'a pas de sens",
  "qualificateur de type sur type de retour 'void' non autorisé dans une définition de fonction",
  "déclaration d'un membre de données statique non autorisée dans cette classe",
  "l'instanciation de modèle a entraîné une déclaration de fonction non valide",
  "'...' non autorisé",
  "l'option 'extern_inline' peut uniquement être utilisée lors de la compilation de C++",
  "%n inline externe référencé mais non défini",
  "nom de destructeur non valide pour le type %t",
  null,
  "référence de destructeur ambiguë -- %n1 et %n2 peuvent être utilisés",
  "%n inline virtuel jamais défini",
  "%n jamais référencé",
  "seul un membre de l'union peut être spécifié dans une liste d'initialiseurs de constructeur",
  "prise en charge de 'new[]' et 'delete[]' désactivée",
  "'double' utilisé pour 'long double' dans le code C généré",
  "%n n'a pas d'opérateur delete%s correspondant (appelé en cas de levée d'exception durant l'initialisation d'un objet alloué)",
  "prise en charge de l'opérateur de positionnement delete désactivée",
  "aucun opérateur delete approprié visible",
  "pointeur vers ou référence à un type incomplet non autorisé",
  "spécialisation partielle non valide -- %n est déjà entièrement spécialisé",
  "spécifications d'exceptions incompatibles",
  "retourne la référence à une variable locale",
  "omission de type explicite non standard ('int' pris par défaut)",
  "plusieurs spécialisations partielles correspondent à la liste d'arguments template de %n",
  "%nod",
  "liste d'arguments template non autorisée dans une déclaration de modèle principal",
  "les spécialisations partielles ne peuvent pas avoir d'arguments template par défaut",
  "%n1 n'est pas utilisé dans la liste d'arguments template de %n2, ou ne peut pas en être déduit",
  null,
  "la liste d'arguments template d'une spécialisation partielle inclut un argument sans type dont le type dépend d'un paramètre de modèle",
  "cette spécialisation partielle serait utilisée pour instancier %n",
  "cette spécialisation partielle rendrait ambiguë l'instanciation de %n",
  "l'expression doit avoir le type intégral ou enum",
  "l'expression doit avoir le type arithmétique ou enum",
  "l'expression doit avoir le type arithmétique, enum ou pointeur",
  "le cast doit avoir le type intégral ou enum",
  "le cast doit avoir le type arithmétique, enum ou pointeur",
  "l'expression doit être un pointeur vers un type d'objet complet",
  null,
  "un argument sans type de spécialisation partielle doit être le nom d'un paramètre sans type ou d'une constante",
  "le type de retour n'est pas identique au type de retour %t de la fonction virtuelle substituée %no",
  "l'option 'guiding_decls' peut uniquement être utilisée lors de la compilation de C++",
  "une spécialisation partielle de modèle de classe doit être déclarée dans l'espace de noms dont il est membre",
  "%n est une fonction virtuelle pure",
  "%n virtuel pure n'a pas de remplaçant",
  "attributs __declspec ignorés",
  "caractère non valide dans la ligne d'entrée",
  "la fonction retourne un type incomplet %t",
  "l'effet de cette directive '#pragma pack' est local à %n",
  "%s n'est pas un modèle",
  "une déclaration Friend ne peut pas déclarer une spécialisation partielle",
  "spécification d'exception ignorée",
  "la déclaration de 'size_t' ne correspond pas au type attendu %t",
  "espace requis entre les délimiteurs '>' adjacents de listes d'arguments de modèle imbriquées ('>>' est l'opérateur Right Shift)",
  "impossible de définir les paramètres régionaux %sq permettant le traitement de caractères multioctets",
  "séquence de caractères multioctets non valide",
  "l'instanciation du modèle a généré un type de fonction inattendu de %t1 (la signification d'un nom a peut-être changé depuis la déclaration de modèle -- le modèle est de type %t2)",
  "déclaration de guidage ambiguë -- plusieurs modèles de fonction %no correspondent au type %t",
  "opération non intégrale non autorisée dans un argument template sans type",
  "l'option 'embedded_c++' peut uniquement être utilisée lors de la compilation de C++",
  "Embedded C++ ne prend pas en charge les modèles",
  "Embedded C++ ne prend pas en charge la gestion des exceptions",
  "Embedded C++ ne prend pas en charge les espaces de noms",
  "Embedded C++ ne prend pas en charge les informations de type au moment de l'exécution",
  "Embedded C++ ne prend pas en charge la nouvelle syntaxe de cast",
  "Embedded C++ ne prend pas en charge les déclarations using",
  "Embedded C++ ne prend pas en charge 'mutable'",
  "Embedded C++ ne prend pas en charge l'héritage multiple ou virtuel",
  "numéro de version Microsoft non valide : %s",
  "représentation du pointeur vers membre %sq déjà définie pour %n",
  "impossible d'utiliser %t1 pour désigner le constructeur de %t2",
  "suffixe de constante intégrale non valide",
  "l'opérande of __uuidof doit avoir un type classe ou enum pour lequel __declspec(uuid('...')) a été spécifié",
  "chaîne GUID non valide dans __declspec(uuid('...'))",
  "l'option 'vla' peut uniquement être utilisée lors de la compilation de C++",
  "tableau de longueur variable avec limites d'index non spécifiées non autorisé",
  "liste d'arguments template explicite non autorisée sur cette déclaration",
  "une entité avec une liaison ne peut pas avoir un type impliquant un tableau de longueur variable",
  "un tableau de longueur variable ne peut pas avoir une durée de stockage statique",
  "%n n'est pas un modèle",
  "dimension de tableau de longueur variable (%p déclaré)",
  "argument template attendu",
  null,
  "un opérateur non membre requiert un paramètre avec un type classe ou enum",
  "l'option 'enum_overloading' peut uniquement être utilisée lors de la compilation de C++",
  null,
  "le qualificateur du nom de destructeur %t1 ne correspond pas au type %t2",
  "qualificateur de type ignoré",
  "l'option 'nonstd_qualifier_deduction' peut uniquement être utilisée lors de la compilation de C++",
  "impossible de définir une fonction déclarée 'dllimport'",
  "spécification de propriété incorrecte ; le format correct est __declspec(property(get=nom1,put=nom2))",
  "propriété déjà définie",
  "__declspec(property) non autorisé sur cette déclaration",
  "membre déclaré avec __declspec(property), mais aucune fonction 'get' spécifiée",
  "fonction __declspec(property) 'get' %sq manquante",
  "membre déclaré avec __declspec(property), mais aucune fonction 'put' spécifiée",
  "fonction __declspec(property) 'put' %sq manquante",
  "référence de membre de classe ambiguë -- %nd1 utilisé en référence à %nd2",
  null,
  null,
  null,
  "impossible de convertir un pointeur vers un membre de la classe dérivée %t1 en pointeur vers un membre de la classe de base %t2 -- la classe de base est virtuelle",
  "répertoire non valide pour les fichiers d'instanciation : %s",
  "l'option 'one_instantiation_per_object' peut uniquement être utilisée lors de la compilation de C++",
  null,
  null,
  "impossible de spécifier un nom de fichier d'informations d'instanciation lors de la compilation de plusieurs fichiers d'entrée",
  "impossible d'utiliser l'option 'one_instantiation_per_object' lors de la compilation de plusieurs fichiers d'entrée",
  "plusieurs options de ligne de commande correspondent à l'abréviation '--%s' :",
  "--%s",
  "les qualificateurs de type sur les types de fonction sont ignorés",
  null,
  "l'option late/early tiebreaker peut uniquement être utilisée lors de la compilation de C++",
  "utilisation incorrecte de va_start",
  "utilisation incorrecte de va_arg",
  "utilisation incorrecte de va_end",
  "l'option d'instanciations en attente peut uniquement être utilisée lors de la compilation de C++",
  "répertoire non valide pour les fichiers #import : %s",
  "un répertoire d'importation ne peut être spécifié qu'en mode Microsoft",
  "membre avec type référence non autorisé dans une union",
  "impossible de spécifier 'typedef' ici",
  "la redéclaration de %n modifie son accès",
  "un nom qualifié par une classe ou un espace de noms est requis",
  "type de retour 'int' omis dans la déclaration de la fonction 'main'",
  "la représentation du pointeur vers membre %sq est trop restrictive pour %n",
  "instruction return manquante à la fin d'un %n non void",
  "déclaration using dupliquée de %no ignorée",
  "les champs de bits enum sont toujours non signés, mais l'enum %t inclut un énumérateur négatif",
  "l'option 'class_name_injection' peut uniquement être utilisée lors de la compilation de C++",
  "l'option 'arg_dep_lookup' peut uniquement être utilisée lors de la compilation de C++",
  "l'option 'friend_injection' peut uniquement être utilisée lors de la compilation de C++",
  "le nom suivant 'template' doit être un modèle",
  null,
  "déclaration Friend de classe locale non standard -- aucune déclaration préalable dans la portée englobante",
  "spécification d'un argument par défaut sur cette déclaration non standard",
  "l'option 'nonstd_using_decl' peut uniquement être utilisée lors de la compilation de C++",
  "le type de retour de la fonction 'main' doit être 'int'",
  "un paramètre de modèle sans type ne peut pas avoir le type classe",
  "impossible de spécifier un argument template par défaut sur la déclaration d'un membre de modèle de classe en dehors de sa classe",
  "instruction return non autorisée dans le gestionnaire d'un bloc try de fonction d'un constructeur",
  "impossible de combiner des désignateurs ordinaires et étendus dans la désignation d'un initialiseur",
  "le second indice doit être inférieur au premier",
  null,
  "l'option 'extended_designators' peut uniquement être utilisée lors de la compilation de C++",
  "la taille déclarée du champ de bits est supérieure à celle du type champ de bits ; tronqué à %s bits",
  "le type utilisé comme nom de constructeur ne correspond pas au type %t",
  "utilisation d'un type sans liaison pour déclarer une variable avec liaison",
  "utilisation d'un type sans liaison pour déclarer une fonction",
  "impossible de spécifier un type de retour sur un constructeur",
  "impossible de spécifier un type de retour sur un destructeur",
  "nom de caractère universel incorrect",
  "le nom de caractère universel spécifie un caractère non valide",
  "un nom de caractère universel ne peut pas désigner un caractère dans un jeu de caractères de base",
  "caractère universel non autorisé dans un identificateur",
  "l'identificateur __VA_ARGS__ peut uniquement apparaître dans les listes de remplacement de macros variadiques",
  "qualificateur sur cette déclaration Friend ignoré",
  "impossible d'appliquer des désignateurs de plage de tableau à des initialiseurs dynamiques",
  "le nom de propriété ne peut pas apparaître ici",
  "'inline' utilisé comme qualificateur de fonction est ignoré",
  "l'option 'compound_literals' peut uniquement être utilisée lors de la compilation de C++",
  "type tableau de longueur variable non autorisé",
  "littéral composé non autorisé dans une expression constante intégrale",
  "littéral composé de type %t non autorisé",
  "déclaration Friend de modèle impossible dans une classe locale",
  "opération '?' ambiguë : le second opérande de type %t1 peut être converti au type %t2 du troisième opérande, et vice versa",
  "appel d'un objet d'un type de classe sans operator() approprié ou fonctions de conversions en type pointeur vers fonction",
  "fonction de substitution de la conversion %np",
  "un objet de type %t peut être appelé de plusieurs façons pour la liste d'arguments :",
  "le nom de typedef a déjà été déclaré (avec un type similaire)",
  "l'opérateur new et l'opérateur delete ne peuvent pas avoir de liaison interne",
  "classe de stockage 'mutable' non autorisée pour les unions anonymes",
  "fichier d'en-tête précompilé non valide",
  "type de classe abstraite %t non autorisé en tant que type catch :",
  "impossible d'utiliser un type de fonction qualifié pour déclarer une fonction non membre ou une fonction membre statique",
  "impossible d'utiliser un type de fonction qualifié pour déclarer un paramètre",
  "impossible de créer un pointeur vers ou une référence à un type de fonction qualifié",
  "accolades supplémentaires non standard",
  "définition de macro non valide : %s",
  "retrait de types pointeur %t1 et %t2 non standard",
  "liste de paramètres de modèle vide non autorisée dans une déclaration de paramètre template de modèle",
  "'class' attendu",
  "le mot clé 'struct' ne peut pas être utilisé dans la déclaration d'un paramètre template de modèle",
  "%np2 est masqué par %no1 -- la substitution de la fonction virtuelle est-elle intentionnelle ?",
  "un nom qualifié n'est pas autorisé pour une déclaration Friend qui est une définition de fonction",
  "%n1 incompatible avec %n2",
  "impossible de spécifier une classe de stockage ici",
  "un membre de classe désigné par une déclaration using doit être visible dans une classe de base directe",
  null,
  "le mode Sun est incompatible avec le mode cfront",
  "le mode strict est incompatible avec le mode Sun",
  "le mode Sun est uniquement autorisé lors de la compilation de C++",
  "un paramètre template de modèle ne peut pas avoir le même nom qu'un de ses paramètres de modèle",
  "instanciation récursive d'argument par défaut",
  null,
  "%n n'est pas une entité pouvant être définie",
  "le nom de destructeur doit être qualifié",
  "impossible d'introduire un nom de classe Friend à l'aide de 'typename'",
  "une déclaration using ne peut pas nommer un constructeur ou un destructeur",
  "une déclaration de modèle Friend qualifiée doit faire référence à un modèle spécifique déclaré au préalable",
  "spécificateur non valide dans une déclaration de modèle de classe",
  "argument incompatible avec le paramètre formel",
  "l'option 'dep_name' peut uniquement être utilisée lors de la compilation de C++",
  "boucle dans la séquence de fonctions 'operator->' commençant à la classe %t1",
  "%n n'a pas de classe membre %sq",
  "la portée globale n'a pas de classe nommée %sq",
  "instanciation récursive d'argument template par défaut",
  "les déclarations d'accès et les déclarations using ne peuvent pas apparaître dans des unions",
  "%no n'est pas un membre de classe",
  "déclaration de constante membre non standard non autorisée",
  "l'option 'ignore_std' peut uniquement être utilisée lors de la compilation de C++",
  "l'option 'parse_templates' peut uniquement être utilisée lors de la compilation de C++",
  "impossible d'utiliser l'option 'dep_name' avec 'no_parse_templates'",
  "modes de langage spécifiés incompatibles",
  "redéclaration de classe imbriquée non valide",
  "un type contenant un tableau de taille inconnue n'est pas autorisé",
  "impossible de définir une variable à durée de stockage statique dans une fonction inline",
  "impossible de référencer une entité avec une liaison interne dans une fonction inline avec une liaison externe",
  "le type d'argument %t ne correspond pas à cette macro de fonction de type générique",
  "tableau de longueur variable %nod",
  "la déclaration Friend ne peut pas ajouter d'arguments par défaut à la déclaration précédente",
  "impossible de déclarer %n dans cette portée",
  "l'identificateur réservé %sq ne peut être utilisé que dans une fonction",
  "ce caractère universel ne peut pas commencer un identificateur",
  "littéral de chaîne attendu",
  "pragma STDC non reconnu",
  "'ON', 'OFF' ou 'DEFAULT' attendu",
  "un pragma STDC peut uniquement apparaître entre les déclarations dans la portée globale, ou avant les instructions ou les déclarations dans une portée de bloc",
  "utilisation incorrecte de va_copy",
  "%s ne peut être utilisé qu'avec les types virgule flottante",
  "type complexe non autorisé",
  "genre de désignateur non valide",
  "impossible de représenter exactement la valeur à virgule flottante",
  "le résultat de l'opération en virgule flottante complexe est hors limites",
  "une conversion entre real et imaginary donne zéro",
  "impossible de spécifier un initialiseur pour un membre de tableau flexible",
  "imaginary *= imaginary donne la valeur zéro à l'opérande de partie gauche",
  "standard requiert qu'une déclaration ultérieure affecte un type à %n ('int' pris par défaut)",
  "définition requise pour %n inline",
  "conversion d'entier en pointeur plus petit",
  "un type virgule flottante doit être inclus dans le spécificateur de type pour un type _Complex ou _Imaginary",
  "impossible de déclarer les types dans des unions anonymes",
  "retourne un pointeur vers une variable locale",
  "retourne un pointeur vers la mémoire locale",
  "l'option 'export' peut uniquement être utilisée lors de la compilation de C++",
  "impossible d'utiliser l'option 'export' avec 'no_dep_name'",
  "impossible d'utiliser l'option 'export' avec 'implicit_include'",
  "déclaration de %n incompatible avec une déclaration d'une autre unité de traduction",
  "l'autre déclaration est %p",
  "détecté lors de la compilation de l'unité de traduction secondaire %sq",
  "compilation de l'unité de traduction secondaire %sq",
  "une déclaration de champ ne peut pas avoir un type impliquant un tableau de longueur variable",
  "la déclaration de %n avait une autre signification lors de la compilation de %sq",
  "'template' attendu",
  "impossible d'utiliser 'export' sur une instanciation explicite",
  "impossible d'utiliser 'export' sur cette déclaration",
  "impossible de déclarer 'export' un membre d'un espace de noms sans nom",
  "impossible de déclarer un modèle 'export' après sa définition",
  "une déclaration ne peut pas avoir d'étiquette",
  "prise en charge de modèles exportés désactivée",
  null,
  "%n déjà défini lors de la compilation de %sq",
  "%n déjà défini dans une autre unité de traduction",
  "impossible d'utiliser une variable locale non statique dans une spécification __based",
  "impossible de spécifier l'option pour répertorier les dépendances d'un makefile lors de la compilation de plusieurs unités de traduction",
  null,
  "impossible de spécifier l'option pour générer une sortie prétraitée lors de la compilation de plusieurs unités de traduction",
  "impossible de déclarer un champ du même nom que sa classe dans une classe ayant un constructeur déclaré par l'utilisateur",
  "impossible d'utiliser 'implicit_include' lors de la compilation de plusieurs unités de traduction",
  "fichier de modèle exporté %sq endommagé",
  "impossible d'instancier %n -- il a été explicitement spécialisé dans l'unité de traduction contenant la définition exportée",
  "le type d'objet est : %s",
  "l'objet a des qualificateurs de type incompatibles avec le membre %n",
  "aucune instance de %n ne correspond à la liste d'arguments et à l'objet (les qualificateurs de type de l'objet empêchent une correspondance)",
  "un attribut spécifie un mode incompatible avec %t",
  "aucun type avec la largeur spécifiée",
  "valeur d'alignement non valide spécifiée par l'attribut",
  "attribut non valide pour %t",
  null,
  null,
  "l'attribut %sq n'accepte pas d'arguments",
  null,
  "nom d'attribut attendu",
  "attribut inconnu %sq",
  "aucun attribut ne peut apparaître ici",
  "argument non valide pour l'attribut %sq",
  null,
  "dans 'goto *expr', expr doit avoir le type 'void *'",
  "'goto *expr' non standard",
  "la prise d'adresse d'une étiquette est non standard",
  "nom de fichier spécifié plusieurs fois : %s",
  "directive #avertissement : %s",
  null,
  "l'attribut 'transparent_union' s'applique uniquement aux unions ; %t n'est pas une union",
  "l'attribut 'transparent_union' est ignoré sur les types incomplets",
  "%t ne peut pas être transparent car %n n'a pas la même taille que le premier champ",
  "%t1 ne peut pas être transparent, car il a un champ de type %t2 qui n'est pas de la même taille que le premier champ",
  null,
  "l'attribut %sq ne s'applique pas aux variables locales",
  "attributs non autorisés sur une définition de fonction",
  null,
  "la seconde constante d'une plage de case doit être supérieure à la première",
  "nom asm non autorisé dans une définition de fonction",
  "nom asm ignoré dans un typedef",
  "nom de registre inconnu '%s'",
  null,
  "modificateur de contrainte asm inconnu '%s'",
  "lettre de contrainte asm inconnue '%s'",
  "l'opérateur asm n'a pas de lettre de contrainte",
  "un opérande de sortie asm doit avoir un modificateur '=' ou '+'",
  "un opérande d'entrée asm ne peut pas avoir de modificateur '=' ou '+'",
  null,
  null,
  "registre '%s' utilisé plusieurs fois",
  "le registre '%s' est à la fois utilisé et écrasé",
  "registre '%s' écrasé plusieurs fois",
  "le registre '%s' a un objectif fixe et ne peut pas être utilisé dans une instruction asm",
  "le registre '%s' a un objectif fixe et ne peut pas être écrasé dans une instruction asm",
  "une liste d'éléments écrasés vide doit être omise entièrement",
  "opérande asm attendu",
  "registre à écraser attendu",
  "l'attribut 'format' requiert un paramètre ellipse",
  "le premier argument de substitution n'est pas le premier argument de variable",
  "l'index d'arguments de format est supérieur au nombre d'arguments",
  "l'argument de format n'est pas de type chaîne",
  "le mot clé 'template' utilisé pour la levée de l'ambiguïté syntaxique peut uniquement être utilisée dans un modèle",
  "une option de débogage doit être spécifiée dans la ligne de commande du pragma db_opt à utiliser",
  null,
  "l'attribut %sq ne s'applique pas au type sans fonction %t",
  "arithmétique sur pointeur vers type void ou fonction",
  "la classe de stockage doit être auto ou register",
  "%t1 aurait été promu %t2 lors du passage par le paramètre ellipse ; utilisez le second type à la place",
  "%sq n'est pas un membre de classe de base",
  "__super ne peut pas apparaître après '::'",
  "__super peut uniquement être utilisé dans une portée de classe",
  "__super doit être suivi de '::'",
  "[ contextes d'instanciation %d non affichés ]",
  "nom altéré trop long",
  "déclaration dont l'alias est l'entité non définie %sq",
  "la déclaration ne correspond pas à son alias %n",
  "l'entité déclarée en tant qu'alias ne peut pas avoir de définition",
  "type de champ de tableau de longueur variable considéré comme type de champ de tableau de longueur zéro",
  "cast non standard sur lvalue ignoré",
  "nom d'indicateur non reconnu : %s",
  "le type de retour void ne peut pas être qualifié",
  "spécificateur auto ignoré ici (non valide dans C/C++ standard)",
  "réduction d'alignement sans attribut 'packed' ignorée",
  "un modèle membre correspondant à %no est déclaré en tant que modèle de genre différent dans une autre unité de traduction",
  "initialiseurs en trop ignorés",
  "va_start peut uniquement apparaître dans une fonction ayant un paramètre ellipse",
  "l'option 'short_enums' est uniquement valide dans les modes C GNU et C++ GNU",
  "fichier d'informations d'importation non valide %sq1 à la ligne %s2",
  "expressions d'instruction uniquement autorisées dans une portée de bloc",
  "à partir de l'unité de traduction ",
  "nom asm ignoré sur une variable automatique non-register",
  null,
  "pragma UPC non reconnu",
  "la taille du bloc partagé ne correspond pas à celle précédemment spécifiée",
  "l'expression entre crochets est supposée être la spécification de taille d'un bloc plutôt que la dimension d'un tableau",
  "la taille de bloc d'un tableau partagé doit être supérieure à zéro",
  "plusieurs tailles de bloc ne sont pas autorisées",
  "le mode strict ou souple requiert la mémoire partagée",
  "THREADS non autorisé dans ce contexte",
  "la taille de bloc spécifiée dépasse la valeur maximale autorisée %s",
  "fonction retournant un type partagé non autorisée",
  null,
  "une dimension d'un tableau de type partagé doit être un multiple de THREADS lorsque le nombre de threads est non constant",
  "type partagé non autorisé dans un struct ou une union",
  "les paramètres ne peuvent pas avoir de types partagés",
  "une dimension THREADS dynamique requiert une taille de bloc définie",
  "les variables partagées doivent être statiques ou externes",
  "l'argument de upc_blocksizeof est un pointeur vers un type partagé (pas un type partagé lui-même)",
  "expression d'affinité ignorée dans upc_forall imbriqué",
  "la création d'une branche dans ou en dehors d'une boucle upc_forall loop n'est pas autorisée",
  "l'expression d'affinité doit avoir un type partagé ou pointer vers un type partagé",
  "l'affinité a un type partagé (et non pas un pointeur vers un type partagé)",
  "les types void* partagés peuvent uniquement être utilisés pour comparaison d'égalité",
  "mode UPC incompatible avec les modes C++ et K&R",
  "caractère null (zéro) ignoré dans ligne d'entrée",
  "caractère null (zéro) dans chaîne ou constante caractère",
  "caractère null (zéro) dans nom d'en-tête",
  "déclaration dans for-initializer masque une déclaration dans la portée environnante",
  "la déclaration masquée est %p",
  "la déclaration de prototype %nfd est ignorée après cette redéclaration non prototypée",
  null,
  "%npd doit avoir une liaison C externe",
  "la déclaration de variable masque la déclaration dans for-initializer",
  "impossible d'utiliser le typedef %sq dans un spécificateur de type élaboré",
  "appel de constante nulle ignorée",
  "impossible de redéclarer le paramètre %sq dans une clause Catch de bloc try de fonction",
  "la spécialisation explicite initiale de %n doit être déclarée dans l'espace de noms contenant le modèle",
  "élément écrasé 'cc' ignoré",
  "'template' doit être suivi d'un identificateur",
  "MYTHREAD non autorisé dans ce contexte",
  "le qualificateur de disposition ne peut pas qualifier un pointeur en pointeur partagé",
  "le qualificateur de disposition ne peut pas qualifier un tableau incomplet",
  "la déclaration de %sq masque le paramètre de gestionnaire",
  "cast en type de tableau non standard ignoré",
  "impossible d'utiliser ce pragma dans un opérateur _Pragma (une directive #pragma doit être utilisée)",
  "le champ utilise le remplissage de fin d'une classe de base",
  "les compilateurs C++ GNU peuvent utiliser le remplissage de champ de bits",
  "%nd a été déclaré déconseillé",
  "nom asm non autorisé sur une déclaration membre non statique",
  "type de fonction de format non reconnu %sq ignoré",
  "la classe de base %no1 utilise le remplissage de fin de la classe de base %no2",
  "l'attribut 'init_priority' ne peut être utilisé que pour les définitions de membres de données statiques et les variables de portée espace de noms de types classe",
  "la priorité demandée pour l'initialisation est réservée pour usage interne",
  "ce champ union/struct anonyme est masqué par %nd",
  "numéro d'erreur non valide",
  "indicateur d'erreur non valide",
  "numéro ou indicateur d'erreur attendu",
  "la taille de la classe est affectée par le remplissage de fin",
  "les étiquettes peuvent uniquement être référencées dans des définitions de fonction",
  "transfert de contrôle non autorisé dans une expression d'instruction",
  null,
  "cette instruction n'est pas autorisée dans une expression d'instruction",
  "une classe qui n'est pas copiable de manière triviale ne peut pas être définie dans une expression d'instruction",
  null,
  "variable statique locale initialisée dynamiquement non autorisée dans une expression d'instruction",
  "tableau de longueur variable non autorisé dans une expression d'instruction",
  "expression d'instruction non autorisée dans un argument par défaut",
  "conversion non standard entre un pointeur de fonction et un pointeur de données",
  "les types interface ne peuvent pas avoir de classes de base virtuelles",
  "les types interface ne peuvent pas spécifier 'private' ou 'protected'",
  "les types interface ne peuvent dériver que d'autres types interface",
  "%t n'est pas un type interface",
  "les types interface ne peuvent pas avoir de membres typedef",
  "les types interface ne peuvent pas avoir de constructeurs ou destructeurs déclarés par l'utilisateur",
  "les types interface ne peuvent pas avoir d'opérateurs membres déclarés par l'utilisateur",
  "impossible de déclarer les types interface dans des fonctions",
  null,
  "les types interface ne peuvent pas avoir de membres de données",
  "les types interface ne peuvent pas contenir de déclarations friend",
  null,
  "les types interface ne peuvent pas avoir de types classe imbriqués",
  "les types interface ne peuvent pas avoir de modèles de membres",
  "les types interface ne peuvent pas avoir de fonctions membres statiques",
  "impossible d'utiliser ce pragma dans un opérateur __pragma (une directive #pragma doit être utilisée)",
  "le qualificateur doit être une classe de base de %t",
  "la déclaration doit correspondre à une fonction membre virtuelle pure dans la classe de base indiquée",
  "dépassement sur les entiers dans le calcul interne en raison de la taille ou de la complexité de %t",
  "dépassement sur les entiers dans le calcul interne",
  "__w64 peut uniquement être spécifié sur les types int, long et pointeur",
  "conversion potentiellement restrictive lors de la compilation dans un environnement où les types int, long ou pointeur sont de 64 bits",
  "la valeur actuelle de pragma pack est %s",
  "arguments de pragma pack(show) ignorés",
  null,
  null,
  "__declspec(align(...)) antérieur ignoré",
  "valeur d'argument pour le paramètre d'attribut %sq attendue",
  "valeur d'argument non valide pour le paramètre d'attribut %sq",
  "valeur booléenne pour le paramètre d'attribut %sq attendue",
  "un argument positionnel ne peut pas suivre un argument nommé dans un attribut",
  "l'attribut %sq1 n'a pas de paramètre nommé %sq2",
  "liste d'arguments pour l'attribut %sq attendue",
  "',' ou ']' attendu",
  "une valeur a déjà été assignée à l'argument d'attribut %sq",
  "impossible d'assigner une valeur à l'attribut %sq",
  "une expression Throw ne peut pas avoir de pointeur vers un type incomplet",
  "opérateur alignment-of appliqué à un type incomplet",
  "%sq peut uniquement être utilisé en tant qu'attribut autonome",
  "impossible d'utiliser l'attribut %sq ici",
  null,
  "attributs non autorisés ici",
  "valeur d'argument non valide pour le paramètre d'attribut %sq",
  "trop d'arguments d'attribut",
  "conversion à partir de la classe de base inaccessible %t non autorisée",
  "l'option 'export' requiert des signatures de modèle distinctes",
  "impossible de concaténer des littéraux de chaîne avec des genres de caractères différents",
  "bogue de disposition GNU non émulée car elle place la base virtuelle %no1 en dehors des limites de l'objet %no2",
  "base virtuelle %no1 placée en dehors des limites de l'objet %no2",
  "nom qualifié non standard dans la déclaration de membre d'espace de noms",
  "réduction d'alignement ignorée",
  "qualificateur const ignoré",
  null,
  "qualificateurs asm GNU non valides",
  "un type de classe qui ne peut pas être copié de manière évidente a été passé via des points de suspension",
  "un type de classe qui ne peut pas être copié de manière évidente ne peut pas être récupéré (fetch) par va_arg",
  "le suffixe 'u' ou 'U' doit apparaître avant le suffixe 'l' ou 'L' dans un littéral à virgule fixe",
  "l'option 'fixed_point' peut uniquement être utilisée lors de la compilation de C++",
  "un opérande entier peut entraîner un dépassement de capacité à virgule fixe",
  "constante à virgule fixe hors limites",
  "impossible de représenter exactement la valeur à virgule fixe",
  "constante trop grande pour long long ; type long long non signé utilisé (non standard)",
  "le qualificateur de disposition ne peut pas qualifier un pointeur en pointeur void partagé",
  "THREADS dupliqué dans type de tableau multidimensionnel",
  "une directive using forte peut uniquement apparaître dans une portée espace de noms",
  "%nf déclare une fonction sans modèle -- ajoutez <> pour référencer une instance de modèle",
  "l'opération peut entraîner un dépassement de capacité à virgule fixe",
  "l'expression doit avoir le type intégral, enum, ou à virgule fixe",
  "l'expression doit avoir le type intégral ou à virgule fixe",
  "une fonction déclarée avec 'noreturn' retourne une valeur",
  "nom asm ignoré car il est en conflit avec une déclaration précédente",
  "impossible de redéclarer le typedef d'un membre de classe",
  "prise d'adresse d'une variable temporaire",
  "attributs ignorés sur une déclaration classe qui n'est pas également une définition",
  "valeur à virgule fixe implicitement convertie en type virgule flottante",
  "les types virgule fixe n'ont pas de classification",
  "un paramètre de modèle ne peut pas avoir le type virgule fixe",
  "constantes à virgule flottante hexadécimales non autorisées",
  "l'option 'named_address_spaces' peut uniquement être utilisée lors de la compilation de C++",
  "la valeur à virgule flottante ne peut pas être contenue dans le type virgule fixe",
  "la valeur ne peut pas être convertie exactement en valeur à virgule fixe",
  "la conversion en virgule fixe a entraîné un changement de signe",
  "la valeur entière ne peut pas être contenue dans le type virgule fixe requis",
  "le résultat de l'opération en virgule fixe est hors limites",
  "plusieurs espaces d'adressage nommés",
  "impossible de stocker une variable à durée de stockage automatique dans un espace d'adressage nommé",
  "impossible de qualifier un type avec un espace d'adressage nommé",
  "impossible de qualifier un type de fonction avec un espace d'adressage nommé",
  "impossible de qualifier un type de champ avec un espace d'adressage nommé",
  "la valeur à virgule fixe ne peut pas être contenue dans le type virgule flottante requis",
  "la valeur à virgule fixe ne peut pas être contenue dans le type entier requis",
  "la valeur ne peut pas être contenue dans le type virgule fixe requis",
  "l'option 'named_registers' peut uniquement être utilisée lors de la compilation de C++",
  "une classe de stockage nommée dans le registre n'est pas autorisée ici",
  "%nd redéclaré avec une classe de stockage nommée dans le registre incompatible",
  "impossible de spécifier une classe de stockage nommée dans le registre pour une variable ayant un alias",
  "spécificateur de stockage nommé dans le registre déjà utilisé",
  "impossible de combiner l'option 'embedded_c' avec les options de contrôle de fonctionnalités Embedded C individuelles",
  "répertoire EDG_BASE non valide : %s",
  null,
  "entrée de macro prédéfinie non valide à la ligne %s : %s2",
  "nom de mode macro non valide %sq",
  "redéfinition de macro prédéfinie %sq incompatible",
  "classe de stockage nommée dans le registre manquante dans la redéclaration de %nd",
  "registre nommé trop petit pour le type de variable",
  "impossible de déclarer les tableaux avec une classe de stockage nommée dans le registre",
  "const_cast en type enum non standard",
  "l'option 'embedded_c' peut uniquement être utilisée lors de la compilation de C++",
  "qualificateur d'espace d'adressage nommé non autorisé ici",
  "initialiseur vide non valide pour un tableau dont les limites d'index ne sont pas spécifiées",
  "la fonction retourne un type classe incomplète %t",
  "%n déjà initialisé ; initialiseur hors classe ignoré",
  "la déclaration masque %nd",
  "impossible d'allouer un paramètre dans un espace d'adressage nommé",
  "suffixe non valide sur constante à virgule fixe ou à virgule flottante",
  "impossible d'allouer une variable de registre dans un espace d'adressage nommé",
  "'SAT' ou 'DEFAULT' attendu",
  "%n n'a pas d'opérateur membre delete%s correspondant (appelé en cas de levée d'exception lors de l'initialisation d'un objet alloué)",
  "impossible de déclarer une variable de thread local avec 'dllimport' ou 'dllexport'",
  "impossible de qualifier le type de retour d'une fonction avec un espace d'adressage nommé",
  "impossible de spécifier un initialiseur pour un membre de tableau flexible dont les éléments ont un destructeur non trivial",
  "impossible de spécifier un initialiseur pour un membre de tableau flexible indirect",
  "numéro de version GNU non valide : %s",
  "plusieurs variables apparaissant après un initialiseur entre parenthèses sont ignorées",
  "impossible d'utiliser le résultat de ce cast comme une lvalue",
  "négation d'une valeur à virgule fixe non signée",
  null,
  null,
  "les noms de registre peuvent uniquement être utilisés pour les variables de registre",
  "les variables de registre nommées ne peuvent pas avoir le type void",
  null,
  "les paramètres ne peuvent pas avoir de spécificateurs au niveau de la portée liaison",
  "plusieurs spécificateurs au niveau de la portée liaison",
  "les spécificateurs au niveau de la portée liaison peuvent uniquement apparaître sur des fonctions ou des variables ayant une liaison externe",
  "une redéclaration ne peut pas affaiblir une portée liaison",
  "spécificateur au niveau de la portée liaison non autorisé sur cette déclaration",
  "nom qualifié non standard dans la déclaration au niveau de la portée globale",
  "conversion implicite d'un type intégral à 64 bits en type intégral plus petit (problème de portabilité potentiel)",
  "conversion explicite d'un type intégral à 64 bits en type intégral plus petit (problème de portabilité potentiel)",
  "conversion de pointeur en type intégral de même taille (problème de portabilité potentiel)",
  null,
  "spécificateur Friend non autorisé dans une définition de classe ; spécificateur Friend ignoré",
  "seules les variables statiques et externes peuvent utiliser le stockage local des threads",
  "plusieurs spécificateurs de stockage local des threads",
  "%n virtuel non défini (et ne peut pas être défini ailleurs car il est membre d'un espace de noms sans nom)",
  "caractère de retour chariot dans la ligne source, à l'extérieur du commentaire ou du littéral de caractère/chaîne",
  "l'expression doit avoir le type virgule fixe",
  "l'utilisation non valide d'un spécificateur d'accès est ignorée",
  "pointeur converti en booléen",
  "pointeur vers membre converti en booléen",
  "spécificateur de stockage ignoré",
  "dllexport et dllimport ignorés sur les modèles de classe",
  "la spécification dllexport/dllimport de la classe de base est différente de celle de la classe dérivée",
  "la redéclaration ne peut pas ajouter dllexport/dllimport à %nod",
  "dllexport/dllimport en conflit avec %nod; dllexport pris par défaut",
  "impossible de définir l'entité dllimport",
  "dllexport/dllimport requiert une liaison externe",
  "un membre d'une classe déclarée avec dllexport/dllimport ne peut pas être lui-même déclaré avec ce spécificateur",
  "un champ de type de classe sans interface DLL a été utilisé dans une classe à interface DLL",
  "déclaration de membre entre parenthèses non standard",
  "espace blanc ignoré entre la barre oblique inverse et le saut de ligne dans la jointure de ligne",
  "dllexport/dllimport en conflit avec %nod; dllimport/dllexport supprimé",
  "membre non valide pour une classe membre anonyme -- la classe %t a une fonction membre interdite",
  "reinterpret_cast non standard",
  "le spécificateur de format de position ne peut pas être nul",
  "une classe locale ne peut pas faire référence à un type de tableau de longueur variable à partir d'une fonction englobante",
  "le membre %nd a déjà un spécificateur dllexport/dllimport explicite",
  "tableau de longueur variable non autorisé dans un type de retour de fonction",
  "type tableau de longueur variable non autorisé dans un pointeur vers membre de type %t",
  "le résultat d'une expression d'instruction ne peut pas avoir un type impliquant un tableau de longueur variable",
  "prise en charge des trigraphes désactivée",
  "l'attribut %sq peut uniquement apparaître sur les fonctions et les variables ayant une liaison externe",
  "le mode strict est incompatible avec le traitement de namespace std en tant qu'alias pour l'espace de noms global",
  "dans l'expansion macro '%s' %p",
  "<Inconnu>",
  "",
  "[ %d expansions macro non affichées ]",
  "dans l'expansion macro à %p",
  "nom d'opérande symbolique non valide %sq",
  "une contrainte de correspondance symbolique doit faire référence à un des dix premiers opérandes",
  "l'utilisation de __if_exists n'est pas prise en charge dans ce contexte",
  "le bloc __if_exists n'a pas été fermé dans la portée dans laquelle il a été ouvert",
  "impossible d'initialiser dynamiquement une variable de thread local",
  "la conversion supprime le qualificateur '__unaligned'",
  "certaines valeurs d'énumérateur ne peuvent pas être représentées par le type intégral sous-jacent du type enum",
  "argument par défaut non autorisé sur une déclaration Friend de modèle de classe",
  "littéral de caractère à multiples caractères (problème de portabilité potentiel)",
  "type classe, struct ou union attendu",
  "le second opérande de offsetof doit être un champ",
  "le second opérande de offsetof ne peut pas être un champ de bits",
  "impossible d'appliquer offsetof à un membre de base virtuelle",
  "offsetof appliqué à un autre type que celui d'une classe standard",
  "arguments par défaut non autorisés sur une déclaration Friend de fonction membre",
  "arguments par défaut non autorisés sur des déclarations friend qui ne sont pas des définitions",
  "la redéclaration de %nd précédemment déclaré en tant que Friend avec des arguments par défaut n'est pas autorisée",
  "qualificateur non valide pour %t (classe dérivée non autorisée ici)",
  "qualificateur non valide pour la définition de la classe %t",
  "aucun push_macro préalable pour %sq",
  "littéral de chaîne étendu non autorisé",
  null,
  "%sq est uniquement autorisé dans C",
  "__ptr32 et __ptr64 doivent suivre un '*'",
  "__ptr32 et __ptr64 ne peuvent pas s'appliquer simultanément",
  "la liste d'arguments template de %sq doit correspondre à la liste de paramètres",
  "type classe incomplète non autorisé",
  "types intégraux complexes non pris en charge",
  "__real et __imag ne peuvent s'appliquer qu'à des valeurs complexes",
  "__real/__imag appliqué à une valeur réelle",
  "%nd a été déclaré déconseillé (%sq)",
  "redéfinition non valide de %nd",
  "dllimport/dllexport appliqué à un membre d'un espace de noms sans nom",
  "__thiscall peut uniquement apparaître sur des déclarations de fonctions membres non statiques",
  "__thiscall non autorisé sur une fonction ayant un paramètre ellipse",
  "la spécialisation explicite de %n doit précéder sa première utilisation (%p)",
  "impossible d'utiliser un type de classe sealed en tant que classe de base",
  "modificateur de classe dupliqué",
  "une fonction membre ne peut pas avoir à la fois les modificateurs 'abstract' et 'sealed'",
  "un membre sealed ne peut pas être virtuel pure",
  "impossible de déclarer une fonction virtuelle avec le modificateur 'abstract' ou 'sealed'",
  "une fonction membre déclarée avec le modificateur 'override' ne remplace pas un membre de la classe de base",
  "impossible de remplacer %nd sealed",
  "%nd a été déclaré avec le modificateur de classe 'abstract'",
  "à la ligne ",
  " de ",
  "avec ",
  "mot clé",
  "macro",
  "étiquette",
  "paramètre du modèle",
  "type",
  "Union",
  "classe",
  "struct",
  "paramètre template de modèle",
  "modèle",
  "modèle de classe",
  "enum",
  "paramètre",
  "paramètre de gestionnaire",
  "variable",
  "sans type",
  "constante",
  "fonction",
  "fonction surchargée",
  "membre",
  "champ",
  "espace de noms",
  "registre nommé",
  "espace d'adressage nommé",
  "modèle de fonction",
  "basé sur un argument template",
  "basé sur des arguments template",
  " (déclaré ",
  "(à la fin de la source)",
  "À la fin de la source",
  "Ligne",
  "ligne",
  "col.",
  "remarque",
  "Remarque",
  "avertissement",
  "Avertissement",
  "erreur",
  "Erreur",
  "erreur grave",
  "Erreur grave",
  "erreur de ligne de commande",
  "Erreur de ligne de commande",
  "erreur interne",
  "Erreur interne",
  null,
  null,
  "Limitation d'erreur atteinte.",
  "Boucle d'erreur interne",
  "Boucle lors du traitement d'une erreur grave.",
  null,
  "temporaire",
  "prétraitement de la sortie",
  "liste brute",
  "renvoi",
  "langage intermédiaire (1)",
  "langage intermédiaire (2)",
  "langage intermédiaire (3)",
  "langage intermédiaire (4)",
  "langage intermédiaire (5)",
  "langage intermédiaire (6)",
  "langage intermédiaire (7)",
  "langage intermédiaire (8)",
  "langage intermédiaire (9)",
  null,
  null,
  null,
  null,
  null,
  "indicateur impossible-redéfinir manquant",
  "mode manquant après ','",
  "nom de macro manquant",
  "valeur cannot-redefine non valide",
  "modificateur de fonction dupliqué",
  "caractère non valide pour le littéral char16_t",
  null,
  "convention d'appel inconnue %s, doit être l'une des suivantes :",
  null,
  null,
  null,
  "le type sous-jacent du type enum doit être un type intégral",
  "impossible de représenter certaines constantes d'énumérateur par %t",
  "%sq non autorisé dans le mode actuel",
  "l'option type traits helpers peut uniquement être utilisée lors de la compilation de C++",
  "l'attribut 'sentinel' requiert un paramètre ellipse",
  "l'argument doit être une constante de valeur de pointeur null",
  "nombre d'arguments insuffisant pour la valeur de la sentinelle",
  "l'argument sentinel doit correspondre à un paramètre ellipse",
  "__declspec(implementation_key(...) ne peut apparaître qu'entre #pragma start_map_region et #pragma stop_map_region",
  "#pragma start_map_region déjà actif : pragma ignoré",
  "aucun #pragma start_map_region actuellement actif : pragma ignoré",
  "impossible d'utiliser %n pour nommer un destructeur (un nom de type est requis)",
  "littéral de caractère étendu vide non standard traité en tant que L'\\0'",
  "impossible de spécifier 'typename' ici",
  "un opérateur de non-positionnement delete doit être visible dans une classe ayant un destructeur virtuel",
  "la liaison de nom est en conflit avec une déclaration précédente de %nd",
  "l'alias crée un cycle d'entités avec alias",
  null,
  "impossible de déclarer une variable ayant une durée de stockage statique allouée dans un registre spécifique avec un initialiseur",
  "une variable allouée dans un registre spécifique doit pouvoir être copiée de manière triviale",
  "signification prédéfinie de %no ignorée",
  null,
  "type de classe non utilisable par les désignateurs",
  null,
  "qualificateur d'union anonyme non standard",
  "qualificateur d'union anonyme ignoré",
  null,
  "__declspec(%s) ignoré (sans signification pour une struct C)",
  "les spécificateurs situés après la virgule entre les déclarations sont non standard",
  "spécificateur non standard ignoré",
  "attributs ignorés sur une déclaration enum qui n'est pas également une définition",
  "déclaration d'une référence avec 'mutable' non standard",
  "une déclaration de condition pour un tableau est toujours vraie",
  "échec de l'assertion statique avec %sq",
  "attribut de visibilité ignoré car il est en conflit avec une déclaration précédente",
  "le nom de champ est résolu en plusieurs offsets -- voir %nod1 et %nod2",
  "%sq n'est pas un nom de champ",
  "la valeur de l'étiquette case apparaît déjà dans ce commutateur %p",
  "une fonction membre ne peut pas avoir une liaison interne",
  "la déclaration masque le %n intégré",
  "la déclaration surcharge le %n intégré",
  "impossible de spécifier l'option pour répertorier les définitions de macro lors de la compilation de plusieurs unités de traduction",
  "parenthèse inattendue après la déclaration %n (liste de paramètres incorrecte ou initialiseur non valide ?)",
  "les parenthèses autour d'un initialiseur de chaîne sont non standard",
  "__interface",
  "une variable déclarée avec un spécificateur de type auto ne peut pas apparaître dans son propre initialiseur",
  "impossible de déduire le type 'auto'",
  "initialisation avec '{...}' non autorisée pour le type 'auto'",
  "le type 'auto' ne peut pas apparaître dans un type de tableau de premier niveau",
  "le type 'auto' ne peut pas apparaître dans un type de fonction de premier niveau",
  "un membre de type %t ne peut pas avoir un initialiseur de classe",
  "un membre avec un initialiseur de classe doit être const",
  "impossible de déduire le type 'auto' (initialiseur requis)",
  "le type 'auto' est %t1 pour cette entité, mais il était %t2 implicitement au préalable",
  "déclaration de constructeur non valide",
  "utilisation non valide d'un qualificateur de type",
  "une union ne peut pas être abstract ou sealed",
  "'auto' non autorisé ici",
  "définition de type de classe de base inachevée",
  "'extern template' ne peut pas faire référence à une spécialisation de %nd statique",
  "'extern template' ne peut pas suivre l'instanciation explicite de %n",
  "__declspec(restrict) requiert une fonction qui retourne un type pointeur",
  "l'option 'report_gnu_extensions' est uniquement valide dans les modes C GNU et C++ GNU",
  "les types tableau de longueur variable ne sont pas standard",
  "désignateurs non standard",
  "cette syntaxe de désignateur est une extension GNU",
  "littéraux composés non standard",
  "les expressions d'instruction sont une extension GNU",
  "nom asm ignoré pour une entité définie précédemment",
  "les attributs sont une extension GNU",
  "la syntaxe asm étendue est une fonctionnalité GNU",
  "les déclarations asm volatiles sont une extension GNU",
  "les spécificateurs de nom asm sont une extension GNU",
  "qualificateur '__restrict' non standard",
  "'typeof' est une extension GNU",
  "la modification de la taille ou de la signature d'un typedef est non standard",
  "les tableaux de longueur nulle sont une extension GNU",
  "les membres de tableau flexible sont non standard",
  "l'attribut 'nonnull' fait référence à un paramètre non pointeur",
  "l'argument de l'attribut 'nonnull' est supérieur au nombre de paramètres",
  "aucun paramètre n'a de type pointeur",
  "argument null fourni pour un paramètre marqué avec l'attribut 'nonnull'",
  "le destructeur de %t1 a été supprimé car le destructeur de %t2 est inaccessible",
  "le destructeur de %t qui a été supprimé est requis",
  "routine à la fois 'inline' et 'noinline'",
  "routine de nettoyage non valide",
  "l'attribut 'cleanup' requiert une durée de stockage automatique",
  "l'attribut 'cleanup' ne s'applique pas aux paramètres",
  "type de routine de nettoyage non valide",
  "l'appel de la routine de nettoyage requiert une conversion suspecte",
  "__sptr et __uptr doivent suivre '*'",
  "impossible de spécifier à la fois __sptr et __uptr",
  "la conversion étendue de pointeur de %t1 en %t2 étend le bit de signe",
  "__sptr et __uptr ne s'appliquent pas aux types pointeur vers membre",
  "la déclaration de l'opérateur d'assignation de copie de %t a été supprimée car %n est const",
  "la déclaration de l'opérateur d'assignation de copie de %t a été supprimée, car %n a un type référence",
  "la déclaration de l'opérateur d'assignation de copie de %t1 a été supprimée car celle de %t2 a été supprimée",
  "la déclaration de l'opérateur d'assignation de copie de %t1 a été supprimée car celle de %t2 est ambiguë",
  "la déclaration de l'opérateur d'assignation de copie de %t1 a été supprimée car celle de %t2 est inaccessible",
  "la déclaration du constructeur de copie de %t1 a été supprimée car celle de %t2 a été supprimée",
  "la déclaration du constructeur de copie de %t1 a été supprimée car celle de %t2 est ambiguë",
  "la déclaration du constructeur de copie de %t1 a été supprimée car celle de %t2 est inaccessible",
  "le destructeur de %t1 ne sera pas appelé car il est inaccessible et le destructeur de %t2 a été supprimé",
  "la définition à la fin du fichier n'est pas suivie d'un point-virgule ou d'un déclarateur",
  "le premier argument doit être un pointeur vers un type entier ou énumération",
  "les opérations synchronisées sont valides sur les objets de taille 1, 2, 4 ou 8",
  "arguments supplémentaires ignorés",
  "'=' pris par défaut après le nom de macro %sq dans la définition de ligne de commande",
  "espace blanc requis entre le nom de macro %sq et son texte de remplacement",
  "résultat de l'appel non utilisé",
  "l'attribut 'warn_unused_result' est ignoré pour le type de retour void",
  null,
  "dllimport/dllexport est ignoré sur une redéclaration utilisant un nom qualifié",
  "trop de caractères dans le littéral de caractère -- caractères supplémentaires ignorés au début",
  "impossible de déclarer %n inline après sa définition %p",
  null,
  null,
  "un argument template ne peut pas faire référence à un type sans liaison de nom",
  "'virtual' ignoré ici",
  "un argument template ne peut pas faire référence à un type tableau de longueur variable",
  "un nom de caractère universel ne peut pas désigner un point de code de substitution",
  "impossible d'utiliser #include_next dans un fichier source principal",
  "impossible de spécifier %no1 dans une définition de membre de modèle -- %no2 pris par défaut à la place",
  "attribut %sq ignoré dans une déclaration de fonction locale",
  "la concaténation avec %sq in %n ne crée pas un jeton valide",
  "%no est ambigu (%n2 pris par défaut)",
  "qualificateur de type non autorisé sur une fonction de membre statique",
  "qualificateur de type non autorisé sur un constructeur ou un destructeur",
  "qualificateur de type non autorisé sur un opérateur new ou un opérateur delete",
  "qualificateur de type non autorisé sur une fonction non membre",
  "l'argument de %s a des effets secondaires mais il n'est pas évalué",
  "genre de source Unicode non reconnu (doit être UTF-8, UTF-16, UTF-16LE ou UTF-16BE) : %s",
  "le caractère Unicode avec valeur hexadécimale %s n'est pas représentable dans la sortie de prétraitement",
  "la priorité demandée pour le constructeur/destructeur est réservée pour usage interne",
  "pragma GCC non reconnu",
  "directive de pragma de visibilité GCC non reconnue",
  "genre de visibilité non reconnu",
  "pragma de visibilité encore actif",
  "aucun visibility push correspondant",
  "typeid de type incomplet",
  null,
  "tableau %n supposé avoir un élément",
  "l'attribut vector_size requiert le type arithmétique ou enum",
  "taille de vecteur trop importante",
  "le nombre d’éléments dans un vecteur doit être une puissance de deux",
  "la taille de vecteur doit être un multiple de la taille d'élément",
  "opération mixte vecteur-scalaire non autorisée",
  "l'opération requiert deux vecteurs de la même taille",
  "taille de vecteur dépendante du modèle non autorisée",
  null,
  null,
  "l'attribut vector_size n'est pas autorisé avec un type d'élément complexe",
  null,
  "l'opération vecteur requiert des types d'éléments identiques",
  "l'opération vecteur ne s'applique pas à un vecteur avec un type non intégral",
  "impossible d'ouvrir le fichier %s %sq2",
  "impossible d'ouvrir le fichier %s %sq2 : %s3",
  "en-tête précompilé",
  "macro prédéfinie",
  "C généré",
  "C++ généré",
  "source",
  "erreur lors de l'écriture du fichier %s : %s2",
  "fichier non régulier",
  "est un répertoire",
  "nom de fichier non valide",
  "liste de définitions",
  "requête d'instanciation",
  "modèle exporté",
  "informations sur l'exportation",
  "informations sur le modèle",
  "sortie IL",
  "la conversion supprime le qualificateur '__restrict'",
  "impossible d'obtenir la mémoire mappée pour %sq : %s2",
  "qualificateur restrict ignoré",
  null,
  "un tableau d'éléments contenant un membre de tableau flexible est non standard",
  "un paramètre de modèle ne peut pas avoir le type vecteur",
  "l'initialisation de %n1 aura lieu avant celle de %n2",
  null,
  "genre d'héritage ignoré sur un spécificateur enum",
  null,
  "modificateur ignoré sur un spécificateur enum",
  "le caractère d'identificateur ne peut pas être représenté au format Unicode",
  "le nom d'en-tête contient des caractères ne pouvant pas être représentés au format Unicode",
  "%sq n'est pas un nom de paramètres régionaux valide",
  "la déclaration d'une liste de paramètres void avec un paramètre de modèle est non standard",
  "l'option lambdas peut uniquement être utilisée lors de la compilation de C++",
  "la capture explicite correspond à la capture par défaut",
  "%n n'est pas une variable",
  "impossible de capturer une variable avec une durée de stockage statique dans une expression lambda",
  "impossible de capturer 'this' par référence",
  "impossible d'utiliser 'this' dans le corps de cette expression lambda",
  "impossible de faire référence à un membre d'union anonyme dans la portée externe dans le corps d'une expression lambda",
  "impossible de faire référence à la variable locale d'une fonction englobante dans le corps d'une expression lambda, sauf si elle figure dans la liste de capture",
  "référence non valide à une variable locale dans la portée externe dans le corps d'une expression lambda",
  "impossible de capturer une variable locale en dehors de la portée de la fonction active",
  "impossible de faire référence à la fonction englobante 'this' dans le corps d'une expression lambda, sauf si elle figure dans la liste de capture",
  null,
  "impossible de copier la variable capturée lambda de type %t1 dans le champ closure class de type %t2",
  "répertoire de modèles non valide : %s",
  "erreur",
  "erreurs",
  "erreur grave",
  "erreurs graves",
  "et",
  "détectée(s) dans la compilation de '%s'.",
  "détectée(s) dans cette compilation.",
  "la valeur d'énumération se trouve en dehors de la plage de son type sous-jacent (%t)",
  "'\\' suivi d'un espace blanc n'est pas une jointure de ligne",
  "ce dynamic_cast ne peut pas être exécuté sans informations de type au moment de l'exécution et ces dernières sont désactivées",
  "conversion en %t ambiguë ; base directe sélectionnée",
  "une mémoire tampon interne serait trop grande",
  "un gestionnaire d'exceptions C++ a été utilisé, mais la sémantique de gestion des exceptions n'a pas été spécifiée",
  "qualificateur de type ignoré sur le constructeur",
  "une variable capturée par une capture lambda ne peut pas avoir un type impliquant un tableau de longueur variable",
  "conversion entre des types de vecteurs incompatibles",
  "'{' introduisant un corps d'expression lambda attendu",
  "l'option rvalue references peut uniquement être utilisée lors de la compilation de C++",
  "qualificateur de type non autorisé sur une expression lambda",
  "un nom ne peut pas apparaître plusieurs fois dans une liste de capture",
  "arguments template explicites ignorés",
  "expression lambda non autorisée dans une expression constante",
  "%t n'est pas un type de classe",
  "'delete' appliqué à un type pointeur vers tableau considéré comme delete[]",
  "'delete' appliqué à un type pointeur vers tableau non standard ; considéré comme delete[]",
  "impossible d'appeler %n avec la liste d'arguments donnée",
  "impossible de lier une référence rvalue à une lvalue",
  "un paramètre de modèle sans type ne peut pas avoir le type référence rvalue",
  "qualificateurs de type ignorés (le type sous-jacent est une référence)",
  "%n, déclaré à l'aide d'un type local, doit être défini dans cette unité de traduction",
  "%n, déclaré à l'aide d'un type sans liaison, doit être défini dans cette unité de traduction",
  "l'opérande d'un dynamic_cast de référence rvalue doit avoir un type classe complète",
  "'= default' peut uniquement apparaître sur les constructeurs, constructeurs de copie et de déplacement, opérateurs d'assignation de copie et de déplacement et destructeurs par défaut",
  "'= delete' peut uniquement apparaître sur la première déclaration d'une fonction",
  "impossible de faire référence à %npd -- fonction supprimée",
  "expression lambda non autorisée dans une expression non évaluée",
  "__builtin_va_arg_pack/__builtin_va_arg_pack_len peuvent uniquement apparaître dans une fonction inline avec un paramètre ellipse",
  "impossible de spécifier '= default' sur une déclaration Friend",
  "mot clé C++ attendu",
  null,
  "l'offset n'est pas une constante",
  "type de #pragma comment non reconnu %sq",
  "l'option permettant de contrôler si 'auto' est un spécificateur de type peut uniquement être utilisée lors de la compilation de C++",
  "l'option permettant de contrôler si 'auto' est une classe de stockage peut uniquement être utilisée lors de la compilation de C++",
  "la signification de 'auto' ne peut pas être désactivée à la fois pour le spécificateur de type et le spécificateur de classe de stockage",
  "chaîne non valide dans #pragma comment",
  "la fonction supprimée se substitue à %n qui n'a pas été supprimé",
  "la fonction non supprimée se substitue à %n qui a été supprimé",
  "impossible de faire référence au constructeur par défaut de %t -- il s'agit d'une fonction supprimée",
  "référence rvalue non autorisée en tant que type catch",
  "arguments par défaut de %n incompatibles avec une déclaration d'une autre unité de traduction",
  "arguments par défaut de %n différents lors de la compilation de %sq",
  null,
  "l'initialiseur de %n est différent dans une autre unité de traduction",
  "l'initialiseur de %n était différent lors de la compilation de %sq",
  "désignateur non autorisé dans un type dépendant du modèle",
  "genre de conformité non reconnu",
  "'on' ou 'off' attendu",
  "la pile #pragma conform(forScope) est vide",
  "aucune entrée #pragma conform(forScope) précédente ne correspond à %sq",
  "le comportement de forScope est non standard",
  "le comportement de forScope est standard",
  "impossible de supprimer la fonction 'main'",
  "les qualificateurs de type n'ont pas de sens ici",
  "type non valide pour l'opérateur d'assignation utilisé par défaut",
  "impossible d'utiliser des modèles de fonction par défaut",
  "type non valide pour le constructeur par défaut",
  "l'appel de fonction requiert un argument",
  "l'appel de fonction requiert un argument à virgule flottante réel",
  "impossible d'utiliser par défaut un constructeur de copie avec un argument par défaut",
  "impossible de supprimer une fonction prédéclarée",
  "instruction dépendante vide dans une instruction if",
  "instruction dépendante vide dans la clause 'else' d'une instruction",
  "impossible de faire référence à %nfd, requis pour la copie supprimée -- il s'agit d'une fonction supprimée",
  "premier paramètre %t de 'main' non standard, 'int' attendu",
  "nombre de paramètres non standard pour 'main', zéro ou deux paramètres attendus",
  "second paramètre %t de 'main' non standard, 'char *[]' ou 'char **' attendu",
  "%sq spécifié à la fois comme un répertoire include système et non système -- l'entrée non système sera ignorée",
  "l'option pour le contrôle des constructeurs de déplacement et des opérateurs d'assignation de déplacement peut uniquement être utilisée lors de la compilation de C++",
  null,
  null,
  "un type de retour de fin requiert le spécificateur de type 'auto'",
  "un type de retour de fin ne peut pas apparaître dans un déclarateur imbriqué",
  "un déclarateur de fonction avec un type de retour de fin doit être précédé d'un spécificateur de type 'auto' simple",
  "une fonction 'auto' requiert un type de retour de fin",
  "un modèle de membre ne peut pas avoir un spécificateur pure",
  "littéral de chaîne trop long -- caractères en trop ignorés",
  "l'option pour contrôler le mot clé nullptr peut être uniquement utilisée lors de la compilation de C++",
  "std::nullptr_t converted en bool",
  null,
  null,
  "l'attribut %sq n'autorise pas les listes d'arguments vides",
  "l'attribut apparaît plusieurs fois",
  "l'attribut %sq ne s'applique pas ici",
  "l'attribut %sq ne s'applique pas aux champs de bits",
  "l'attribut %sq requiert un champ de bits",
  "l'attribut %sq ne s'applique pas aux fonctions membres",
  "l'attribut %sq requiert une fonction membre",
  "l'attribut %sq ne s'applique pas aux fonctions virtuelles",
  "l'attribut %sq requiert une fonction virtuelle",
  "l'attribut %sq ne s'applique pas aux fonctions virtuelles pures",
  "l'attribut %sq requiert une fonction virtuelle pure",
  "l'attribut %sq ne s'applique pas aux variables de registre",
  "l'attribut %sq requiert une variable de registre",
  "l'attribut %sq n'apparaissait pas dans la déclaration originale",
  "attributs non autorisés ici",
  "l'attribut %sq doit apparaître dans une définition de classe",
  "'final' appliqué à une fonction virtuelle pure",
  "impossible de substituer 'final' %nd",
  "%n statique considéré comme externe, car il était référencé mais pas défini",
  "l'option permettant d'activer l'incorporation de GNU-C89-style peut seulement être utilisée lors de la compilation de C",
  "la fonction a été précédemment déclarée sans l'attribut 'gnu_inline'",
  "l'attribut 'gnu_inline' est ignoré dans les fonctions non-inline",
  "%n déclaré précédemment sans l'attribut carries_dependency",
  "initialiseur non valide pour le tableau %n",
  "doit spécifier le mode C++11 ou C++14 lors de la génération de la bibliothèque runtime",
  "l'attribut %sq ne s'applique pas aux types de fonction",
  "l'attribut %sq requiert un type de fonction",
  "l'attribut %sq ne s'applique pas aux fonctions de membre non statique",
  "l'attribut %sq ne s'applique pas aux variables automatiques",
  "l'attribut %sq requiert une variable automatique",
  "l'attribut %sq ne s'applique pas à une variable ou fonction avec liaison externe",
  "l'attribut %sq requiert une variable locale",
  "attributs ignorés ici",
  "l'attribut ne s'applique à aucune entité",
  "substitution d'argument d'attribut incorrect",
  "l'argument de l'attribut 'tls_model' doit être 'global-dynamic', 'local-dynamic', 'initial-exec' ou 'local-exec'",
  "la déclaration %p a spécifié un argument 'tls_model' différent",
  "l'attribut %sq ne s'applique pas aux fonctions inline",
  "l'attribut %sq requiert une fonction inline",
  "Les deux noms de fichiers d'un pragma include_alias doivent utiliser les mêmes caractères délimiteurs",
  "comparaison entre les opérandes signés et non signés",
  "attribut %sq ignoré sur un type sans nom",
  "l'attribut %sq est ignoré, car aucune définition ne suit",
  "la localité du thread est incompatible avec une déclaration précédente de %nd",
  "impossible de faire référence à cette variable locale d'une fonction englobante dans le corps de cette expression lambda, car une expression lambda englobante n'autorise pas les captures implicites",
  "cet argument d'attribut contient des parenthèses, crochets ou accolades dépareillés",
  "un appel à __builtin_fpclassify requiert cinq arguments intégraux suivis d'un argument à virgule flottante",
  "le dernier argument d'un appel à __builtin_fpclassify doit avoir un type à virgule flottante réel",
  "l'alignement ne peut pas être défini sur une valeur inférieure à l'alignement par défaut",
  "les attributs ne sont pas autorisés dans les instanciations explicites",
  "l'attribut %sq ne s'applique pas à une définition",
  "l'attribut %sq requiert une définition",
  "les attributs standard ne peuvent pas apparaître sur des déclarations friend qui ne sont pas des définitions",
  "l'alignement spécifié (%s1) est différent de l'alignement (%s2) spécifié sur une déclaration précédente",
  "l'attribut d'alignement doit également apparaître sur la définition %p",
  "%n ne peut pas être utilisé dans l'ID type de la déclaration d'alias",
  "modèle d'alias",
  "%t ne peut pas être transparent, car son premier champ a un type virgule flottante",
  "%t ne peut pas être transparent, car son premier champ est un champ de bits",
  "la fonction virtuelle d'une classe 'base_check' remplace un membre de classe de base, mais il lui manque l'attribut 'override'",
  "l'attribut 'hiding' spécifié sur une déclaration qui ne masque pas une déclaration de classe de base",
  "l'attribut 'hiding' spécifié sur une déclaration référencée par la déclaration using %p",
  "l'attribut 'hiding' est requis sur une déclaration (dans une classe 'base_check') qui masque %nd",
  "%n n'est pas défini dans cette unité de traduction, mais dépend d'un type local",
  "%n n'est pas défini dans cette unité de traduction, mais dépend d'un type sans liaison",
  "l'attribut %sq est manquant dans une autre unité de traduction",
  "l'attribut %sq est en conflit avec une autre unité de traduction",
  "l'option 'nonstd_gnu_keywords' est uniquement valide dans les modes C GNU et C++ GNU",
  "l'utilisation d'une variable const dans une expression constante est non standard en C",
  "un initialiseur ne peut pas être spécifié pour un membre de tableau flexible à durée de stockage automatique",
  null,
  "un type de classe 'final' ne peut pas être utilisé comme une classe de base",
  "les modèles exportés ne sont plus en langage C++ standard",
  "un désignateur dépendant du modèle n'est pas autorisé",
  "le second opérande de offsetof ne peut pas être un champ avec type référence",
  "les temporaires à durée de vie longue sont incompatibles avec les autres fonctionnalités de langage plus récentes demandées",
  "le littéral de chaîne à caractères larges ne sera pas entre guillemets dans les diagnostics",
  "arguments manquants pour l'attribut %sq",
  "les options 'c++11' et 'c++11_sfinae' requièrent une configuration de compilateur différente",
  "package de paramètres de modèle manquant à la fin de la liste de paramètres",
  "déclaration de package de paramètres non autorisée ici",
  "un package de paramètres ne peut pas avoir de valeur par défaut",
  "C++/CLI peut uniquement être activé en mode Microsoft C++",
  "impossible d'utiliser 'value__' en tant que nom de constante d'énumérateur (il s'agit d'un nom réservé dans ce contexte)",
  "une valeur d'énumérateur explicite est requise dans un type d'énumération avec un type sous-jacent booléen",
  null,
  "package de paramètres %sq référencé mais non développé",
  "l'expansion de package n'utilise aucun package d'arguments",
  "le package %sq n'a pas le même nombre d'éléments que %sq2",
  null,
  "l'attribut vector_size n'est pas autorisé avec un type d'énumération",
  "une propriété ne peut pas être à la fois statique et virtuelle",
  "une propriété indexée ne peut pas être triviale",
  "cette déclaration ne peut pas figurer dans une définition de propriété",
  "impossible d'utiliser un type de fonction qualifié pour déclarer une fonction d'accesseur",
  "une fonction d'accesseur ne peut pas avoir un paramètre ellipse",
  "un accesseur 'get' a déjà été déclaré pour cette propriété %p",
  "un accesseur 'set' a déjà été déclaré pour cette propriété %p",
  "un accesseur 'get' ne peut pas avoir de paramètre",
  "le type de retour de l'accesseur 'get' ne correspond pas au type de propriété",
  "le type de retour de l'accesseur 'set' doit être void",
  "une propriété ne peut pas déclarer une liste d'index vide",
  "un index de propriété ne peut pas être de type void",
  "le type d'index ne correspond pas au paramètre associé dans l'accesseur 'set'",
  "le type d'index ne correspond pas au paramètre associé dans l'accesseur 'get'",
  "type d'index manquant dans l'accesseur 'set'",
  "type d'index manquant dans l'accesseur 'get'",
  "paramètre de valeur de l'accesseur 'set' manquant",
  "la fonction d'accesseur a trop de paramètres",
  "le dernier paramètre de l'accesseur 'set' ne correspond pas au type de propriété",
  "%sq requiert le mode C++/CLI",
  "erreur dans l'API Win32 '%s' : %s",
  "#using peut uniquement être utilisé au niveau de la portée globale",
  "métadonnées",
  "le nom de membre %sq est réservé par %nd",
  "'[' attendu",
  "le mode %[C++/CLI] requiert microsoft_version >= 1600",
  "une propriété indexée par défaut ne peut pas être statique",
  "un accesseur de propriété ne peut pas être à la fois statique et virtuel",
  "un spécificateur de visibilité de niveau supérieur ne peut pas figurer dans une déclaration de type imbriqué",
  "un spécificateur de visibilité de niveau supérieur requiert une définition de type",
  "une propriété triviale ne peut pas être de type référence",
  "une propriété triviale ne peut pas être de type const ou volatile",
  "%nd a précédemment été déclaré en tant qu'un autre genre d'énumération",
  "une variable capturée par une capture lambda ne peut pas avoir un type de classe %[managed]",
  "une fonction virtuelle effectuant une substitution avec un type de retour covariant n'est pas autorisée dans une classe %[managed]",
  "tableau de handles non autorisé",
  "handle vers tableau non autorisé",
  "handle vers fonction non autorisé",
  "handle vers void non autorisé",
  "handle vers handle, pointeur ou référence non autorisé",
  "référence de suivi vers fonction non autorisée",
  null,
  "un champ ne peut pas être une référence de suivi",
  "une référence de suivi ne peut pas être associée à une référence ordinaire de cette façon",
  "une variable à une durée de stockage statique ne peut pas être de type classe ref",
  "une classe %[managed] doit avoir un nom",
  "une classe %[managed] ne peut pas être locale",
  "%nd a précédemment été déclaré en tant qu'un autre genre de classe",
  "%nd a précédemment été déclaré en tant qu'un autre genre de modèle de classe",
  "les données membres littérales peuvent uniquement être membres de classes %[managed]",
  "une donnée membre littérale doit être initialisée",
  "une donnée membre littérale de type %t n'est pas autorisée",
  "const n'a aucun effet sur une donnée membre littérale",
  "les données membres initonly peuvent uniquement être membres de classes %[managed]",
  "const n'a aucun effet sur une donnée membre initonly",
  "%nd n'a pas d'accesseur 'get'",
  "%nd n'a pas d'accesseur 'set'",
  "un constructeur statique ne peut pas avoir de paramètres",
  "un constructeur statique ne peut pas être un modèle de membre",
  "lvalue composé non autorisé en tant qu'opérande de sortie",
  "les propriétés peuvent uniquement être membres de classes %[managed]",
  "qualificateur de type non autorisé sur une fonction membre d'une classe %[managed]",
  "pointeur ordinaire non autorisé vers une classe ref %[C++/CLI] ou une classe interface",
  "référence ordinaire non autorisée vers une classe ref %[C++/CLI] ou une classe interface",
  "le spécificateur de substitution ne désigne pas de fonction membre de classe de base",
  "le spécificateur de substitution désigne un membre non virtuel %nd",
  "la fonction membre remplace %nd1 qui est déjà remplacé par %nd2",
  "un seul spécificateur de visibilité est autorisé",
  "le type %t utilisé pour la définition de délégué n'est pas un type de fonction",
  "les types de membres délégués peuvent uniquement être membres de classes %[managed]",
  "référence de suivi vers un type délégué non autorisée",
  "type délégué non autorisé ici",
  "cette expansion de package a généré une liste d'expressions vide et une expression est requise ici",
  "un événement ne peut pas être à la fois statique et virtuel",
  "les événements peuvent uniquement être membres de classes %[managed]",
  "cette déclaration ne peut pas figurer dans une définition d'événement",
  "le type d'événement doit être handle vers délégué",
  "un accesseur 'add' a déjà été déclaré pour cet événement %p",
  "un accesseur 'remove' a déjà été déclaré pour cet événement %p",
  "un accesseur 'raise' a déjà été déclaré pour cet événement %p",
  "un accesseur d'événement ne peut pas être à la fois statique et virtuel",
  "le type de retour des accesseurs 'add' et 'remove' doit être void",
  "paramètre de valeur manquant pour l'accesseur d'événement",
  "la fonction d'accesseur a trop de paramètres",
  "le type %t1 du paramètre de l'accesseur d'événement ne correspond pas au type d'événement (%t2)",
  "le type de l'accesseur 'raise' ne correspond pas au type d'appel de délégué de l'événement",
  "une définition d'événement doit inclure à la fois les accesseurs 'add' et 'remove'",
  "une fonction de conversion statique doit accepter exactement un argument",
  "l'opérateur statique doit avoir le type de paramètre T, T&, T%%, ou T^ avec T = %t",
  "l'opérande de sizeof... doit être un nom de package de paramètres",
  "l'opérateur sizeof... peut uniquement être utilisé dans un modèle variadique",
  "le nom d'événement ne peut pas figurer ici",
  "handle vers une classe non %[managed] non autorisé",
  "handle vers un type enum non délimité non autorisé",
  "attribut 'property' non autorisé dans une classe %[managed]",
  "un spécificateur pure ('= 0') suivi d'une définition est non standard",
  "le type nullptr %[managed] ne peut pas être utilisé ici",
  "l'opérateur '&' ne peut pas être utilisé pour prendre l'adresse d'un objet avec un type classe ref",
  "tableau de classe %[managed] non autorisé",
  "une variable à durée de stockage statique ne peut pas avoir un type de handle ou de référence de suivi",
  "une variable capturée par une capture lambda ne peut pas être un handle ou une référence de suivi",
  "un tableau de paramètres %[C++/CLI] requiert un handle vers un type %[cli::array] unidimensionnel",
  "impossible d'importer des métadonnées à partir du fichier %sq",
  "impossible d'étendre l'espace de noms cli",
  "le type d'élément d'un %[cli::array] doit être un type de handle ou de valeur",
  "nombre de dimensions non valide pour le type %[cli::array]",
  "un cli::interior_ptr/cli::pin_ptr doit pointer vers une classe standard, une classe Value, un entier, un handle ou un pointeur standard",
  "%t ne peut pas être un membre de classe",
  "paramètre de type type cli::pin_ptr non autorisé",
  "déclaration de finaliseur non valide",
  "un finaliseur ne peut pas avoir de paramètres",
  "qualificateur de type non autorisé sur un finaliseur",
  "impossible de spécifier un type de retour sur un finaliseur",
  "une déclaration using ne peut pas désigner un finaliseur",
  "un nom de finaliseur doit être qualifié",
  "le qualificateur du nom de finaliseur %t1 ne correspond pas au type %t2",
  "%n ne peut pas désigner un finaliseur (un nom de type est requis)",
  "nom de finaliseur non valide pour le type %t",
  "référence de finaliseur ambiguë -- %n1 et %n2 peuvent être utilisés",
  "un finaliseur peut uniquement être membre d'une classe ref",
  null,
  "le type utilisé en tant que nom de finaliseur ne correspond pas au type %t",
  "il n'existe aucun finaliseur pour ce type",
  "l'opérateur '%%' peut uniquement être utilisé sur un objet avec un type de classe %[managed]",
  "pointeur et handle vers ou référence à un cli::interior_ptr non autorisé",
  "pointeur et handle vers ou référence à un cli::pin_ptr non autorisé",
  "pointeur vers ou référence à un tableau %[C++/CLI] non autorisé(e)",
  "type de tableau %[C++/CLI] non autorisé ici",
  "une classe ref %[C++/CLI] ne peut dériver que d'une autre classe ref ou de classes interface",
  "une classe Value %[C++/CLI] ne peut dériver que de classes interface",
  "une classe interface %[C++/CLI] ne peut dériver que de classes interface",
  "une classe ref ne peut avoir qu'une classe de base ref directe (%t est déjà une base)",
  "une classe standard ne peut pas dériver d'une classe %[managed]",
  "une classe %[managed] ne peut pas avoir de base virtuelle",
  "une classe %[managed] ne peut pas avoir de base 'private' ou 'protected'",
  "le modificateur 'override' requiert une déclaration de fonction virtuelle avec un mot clé 'virtual' explicite",
  "le modificateur 'abstract' requiert une déclaration de fonction virtuelle avec un mot clé 'virtual' explicite",
  "le modificateur 'sealed' requiert une déclaration de fonction virtuelle avec un mot clé 'virtual' explicite",
  "un spécificateur de substitution nommé requiert une déclaration de fonction virtuelle avec un mot clé 'virtual' explicite",
  "type de retour cli::pin_ptr non autorisé",
  "l'attribut %sq s'applique uniquement en mode %[C++/CLI]",
  "une référence simple (sans suivi) ne peut pas être liée à une entité sur le tas managé",
  "assembly portable",
  "'%s' non chargé à partir des assemblys par défaut",
  "la syntaxe d'initialisation de la liste est une fonctionnalité C++11",
  "l'opérande de sizeof ne peut pas être un type classe ref ou un type classe interface",
  "nombre d'indices non valide pour ce type %[cli::array]",
  "un pointeur vers membre n'est pas valide pour une classe %[managed]",
  "la fonction membre virtuelle privée de classe %[managed] n'est pas 'sealed'",
  "modificateur non autorisé sur un destructeur",
  "modificateur non autorisé sur un finaliseur",
  "'virtual' n'a aucun effet sur le destructeur d'une classe %[managed]",
  "'new' ou 'override' requis, car cette déclaration correspond à %nd",
  "'new' ou 'virtual' requis, car cette déclaration correspond à %nd",
  "'new' ou 'override' non valide ici, car le %nd correspond est membre d'une interface",
  "modificateur 'new' sans membre de classe ref de base correspondant",
  "%nd substitué avec accès réduit",
  "impossible d'initialiser une référence de type %t1 avec une valeur de type %t2",
  "impossible de déclarer un constructeur de copie dans une classe Value",
  "impossible de déclarer un constructeur par défaut dans une classe Value",
  "impossible de déclarer un destructeur dans une classe Value",
  "impossible de déclarer un opérateur d'assignation dans une classe Value",
  "une classe non Value %t ne peut pas être le type d'un membre d'une classe Value",
  "l'option 'cppcli' requiert une autre configuration de compilateur",
  "spécifications d'exceptions non autorisées sur les fonctions membres de classes %[managed]",
  "une classe %[managed] ne peut pas déclarer un friend",
  null,
  null,
  "définition de classe locale non autorisée dans une fonction membre de classe %[managed]",
  "capture lambda locale non autorisée dans une fonction membre de classe %[managed]",
  "une fonction membre d'un type de classe interface %[C++/CLI] ne peut pas avoir de définition",
  "une définition de propriété doit inclure au moins un accesseur ('get' ou 'set')",
  "la propriété indexée par défaut est en conflit avec %nd",
  "impossible d'utiliser %n1, car il suit un package de paramètres et ne peut pas être déduit des paramètres de %n2",
  "cette expansion de package a généré plusieurs expressions, alors qu'une seule expression est requise ici",
  "le type doit correspondre à System::Boolean, System::Byte, System::SByte, System::Int16, System::UInt16, System::Int32, System::UInt32, System::Int64 ou System::UInt64",
  "appel d'un objet de type handle sans opérateur () approprié ou fonctions de conversion en type pointeur vers membre",
  "impossible de placer entre parenthèses une déclaration de package de paramètres non nommée",
  "les modèles variadiques peuvent uniquement être activés lors d'une compilation C++",
  "définition de propriété en conflit avec %nd",
  "propriété surchargée",
  "propriété",
  "un paramètre générique ne peut pas avoir de valeur par défaut",
  "un générique peut uniquement avoir des paramètres de type",
  "à utiliser avec des instructions 'for each', le type %t doit fournir une fonction membre non statique %sq",
  "'for each' ne peut pas utiliser le membre %n, car il est statique",
  "dans cette instruction 'for each', aucune instance de %no ne peut être appelée avec une liste d'arguments vide",
  "'for each' ne peut pas utiliser la fonction membre 'MoveNext', car le type de retour n'est pas valide",
  "une instruction 'for each' ne peut pas fonctionner avec une expression de type %t",
  "pour être utilisé avec des instructions 'for each', le type %t doit fournir une propriété non indexée %sq",
  null,
  "dans cette instruction 'for each', %t2 n'est pas un énumérateur valide (retourné par 'GetEnumerator' de %t1)",
  "'in' attendu",
  "la classe %t n'a aucun opérateur d'assignation approprié (après la synthèse d'opérateur)",
  "%sq n'est pas un paramètre générique",
  "%sq n'est pas un paramètre générique de la liste de paramètres génériques la plus profonde",
  "contrainte générique non valide",
  "utilisation non valide de membre d'événement (seuls l'abonnement, l'annulation d'abonnement et l'appel sont autorisés)",
  "l'appel d'un événement sans accesseur 'raise' n'est pas valide",
  "seuls '+=' et '-=' sont valides pour des événements",
  "typeid de type %[managed] non autorisé",
  "typeid d'un type pointeur %[managed] non autorisé",
  "un nom suivi de '::typeid' doit être un nom de type",
  "un membre %sq de ce type est réservé dans une classe %[managed] -- destructeur intentionnel ?",
  "un membre %sq de ce type est réservé dans une classe %[managed] -- finaliseur intentionnel ?",
  "%[System]::IDisposable::Dispose manquant ou non valide",
  "%[System]::Object::Finalize manquant ou non valide",
  "%n ne remplace pas %[System]::Object::Finalize",
  "l'opérande d'un dynamic_cast de handle doit être un handle vers un type de classe complète",
  "l'opérande d'un dynamic_cast de référence de suivi doit être une lvalue d'un type de classe complète",
  "le type d'un dynamic_cast de handle ou de référence de suivi doit faire référence à une classe complète",
  "impossible d'effectuer un cast d'un pointeur intérieur en pointeur natif",
  "les opérateurs de conversion explicite peuvent uniquement être déclarés dans des types classe Value ou ref",
  "l'opérateur de conversion explicite ne peut pas être virtuel",
  "l'expression doit être de type arithmétique ou enum non délimité",
  "l'expression doit être de type arithmétique, enum non délimité ou pointeur",
  "l'expression doit être de type intégral ou enum non délimité",
  "l'expression doit être de type intégral, enum non délimité ou virgule fixe",
  "un opérateur binaire intégré appliqué à une énumération délimitée requiert deux opérandes du même type",
  "%[gcnew] ne peut pas allouer une entité de type %t",
  "impossible d'utiliser la syntaxe de positionnement avec %[gcnew]",
  "new peut uniquement être utilisé avec des types valeur simples",
  "impossible d'utiliser new avec une classe %[managed] (%[gcnew] doit être utilisé à la place)",
  "impossible d'utiliser new avec un type de handle",
  "%[gcnew] pour un tableau %[C++/CLI] doit avoir un nouvel initialiseur ou un initialiseur de tableau",
  "un initialiseur de tableau peut uniquement être utilisé pour initialiser un type de tableau %[C++/CLI]",
  "auto non autorisé par %[gcnew]",
  "trop de limites d'index de tableau",
  "limites d'index de tableau insuffisantes",
  "arguments insuffisants pour %nf",
  "trop d'arguments pour %nf",
  "classe générique",
  "aucune déclaration de %nf n'accepte le nombre d'arguments génériques fournis",
  "initialiseur de délégué non valide -- il doit s'agir d'une fonction",
  "initialiseur de délégué non valide -- plusieurs fonctions correspondent au type délégué",
  "initialiseur de délégué non valide -- la fonction ne correspond pas au type délégué",
  "initialiseur de délégué non valide -- en plus d'une fonction, un objet est requis",
  "initialiseur de délégué non valide -- la fonction n'est pas membre d'une classe %[managed]",
  "initialiseur de délégué non valide -- objet non requis pour la fonction spécifiée",
  "initialiseur de délégué non valide -- objet de type %t1 mais type %t2 attendu",
  "la prise d'adresse d'une fonction membre d'une classe %[managed] n'est pas autorisée",
  "initialiseur de délégué non valide -- '(<adresse-fonction>)' ou '(<handle-objet>, <adresse-membre>)' attendu",
  "la classe ne peut pas implémenter le membre d'interface %nd",
  "impossible d'utiliser %[gcnew] pour allouer un tableau natif",
  "une classe d'interface %[C++/CLI] ne peut pas déclarer un opérateur d'assignation",
  "une classe interface %[C++/CLI] ne peut pas être sealed",
  null,
  "une déclaration de destructeur ou de finaliseur ne peut pas inclure un spécificateur de substitution nommé",
  "un spécificateur de substitution ne peut pas désigner un destructeur ou un finaliseur",
  "un spécificateur de substitution nommé est uniquement autorisé dans une classe %[managed]",
  "aucun membre désigné par le spécificateur de substitution nommé ne correspond au type de ce membre",
  "une déclaration de constructeur statique ne peut pas inclure un spécificateur de substitution nommé",
  "un type énumération délimitée doit avoir un nom",
  "transfert de contrôle non autorisé dans un bloc finally",
  "instruction return non autorisée dans un bloc finally",
  "un bloc try requiert au moins un gestionnaire ou une clause finally",
  "un objet %[managed] doit être levé par un handle",
  "un objet %[managed] doit être intercepté par un handle",
  "impossible d'utiliser une instruction break dans un bloc finally",
  "impossible d'utiliser une instruction continue dans un bloc finally",
  "impossible d'utiliser un offsetof intégré en cas d'indices surchargés",
  "contrainte dupliquée",
  "plusieurs contraintes de classe : %t1 et %t2",
  "plusieurs clauses de contrainte pour %n",
  "les données membres static initonly doivent avoir un initialiseur ou être initialisées dans un constructeur statique",
  "les attributs GNU d'une redéclaration de modèle n'ont aucun effet",
  "les attributs GNU d'une redéclaration de modèle n'ont aucun effet (les attributs de la déclaration d'origine %p s'appliquent à la place)",
  "un tableau de paramètres %[C++/CLI] doit être le dernier paramètre",
  "une fonction avec un tableau de paramètres %[C++/CLI] ne peut pas avoir d'arguments par défaut",
  "un tableau de paramètres %[C++/CLI] ne peut pas être suivi d'un paramètre ellipse",
  "tableau de paramètres %[C++/CLI] non autorisé dans la liste de paramètres de fonction d'un opérateur",
  "__inline et __forceinline non autorisés ici",
  "une donnée membre ne peut pas avoir un type de classe interface %[C++/CLI]",
  "une variable ne peut pas avoir un type de classe interface %[C++/CLI]",
  "un paramètre ne peut pas avoir un type de classe interface %[C++/CLI]",
  "un type de retour de fonction ne peut pas être un type de classe interface %[C++/CLI]",
  "tableau de types de paramètres génériques non autorisé",
  "pointeur et handle vers ou référence à un type de paramètre générique non autorisé",
  "un champ initonly ne peut pas avoir un type de classe ref",
  "une référence ne peut pas être liée à un champ initonly",
  "prise d'adresse d'un champ initonly non autorisée",
  "un champ initonly peut uniquement être modifié par le constructeur d'instance de sa classe conteneur",
  "un champ initonly statique peut uniquement être modifié par le constructeur statique de sa classe conteneur",
  "la fonction membre sera appelée sur une copie du champ initonly",
  "l'expression doit avoir un type pointeur ou descripteur mais elle a le type %t",
  "un constructeur de déplacement ou un opérateur d'assignation de déplacement est utilisé pour copier une lvalue ici, ce qui peut détruire l'objet source",
  "la sélection de membre sur une entité générique %[C++/CLI] doit utiliser la syntaxe '->', et non pas '.'",
  "un type de classe ref ne peut pas dériver de %t",
  "une classe générique doit être %[managed] (par ex., une classe Value ou une classe interface)",
  "impossible d'utiliser une classe sealed en tant que contrainte",
  "le type d'un dynamic_cast ne peut pas être un type générique susceptible d'être un type valeur",
  "un nom de caractère universel doit désigner un point de code valide",
  "les contraintes génériques ne correspondent pas à celles de %nd",
  "__underlying_type s'applique uniquement aux types d'énumération",
  "une seule expression d'opérande attendue pour ce cast",
  "le caractère Unicode avec valeur hexadécimale %s n'est pas représentable dans la page de codes par défaut système",
  "conversion non standard de pointeur vers membre lié en pointeur fonction",
  "spécificateur d'accès %s1 déconseillé -- utiliser %s2 à la place",
  "fonction d'accesseur statique non autorisée dans une propriété ou définition d'événement non statique",
  "%t a une classe Value et une contrainte de classe ref",
  "%t1 et %t2 impliquent des contraintes de type naked circulaires",
  "%t n'est pas une contrainte de type valide",
  "fichier d'en-tête précompilé %sq non utilisé (car il est incomplet)",
  "%t n'est pas un argument générique valide",
  "attribut assembly_info appliqué à un type non valide",
  "%t1 ne respecte pas la contrainte de classe ref du paramètre générique %t2",
  "%t1 ne respecte pas la contrainte de classe Value du paramètre générique %t2",
  "%t1 ne respecte pas la contrainte %[gcnew] du paramètre générique %t2, car il est abstrait",
  "%t1 ne respecte pas la contrainte %[gcnew] du paramètre générique %t2, car il ne dispose pas d'un constructeur public par défaut",
  "le paramètre générique %t1 ne respecte pas la contrainte %[gcnew] du paramètre générique %t2, car il ne dispose pas de la contrainte %[gcnew]",
  "%t1 ne respecte pas la contrainte de type %t3 du paramètre générique %t2",
  "la contrainte du paramètre générique %t est différente de la déclaration précédente (%p)",
  "un membre d'une classe %[managed] ne peut pas être un tableau standard",
  "un membre d'une classe non %[managed] ne peut pas être un handle",
  "un membre d'une classe non %[managed] ne peut pas être une référence de suivi",
  "reinterpret_cast de handle non sécurisé",
  "un argument template ne peut pas faire référence à un paramètre de type générique",
  "une liste d'expressions n'est pas autorisée dans cette opération d'indice (utilisez des parenthèses autour d'un opérateur virgule de niveau supérieur)",
  "l'expression doit avoir un type pointeur vers objet ou descripteur vers tableau %[C++/CLI] mais elle a le type %t",
  "attribut non reconnu",
  "un membre d'une classe %[managed] ne peut pas être d'un type de classe non %[managed]",
  "un membre d'une classe non %[managed] ne peut pas avoir un type de classe ref ou un type de classe interface",
  "dans ",
  "un délégué ne peut pas être déclaré en tant que modèle",
  "un générique ne peut pas être explicitement spécialisé",
  "un générique ne peut pas être déclaré dans un modèle de classe",
  "un modèle ne peut pas être déclaré dans une classe générique",
  "un champ littéral ne peut pas être déclaré 'static'",
  "'long float' est une extension non standard -- utilisez 'double' à la place",
  "une classe standard ne peut pas être imbriquée dans une classe %[managed]",
  "__clrcall est valide uniquement en mode C++/CLI",
  "__clrcall non autorisé sur une fonction ayant un paramètre ellipse",
  "%sq non autorisé ici",
  "impossible d'utiliser une propriété triviale ou un événement pour remplacer %nd",
  "nom de variable d'itérateur attendu",
  "le type d'itérateur dans cette instruction for each est %t, qui n'est ni un type de pointeur ni un type de classe similaire aux itérateurs",
  "le type d'itérateur dans cette instruction for each est %t, qui n'est ni un type de pointeur ni un type de classe similaire aux itérateurs",
  "le type d'itérateur dans cette instruction for each est %t, qui n'est ni un type de pointeur ni un type de classe similaire aux itérateurs",
  "l'attribut packing sur le type parent est ignoré pour ce champ de type de classe %t non standard",
  "%nd non implémenté, car cette déclaration n'est pas publique et n'a pas de spécificateur de substitution nommé",
  "cette déclaration ne contient pas l'attribut gnu_inline spécifié dans la déclaration précédente %p",
  "une fonction membre d'une classe %[managed] ne peut pas avoir un paramètre ellipse",
  "%n déclaré précédemment non valide en tant qu'itérateur de l'instruction 'for-each'",
  "convention d'appel ignorée, car le type de fonction implique un paramètre générique ; __clrcall utilisé à la place",
  "un type de fonction impliquant un paramètre générique ne peut pas avoir un paramètre ellipse",
  "'virtual' est requis pour remplacer le %nd correspondant",
  "'virtual' est requis pour implémenter le %nd correspondant",
  "des données membres initonly ne peuvent pas être volatiles",
  "un %sq membre de ce type est réservé dans une classe %[managed] -- Les opérateurs %[C++/CLI] doivent être déclarés à l'aide du mot clé 'operator'",
  "une référence de suivi vers une non-constante ne peut pas être liée à une constante",
  "attributs ignorés ici, car ils ne s'appliquent pas à une entité déclarée",
  "référence de suivi vers %[System]::String non autorisée",
  "utilisation non valide d'une classe générique %t avec contraintes en attente (ceci est probablement du à un fichier de métadonnées non valide)",
  "une clause de contrainte en attente est seulement autorisée pour les déclarations de classe générique (mais pas les définitions de classe générique)",
  "liste d'initialiseurs vide non autorisée ici",
  "impossible de déclarer un modèle dans une classe %[managed]",
  "déclaration générique non autorisée ici",
  "les types d'interface ne peuvent pas avoir de génériques membres",
  "Caractère Unicode non Latin-1, tronqué à l'octet de poids faible",
  "à utiliser avec les instructions 'for' basées sur une plage, le type %t doit fournir la fonction %sq",
  "le type d'itérateur dans cette instruction for basée sur une plage est %t, qui n'est ni un type de pointeur ni un type de classe similaire aux itérateurs",
  "le type d'itérateur dans cette instruction for basée sur une plage est %t, qui n'est ni un type de pointeur ni un type de classe similaire aux itérateurs",
  "le type d'itérateur dans cette instruction for basée sur une plage est %t, qui n'est ni un type de pointeur ni un type de classe similaire aux itérateurs",
  "une instruction 'for' basée sur une plage ne peut pas opérer sur un tableau de taille inconnue ou de type incomplet %t",
  "les types de retour pour les fonctions 'begin' et 'end' utilisés dans une instruction 'for' basée sur une plage doivent être identiques (le type de retour de 'begin' est %t1, le type de retour de 'end' est %t2)",
  "%nfd, requis pour détruire l'objet temporaire supprimé, est inaccessible",
  "dans cette instruction 'for' basée sur une plage, aucune instance de %no ne correspond à la liste d'arguments",
  "cette instruction 'for' basée sur une plage nécessite une fonction %sq appropriée et aucune n'a été trouvée",
  "cette instruction 'for each' nécessite une fonction %sq appropriée et aucune n'a été trouvée",
  "%t a une représentation de métadonnées non représentable à l'aide de %[C++/CLI]",
  "'...' attendu",
  "%t dans la liste __implements n'est pas une interface",
  "une liste __implements doit précéder les déclarations de fonctions virtuelles",
  "%t a spécifié '__implements ...' dans sa liste de bases, but il manque une liste __implements correspondante",
  "le résultat du déréférencement d'un handle en type de classe ref ou interface doit être utilisé",
  null,
  "une ')' était attendue ; le pragma a été ignoré",
  "une déclaration using ou d'accès ne peut pas apparaître dans une classe managée",
  "Remarque : %nd aurait pu être appelé, mais n'a pas été considéré car il est inaccessible",
  "une fonction de membre abstraite d'une classe C++/CLI managée ne peut pas avoir de définition",
  "la déclaration de cet 'operator*' unaire peut modifier la signification ou le déréférencement d'un handle (utilisez des opérateurs de membre static pour indiquer explicitement les types applicables)",
  "managé",
  "C++/CX",
  "C++/CLI",
  "Mappage C++/CX",
  "par défaut",
  "mappage cli",
  "cli::array",
  "Platform::Array",
  "Tableau C++/CLI",
  "Tableau C++/CX",
  "Système",
  "Plateforme",
  "gcnew",
  "ref new",
  "une classe interface ne peut pas contenir de membre de données non statique",
  "impossible d'utiliser #pragma GCC system_header dans le fichier source principal",
  "%n est trop volumineux pour être inlined",
  " (déclaré implicitement)",
  "l'option de contrôle des opérations de déplacement peut uniquement être utilisée lors de la compilation de C++",
  "les opérations de déplacement ne peuvent pas être générées lorsque les constructeurs rvalue sont des constructeurs de copie",
  "l'option de contrôle des opérations de déplacement ne peut pas être utilisée lorsque les références rvalue sont désactivées",
  "'final' ne peut pas être utilisé pour les classes managées (utilisez 'sealed' à la place)",
  "cast en classe d'interface CLI %t non autorisé -- cast en handle prévu ?",
  "impossible de créer un objet de classe d'interface CLI",
  "cette déclaration masque la déclaration non standard de %nd, car les types sous-jacents sont incompatibles",
  "le résultat de comparaison de pointeur est constant, car l'opérande ne peut jamais être null",
  "un objet de type incomplet %t ne peut pas être initialisé par une valeur",
  "une référence ne peut pas être initialisée par une valeur",
  "'(' ou '{' attendu",
  "l'initialisation de copie de liste ne peut pas utiliser un constructeur marqué 'explicit'",
  "un pointeur vers un membre de type void n'est pas autorisé",
  "un pointeur vers un membre de type référence n'est pas autorisé",
  "un pointeur vers un membre de type handle n'est pas autorisé",
  "une liste entre accolades n'est pas autorisée ici",
  "un membre operator->* n'est pas autorisé dans une classe managée",
  "les métadonnées de l'assembly référencent un assembly inexistant",
  "l'attribut %sq2 est en conflit avec l'attribut %sq1 antérieur",
  "%nd a précédemment été déclaré avec un type de base différent",
  "'enum class' et 'enum struct' ne peuvent pas être utilisés ici (utilisez un 'enum' simple à la place)",
  "un seul niveau d'accolades autorisé sur un initialiseur pour un objet de type %t",
  "%nd ne peut pas être utilisé en tant que nom de type d'énumération",
  null,
  "un initialiseur entre accolades ne peut pas être utilisé avec 'new auto'",
  "la définition de std::initializer_list ne contient pas le constructeur attendu",
  "la déclaration masque %nd",
  "liste de paramètres du modèle non valide pour std::initializer_list (il doit s'agir uniquement d'un paramètre de type ordinaire sans valeur par défaut)",
  "une liste entre accolades ne peut pas être passée pour un paramètre ellipse",
  "#include <initializer_list> est nécessaire avant l'utilisation de std::initializer_list, dont une utilisation implicite",
  "Le mot clé 'inline' ne peut pas être utilisé sur une déclaration d'alias d'espace de noms",
  "la déclaration précédente de %n n'était pas déclarée inline",
  "%n a déjà été déclaré Inline",
  "le premier argument doit être une constante entière",
  "impossible d'utiliser un désignateur avec un type différent d'un agrégat %t",
  "un désignateur pour un membre d'union anonyme peut uniquement apparaître entre des accolades qui correspondent à cette union anonyme",
  "les balises de prototype de fonction peuvent uniquement être activées lors de la compilation du C",
  "les accolades ne peuvent pas être omises pour cet initialiseur de sous-objet",
  "conversion restrictive non valide de %t1 à %t2",
  "conversion restrictive non valide de %t1 à %t2 : la valeur constante ne peut pas être contenue dans le type de destination",
  "le cast vers un type de tableau incomplet %t n'est pas autorisé",
  "conversion restrictive non valide de %t1 à %t2 : la valeur constante ne peut pas être représentée exactement dans le type de destination",
  "un initialiseur entre parenthèses pour une entité autre qu'une classe doit être une expression et non une liste entre accolades",
  "une liste entre accolades ne fournit pas de type de retour pour cette expression lambda",
  "la spécification d'exception déclarée est incompatible avec celle qui a été générée",
  "les types d'énumération délimitée sont une fonctionnalité du C++11",
  "un type de fonction ne peut pas être initialisé par une valeur",
  "l'initialisation de liste d'un type d'objet %t n'est pas autorisée car le type est incomplet",
  "std::initializer_list a un destructeur et n'est pas censé en avoir un -- la bibliothèque n'est pas configurée correctement",
  "les types de base d'énumération explicite sont une fonctionnalité du C++11",
  "cette expression constante est de type %t1 au lieu du type %t2 requis",
  "un 'new' d'un objet std::initializer_list ne fonctionne généralement pas comme il le devrait car le tableau sous-jacent est détruit à la fin de l'expression complète",
  "Dans le fichier macro prédéfini",
  null,
  "'defined' est toujours false dans une expansion macro en mode Microsoft",
  "%t ne peut pas être le type d'élément d'une liste d'initialiseurs car il ne s'agit pas d'un type d'objet complet",
  "délimiteurs incompatibles dans l'expression d'argument par défaut",
  "conversion non standard de pointeur vers membre en pointeur fonction",
  "spécifications d'exception dynamiques obsolètes",
  "impossible de spécialiser partiellement %n dans la portée actuelle",
  "%nd a précédemment été déclaré comme constexpr",
  "%nd n'a pas été précédemment déclaré comme constexpr",
  "initialiseur manquant pour la variable constexpr",
  "'constexpr' non valide ici",
  "une fonction constexpr doit contenir exactement une instruction return",
  "l'instruction ne peut pas s'afficher dans une fonction constexpr",
  "l'instruction ne peut pas s'afficher dans un constructeur constexpr",
  "une fonction ne peut pas être à la fois constexpr et virtual dans ce mode",
  "une fonction constexpr ne peut pas avoir un type de retour non littéral %t",
  "une fonction constexpr ne peut pas avoir un paramètre de type non littéral %t",
  "les utilisations non séquencées de %n dans une expression peut produire des résultats indéfinis",
  "le troisième argument facultatif d'un appel à __builtin_assumed_aligned doit avoir un type intégral",
  "un destructeur ne peut pas être constexpr",
  "l'adresse fournie pour mmap doit être alignée sur une frontière de page : %s",
  "le corps d'un constructeur constexpr ne peut pas être un bloc try de fonction",
  "constexpr %nf ne fournit aucun initialiseur pour :",
  "%n",
  "l'appel du constructeur par défaut pour %t ne crée pas une valeur constante",
  "le constructeur par défaut pour %t n'est pas constexpr",
  "une variable constexpr doit avoir un type littéral ou un type référence",
  "le constructeur d'une classe avec des bases virtuelles ne peut pas être constexpr",
  "l'appel de fonction doit avoir une valeur constante dans une expression constante",
  "impossible de déclarer la fonction 'main' constexpr",
  null,
  "une définition de classe ou de type d'énumération ne peut pas apparaître dans une fonction constexpr ou dans le corps d'un constructeur",
  "seuls les attributs de style GNU sont autorisés ici",
  "utilisation non standard de 'auto' pour déduire le type d'un initialiseur et pour annoncer un type de retour de fin",
  "la déclaration d'une liste de paramètres void avec un type void qualifié est non standard",
  "le qualificateur sur cette déclaration locale est ignoré",
  "cette expression constante est de type %t1 au lieu du type %s requis",
  "une instanciation de __bases ou __direct_bases requiert un type de classe",
  "l'argument de __bases et __direct_bases doit être un paramètre de modèle avec type",
  "%s ne peut être utilisé que dans les contextes de modèle",
  "le retour de fonction constexpr n'est pas constant",
  "le constructeur constexpr appelle %n qui n'est pas constexpr",
  "le constructeur ne peut pas être constexpr, car l'initialiseur de %n n'est pas une expression constante",
  "initialiseur non constant pour le constructeur constexpr",
  "le constructeur généré par défaut pour %t ne peut pas être utilisé dans un initialiseur pour son propre membre de données",
  "l'instanciation de l'initialiseur de %n dépend de sa propre valeur",
  "le constructeur par défaut utilisé par défaut ne peut pas être constexpr, parce que le constructeur par défaut implicitement déclaré correspondant ne sera pas constexpr",
  null,
  "nombre binaire non valide",
  "une union peut avoir au plus un initialiseur de champ – %nd a aussi un initialiseur",
  null,
  "le constructeur constexpr d'une union doit initialiser l'un de ses champs",
  "le constructeur constexpr n'a pas réussi à initialiser une union anonyme (définie %p)",
  "la déclaration des données membres static de constexpr requiert un initialiseur de classe",
  "les options depth/count maximum de constexpr peuvent uniquement être utilisées lors de la compilation C++",
  "expression non pliée en une constante en raison d'une trop grande complexité d'appels de fonction constexpr",
  "les options d'union illimitée peuvent uniquement être utilisées lors de la compilation C++",
  "le constructeur constexpr doit initialiser la classe de base directe %t",
  "la création d'un objet std::initializer_list dans un initialiseur de champ ne fonctionne généralement pas comme il le devrait, car le tableau sous-jacent est détruit à la fin de l'expression complète",
  "Impossible d'utiliser 'this' dans une expression constante",
  null,
  "'constexpr' n'est pas autorisé sur une directive d'instanciation explicite",
  "impossible de déterminer la spécification d'exception du constructeur par défaut en raison d'une dépendance circulaire",
  "union anonyme définie %p",
  "ce constructeur utilise l'initialiseur de %nd, ce qui se traduira par une récursivité non liée",
  null,
  "initialiseur non autorisé sur la déclaration locale d'une variable externe",
  "initialiseur non autorisé sur la déclaration locale d'une variable de registre nommée",
  null,
  "les unions non restreintes ne peuvent pas être activées en mode Microsoft",
  "le constructeur se délègue directement ou indirectement à lui-même",
  "un constructeur qui effectue une délégation ne peut pas avoir d'autres initialiseurs membres",
  "qualificateur ref non autorisé ici",
  "la surcharge de deux fonctions membres avec les mêmes types de paramètre est possible uniquement si ces deux fonctions ont des qualificateurs ref ou si elles en sont dépourvues",
  "caractère non valide dans un délimiteur de chaîne brute",
  "parenthèse de fin d'un délimiteur de chaîne brute introuvable dans la limite de 16 caractères ; indicateur de chaîne brute ignorée",
  "délimiteur de fin de chaîne brute introuvable",
  "un package de paramètres doit être l'argument template final dans une spécialisation partielle",
  "une fonction pointeur vers membre avec le type %t peut uniquement être utilisée avec un objet lvalue",
  "une fonction pointeur vers membre avec le type %t peut uniquement être utilisée avec un objet rvalue",
  "le paramètre de ce constructeur de copie par défaut ne peut pas être const, car un paramètre de constructeur de copie de base ou de membre est non const",
  "le paramètre de cet opérateur d'assignation par défaut ne peut pas être const, car un paramètre d'assignation de copie de base ou de membre est non const",
  "une union anonyme doit contenir au moins un membre de données non statique",
  "l'option 'delegating_constructors' nécessite une autre configuration de compilateur",
  "réduction d'alignement ignorée",
  "l'opérande d'un const_cast en type référence rvalue ne peut pas être une prvalue sans classe",
  "l'expression doit être une lvalue ou une xvalue",
  "la conversion peut changer la valeur",
  "la conversion d'un littéral de chaîne en 'char *' est déconseillée",
  "la conversion d'un littéral de chaîne en pointeur vers caractère (non const) est déconseillée",
  "'override' et 'final' sont des options C++11",
  "impossible d'utiliser des références rvalue comme types de spécification d'exception",
  "l'attribut %sq ne s'applique pas aux paramètres de gestionnaire",
  "l'attribut %sq nécessite un paramètre de gestionnaire",
  "alignas ne s'applique pas ici",
  "l'opérateur 'alignof' standard n'accepte pas d'argument d'expression (utilisez un type à la place)",
  "qualificateur non valide pour %t (classe dérivée non autorisée ici)",
  "l'attribut 'always_inline' est ignoré dans les fonctions non inline",
  "les constructeurs d'héritage doivent être hérités d'une classe de base directe",
  null,
  "étiquette attendue",
  "nombre d'opérande attendu après '%%l'",
  "le nombre d'opérande pour '%%l' ne fait pas référence à un argument d'étiquette valide",
  "une chaîne étendue est non valide dans une instruction 'asm'",
  "attribut non standard",
  "n'est pas une classe de base de %t",
  "caractère non identificateur trouvé dans le suffixe de littéral défini par l'utilisateur",
  "impossible d'utiliser un littéral à plusieurs caractères dans un littéral défini par l'utilisateur",
  "le suffixe de littéral défini par l'utilisateur ne correspond pas au %sq précédent",
  "nom de l'opérateur de littéral non valide",
  "l'opérateur de littéral défini par l'utilisateur est introuvable",
  "opérateurs de littéral et/ou modèle d'opérateur de littéral ambigus :",
  "un opérateur de littéral ne peut pas être membre d'une classe",
  "un opérateur de littéral ne peut pas contenir de liaison de nom externe 'C'",
  "un opérateur de littéral doit comporter au moins un paramètre",
  "cet opérateur de littéral a trop de paramètres",
  "type de paramètre %t non valide pour l'opérateur de littéral",
  "type de paramètre entier non valide (%t) pour l'opérateur de littéral ; type caractère ou unsigned long long attendu",
  "type de paramètre virgule flottante (%t) non valide pour l'opérateur de littéral ; type 'long double' attendu",
  "type du premier paramètre (%t) non valide pour l'opérateur de littéral ; type 'pointer to non-const' non autorisé",
  "type du deuxième paramètre (%t) non valide pour l'opérateur de littéral ; doit être 'size_t'",
  "type de paramètre de pointeur non valide (%t) pour l'opérateur de littéral ; pointeur vers un type caractère attendu",
  "un opérateur de littéral ne peut pas comporter de paramètre ellipse",
  "un modèle d'opérateur de littéral ne peut pas comporter de paramètres",
  "un modèle d'opérateur de littéral doit avoir une liste de paramètres de modèle de type '<char ...>'",
  "la classe de stockage locale de thread est non valide ici",
  "la déclaration locale de thread suit une déclaration locale non-thread (%p déclaré)",
  "la déclaration locale non-thread suit la déclaration locale de thread (%p déclaré)",
  "un opérateur de littéral ne peut pas comporter d'arguments par défaut",
  "attribut ignoré pour les variables locales de thread",
  "le suffixe d'un littéral fourni par l'utilisateur doit commencer par '_'",
  "les références rvalue sont une fonctionnalité C++11",
  "les expressions lambda sont une fonctionnalité C++11",
  "la syntaxe d'attribut standard est une fonctionnalité C++11",
  "les constructeurs de délégation sont une fonctionnalité C++11",
  "les constructeurs d'héritage sont une fonctionnalité C++11",
  "les initialiseurs de champ sont une fonctionnalité C++11",
  "les fonctions supprimées sont une fonctionnalité C++11",
  "les fonctions par défaut sont une fonctionnalité C++11",
  "impossible d'utiliser une classe de stockage dans une spécialisation explicite",
  null,
  "une énumération non délimitée doit être opaque pour être spécialisée",
  "une déclaration de modèle d'énumération doit faire référence à un membre précédemment déclaré d'un modèle de classe",
  "opérande de vecteur attendu",
  "les opérandes de source de lecture aléatoire ont des types %t1 et %t2 incompatibles",
  "le masque de lecture aléatoire (type %t) n'est pas un vecteur d'entiers",
  "la longueur du masque de lecture aléatoire (type %t1) est différente de l'opérande source (type %t2)",
  "l'initialisation statique avec une valeur d'adresse nécessite une destination de la même taille que l'adresse",
  "l'argument d'une macro de test de fonctionnalité doit être un identificateur simple",
  "impossible d'utiliser __has_include_next dans le fichier source principal",
  "nom de fichier absolu utilisé dans __has_include_next",
  "l'attribut %sq doit être appliqué à un type de fonction",
  null,
  "_Noreturn n'est pas autorisé ici",
  "opérande de type virgule flottante réel attendu (non %t)",
  "__builtin_complex requiert des opérandes de types compatibles (et non %t1 et %t2)",
  "une association par défaut est déjà présente dans cette sélection _Generic",
  "un type utilisant un tableau de longueur variable n'est pas autorisé ici",
  "type d'association (%t) en double dans la sélection _Generic",
  "aucune association ne correspond au type de sélecteur %t",
  "le type de %n (%t) est incompatible avec un type de résolution ifunc",
  "une fonction ne peut pas avoir les attributs ifunc et alias",
  "une fonction ne peut pas avoir les attributs ifunc et weak",
  "l'appel nécessite un opérande de littéral de chaîne",
  "déclaration de constructeur hérité en double (précédemment %p)",
  "'decltype(auto)' doit être un espace réservé pour le type complet de la variable (et non un composant de ce type)",
  "decltype(auto) n'est pas autorisé ici",
  "impossible de déduire 'decltype(auto)' (initialiseur obligatoire)",
  "impossible de déduire le type 'decltype(auto)'",
  "une déclaration locale de thread de portée de bloc doit inclure static ou extern",
  "le type de retour %t1 déduit est en conflit avec le type %t2 précédemment déduit",
  "impossible de déduire le type de retour de %nd; il n'a pas été défini",
  "une fonction virtuelle ne peut pas avoir un type de retour déduit",
  "%n sera considéré comme un mot clé contextuel à partir de ce point",
  "l'espace de noms global n'a pas de membre réel %sq",
  "comparaison entre deux types enum différents (%t1 et %t2)",
  "attribut cible non reconnu",
  "fonction cible 'default' manquante",
  "seule une cible arch= peut être indiquée",
  "une classe générique ne peut pas être un attribut personnalisé",
  "cible d'attribut %sq non valide",
  "attribut ambigu -- %t1 et %t2 peuvent être utilisés",
  "un argument d'attribut nommé ne peut faire référence qu'à un champ en lecture/écriture non statique publique ou à une propriété scalaire",
  "un argument d'attribut nommé ne peut faire référence qu'à un champ non statique ou à une propriété scalaire d'un type de paramètres d'attribut",
  "argument d'attribut non valide -- l'expression doit être une constante d'un type de paramètre d'attribut",
  "un argument d'attribut ne peut pas utiliser des paramètres de type générique",
  "%t doit être utilisé uniquement en tant qu'attribut autonome",
  "la cible d'attribut 'field' ne peut pas être utilisée dans une propriété/événement non trivial",
  "cible d'attribut non valide pour un attribut autonome",
  "cible d'attribut non valide dans ce contexte",
  "l'attribut %t ne peut pas être utilisé ici",
  "%t est déprécié ; utilisez '...' pour indiquer un tableau de paramètres",
  "l'espace de noms par défaut ne peut pas être étendu",
  "le type boxed doit être une classe Value ou une enum",
  "référence de suivi vers la classe value non autorisée",
  "handle vers la classe value non autorisé",
  "référence de suivi vers enum non autorisée",
  "handle vers enum non autorisé",
  "type natif public non autorisé",
  "type imbriqué public non autorisé",
  "types génériques non autorisés en C++/CX",
  "méthodes génériques non autorisées en C++/CX",
  "contraintes génériques non autorisées",
  "les membres de données non publics ne sont pas autorisés dans les types de valeur C++/CX publics",
  "les membres publics qui ne sont pas des données ne sont pas autorisés dans les types de valeur C++/CX publics",
  "constructeurs non autorisés dans les types valeur C++/CX publics",
  "le type de retour de l'accesseur 'add' doit être Windows::Foundation::EventRegistrationToken",
  "le type de retour de l'accesseur 'remove' doit être void",
  "le type de paramètre de l'accesseur 'remove' doit être Windows::Foundation::EventRegistrationToken",
  "handle ou référence à un type de paramètre générique non autorisé",
  "membres de données public non autorisés dans les types non-valeur",
  "C++/CX peut uniquement être activé en mode Microsoft C++",
  "impossible de combiner les modes C++/CLI et C++/CX",
  "%sq nécessite le mode C++/CX",
  "Le mode C++/CX nécessite microsoft_version >= 1600",
  "Les champs littéraux ne sont pas autorisés en C++/CX",
  "impossible de lier une référence standard à un type C++/CX",
  "le type doit correspondre à Platform::Boolean, default::uint8, default::int8, default::int16, default::uint16, default::int32, default::uint32, default::int64 ou default::uint64",
  "un type valeur C++/CX ne peut pas avoir d'événements",
  "un dynamic_cast à un type de handle doit référencer un type de classe complet",
  "Platform::Array peut uniquement être unidimensionnel",
  "le suivi de la référence à un type de classe standard n'est pas autorisé",
  "un type valeur C++/CX ne peut pas hériter d'une interface",
  "un type valeur C++/CX ne peut pas contenir de fonctions virtuelles",
  "'partial' peut uniquement être appliqué à 'ref class' ou 'ref struct' dans la portée globale ou la portée espace de noms",
  "le paramètre de l'accesseur 'set' doit être de type 'const Platform::Array<T>^'",
  "la définition d'un type C++/CX public n'est pas autorisée au niveau de la portée globale",
  "une propriété indexée avec un accesseur 'get' ou 'set' public n'est pas autorisée",
  "un type délégué imbriqué public n'est pas autorisé",
  "initialiseur de délégué non valide -- '(<function-address or functor-object> [, Platform::CallbackContext])' ou '(<object handle>, <member-address> [, Platform::CallbackContext [, bool]])' attendu",
  "initialiseur de délégué non valide -- l'objet doit être un handle de classe %[managed]",
  "C++/CX ne prend pas en charge les tableaux 'in/out' -- utilisez 'const Platform::Array<T>^' pour 'in' et 'Platform::WriteOnlyArray<T>^' ou 'Platform::Array<T>^*' pour 'out' sur les API publiques",
  "attribut 'target' manquant pour %nd",
  "aucune fonction membre déclarée ne correspond aux attributs 'target' pour %n",
  "les attributs Microsoft à cet emplacement ne sont autorisés que pour les types d'interface",
  "routine de résolution multiversion de la fonction GNU obligatoire",
  "un type enum déclaré dans une classe managée doit inclure une définition",
  "un nom qualifié decltype n'est pas standard dans ce contexte de déclaration",
  "une fonction non virtuelle ne peut pas être déclarée avec le modificateur 'final'",
  "l'attribut 'target' sur une fonction spéciale n'est pas pris en charge",
  "doit être un littéral de chaîne étroit",
  "parenthèses sans correspondance",
  "aucun 'push_options' correspondant",
  "ce pragma n'est pas autorisé dans une fonction",
  "la déclaration d'un opérateur 'inline' new ou delete n'est pas standard",
  "un initialiseur mem pour un membre de données ne peut pas être une expansion de package",
  "des expressions lambda génériques ne peuvent pas utiliser les valeurs par défaut de capture dans ce mode",
  "un argument de modèle par défaut dans une déclaration friend ne peut être défini que dans une définition",
  "une déclaration de modèle friend avec un argument de modèle par défaut doit être l'unique déclaration (%p déclaré en premier)",
  "une déclaration enum opaque ne peut pas faire partie d'une autre déclaration",
  "une déclaration enum opaque n'est pas standard dans ce contexte",
  "la syntaxe friend étendue est une fonctionnalité C++11",
  "les séparateurs numériques ne sont pas activés, l'apostrophe représente le début d'un littéral de caractère",
  "un séparateur numérique ne peut pas s'afficher ici",
  "'constexpr' est ignoré ici en mode Microsoft",
  "expression non valide pour le résultat d'expression d'instruction",
  "l'identificateur est une macro et non un suffixe littéral",
  "%nd ne peut pas être appelé sur lvalue",
  "%nd ne peut pas être appelé sur rvalue",
  "une fonction membre ne peut pas être appelée sur lvalue",
  "une fonction membre ne peut pas être appelée sur rvalue",
  "la liste de paramètres de modèle est trop longue",
  "le type de modèle d’alias %t1 est incompatible avec le type précédent de %t2 dans la redéclaration de %nfd",
  "l’initialiseur de champ pour %nd n’est pas une expression constante",
  "le nombre de contraintes d’opérande doit être identique dans chaque chaîne de contrainte",
  "la chaîne de contrainte contient trop de contraintes alternatives ; certaines contraintes n’ont pas été vérifiées",
  "un appel via la classe incomplète %t produit toujours une erreur lorsque celle-ci est instanciée",
  "decltype(auto) ne peut pas avoir ajouté des qualificateurs de type",
  "impossible de capturer init-capture %nod ici",
  "argument de modèle sans type non valide de type %t",
  "l'attribut abi_tag est ignoré (il n'a aucune signification en mode C)",
  "la redéclaration ajoute l'attribut abi_tag '%s'",
  "l'attribut abi_tag est ignoré (annulé et remplacé par un autre attribut abi_tag)",
  "la déclaration précédente de %nd n'avait aucun attribut abi_tag",
  "(voir la déclaration précédente %p)",
  "attribut abi_tag ignoré durant la spécialisation",
  "decltype(auto) ne peut pas s'afficher sous une construction de pointeur, de référence ou de pointeur vers membre",
  "'class' ou 'typename' attendu",
  "l'expression 'new' de positionnement fait référence au %nd de non-positionnement",
  "doit spécifier le mode C++14 durant la génération de la bibliothèque runtime",
  "%s",
  "avertissement de ligne de commande",
  "Avertissement de ligne de commande",
  "La fonction membre non statique constexpr ne sera pas implicement 'const' dans C++14",
  "Le type de variable %t dans la fonction constexpr n'est pas un type littéral",
  "La variable dans la fonction constexpr ne possède pas de durée de stockage automatique",
  "la variable dans la fonction constexpr n'est pas initialisée",
  "L'initialisation entre accolades d'une variable déclarée avec un type d'espace réservé mais sans `=` requiert exactement un élément à l'intérieur des accolades",
  "aucune configuration --target '%s' n'existe",
  "l'attribut n'est pas pris en charge dans les configurations x86 64 bits",
  "'%s' nécessite un argument",
  "un constructeur ou un destructeur ne peut pas être une coroutine",
  "%n ne peut pas être une coroutine",
  "les expressions co_yield ne sont pas autorisées dans une clause catch",
  null,
  null,
  null,
  null,
  "modèle de classe %sq introuvable",
  "utilisez le mot clé 'typename' pour traiter %n comme un type dans un contexte dépendant",
  "la valeur de l'argument doit être inférieure à la somme des éléments de vecteur",
  "%t n'a aucun membre %sq",
  "une liste entre accolades ne fournit pas de type de retour",
  "une expression co_await doit apparaître dans l'étendue d'une fonction",
  "une expression co_await n'est pas autorisée dans une clause catch",
  "une coroutine ne peut pas comporter de paramètre ellipse",
  "l'activation de constexpr en C++14 nécessite la prise en charge de 'bool'",
  "constexpr %nd non défini",
  "impossible d'évaluer cet appel, car la fonction cible %nd n'est pas constexpr ou n'est pas encore complètement définie",
  "remarque",
  "Remarque",
  "union anonyme non valide -- modèle de membre d'alias non autorisé",
  "une valeur littérale de caractère UTF-8 ne peut pas occuper plus d'une unité de code",
  "impossible d'utiliser la valeur de %nd comme constante",
  "impossible d'utiliser un pointeur ou une référence à %nd comme constante",
  "indice différent de zéro pour un objet qui n'est pas un tableau",
  "impossible d'accéder à la position %d1 dans le tableau de %d2 éléments",
  "appelé à partir de :",
  "accès non valide au %n1 inactif de l'union (%n2 est actif)",
  "impossible d'exécuter 'goto' dans les contextes constexpr",
  "valeur retournée manquante",
  "l'appelé a une valeur null",
  "tentative de déréférencement d'un pointeur null",
  "tentative d'accès au stockage juste après la fin du tableau de %d éléments",
  "tentative d'accès au stockage expiré",
  "tentative d'accès au stockage au moment de l'exécution",
  null,
  "impossible d'appeler un(e) %nd non constexpr",
  "impossible d'utiliser un tableau de longueur variable durant une évaluation de constexpr",
  "impossible d'effectuer un déplacement négatif",
  "valeur de déplacement (%d) trop grande",
  "la valeur dépasse la plage de %t",
  "erreur de valeur à virgule flottante",
  "tentative de déréférencement d'un pointeur vers membre null (membre de données)",
  "la comparaison d'un pointeur à void et d'un pointeur à une fonction n'est pas standard",
  "échec de l'initialisation des métadonnées",
  "cast du type de base en type dérivé non valide (le type de classe complet est %t)",
  "accès non valide à %n dans l'objet de type complet %t",
  "'__auto_type' non autorisé ici",
  "'__auto_type' n'autorise pas plusieurs déclarateurs",
  "initialisation avec '{...}' non autorisée pour '__auto_type'",
  "'__auto_type' doit être un espace réservé pour le type complet de la variable (et non pour un composant de ce type)",
  "une variable déclarée avec '__auto_type' nécessite un initialiseur",
  "une constante entière doit être supérieure ou égale à zéro",
  "le type doit être un type intégral",
  "impossible d'interpréter l'expression",
  "impossible d'interpréter l'instruction",
  "utilisation non valide de l'adresse de stockage de l'interpréteur",
  "genre de constante non valide pour l'expression constante",
  "type %t trop grand pour l'évaluation de l'expression constante",
  "type %t non valide pour l'évaluation de l'expression constante",
  "la conversion de %t1 en %t2 est non valide dans l'évaluation de l'expression constante",
  "échec de la conversion en valeur à virgule flottante",
  null,
  "les types de retour déduits sont une fonctionnalité C++14",
  "impossible d'évaluer un constructeur avec un destructeur associé",
  "%n non initialisé durant l'évaluation de constexpr",
  "différence de pointeur non valide dans l'évaluation de constexpr",
  "arithmétique non valide sur un pointeur qui n'est pas de type tableau",
  "impossible de définir un pointeur avant le premier élément de tableau",
  "une coroutine avec un type de retour déduit est non valide",
  "expression non autorisée dans un contexte non évalué",
  null,
  null,
  "'return' n'est pas autorisé dans une coroutine (utilisez 'co_return' à la place)",
  "'co_return' est uniquement autorisé dans les coroutines",
  "impossible de comparer les valeurs à virgule flottante",
  "impossible de comparer les valeurs de pointeur, car elles ne pointent pas vers le même objet complet, ou bien elles pointent vers des sous-objets avec une accessibilité distincte",
  "attribut abi_tag ignoré dans l'espace de noms non inline",
  "attribut abi_tag ignoré dans l'espace de noms anonyme",
  "type de paramètre de modèle complexe ou imaginaire non standard",
  "l'expression co_yield n'est pas autorisée en dehors d'une étendue de fonction",
  "indication locale de thread ignorée sur l'union anonyme",
  null,
  "modèle de variable",
  "accès à l'objet non initialisé",
  "tentative de lecture à partir d'une mémoire volatile",
  "accès non valide au %n1 inactif de l'union (aucun champ n'est actif)",
  "les définitions d'étiquette ne peuvent pas apparaître dans les fonctions constexpr",
  "impossible de comparer un pointeur situé après la fin d'un tableau à un pointeur vers un autre objet complet",
  "le type de fonction %t est un type non valide pour l'instanciation d'un modèle de variable",
  "la variable ne peut pas avoir le type incomplet %t",
  "accès au sous-objet non initialisé (%n)",
  "accès au sous-objet non initialisé (classe de base %t)",
  "un appel de pseudo-destructeur n'est pas autorisé dans une expression constante",
  "tentative de modification du stockage de const",
  null,
  null,
  "tentative d'accès au stockage situé juste après un objet considéré comme un tableau d'un seul élément",
  "impossible d'utiliser reinterpret_cast dans l'évaluation d'une expression constante",
  "opération non autorisée sur un pointeur null",
  "impossible d'utiliser la valeur de *this comme constante",
  "le mot clé 'inline' ne peut pas être utilisé sur une déclaration d'espace de noms imbriquée",
  "l'attribut 'carries_dependency' est ignoré",
  "'__event __interface' ne peut pas avoir de définition ici",
  "un gestionnaire d'événements doit avoir un type de retour void ou intégral",
  "'__event __interface' doit avoir été défini",
  "trop d'arguments de modèle pour %n",
  "énumérateur déjà déclaré (voir %nd)",
  "la version émulée Microsoft doit être au moins la version 1903 pour permettre l'utilisation de '--ms_c++14'",
  "la version émulée Microsoft doit être au moins la version 1903 pour permettre l'utilisation de '--ms_c++latest'",
  "le type %t ne peut pas être _Atomic, car il s'agit d'un type tableau ou fonction",
  "impossible d'appliquer le spécificateur _Atomic(...) au type qualifié %t",
  "accès au membre de l'objet _Atomic",
  "un champ de bits ne peut pas avoir un type _Atomic",
  "Les types de classe _Atomic sont désactivés",
  "un constructeur constexpr appelle un constructeur non constexpr pour l'initialisation d'un sous-objet",
  "virgule attendue (la version de static_assert à un seul argument n'est pas activée dans ce mode)",
  "échec de l'assertion statique",
  "un qualificateur _Nullable, _Nonnull et _Null_unspecified maximum peut modifier un type",
  "les qualificateurs de possibilité de valeur Null sont autorisés uniquement sur les types pointeur et pointeur vers membre",
  "longueur de vecteur trop grande",
  "le type d'élément de vecteur doit être intégral, enum ou un type à virgule flottante réel",
  "la fonction intégrée n'est pas disponible car les entiers 128 bits ne sont pas pris en charge",
  "la fonction intégrée n'est pas disponible car les types de vecteur ne sont pas pris en charge",
  "deux crochets gauches successifs introduisent toujours une liste d'attributs, mais aucune liste d'attributs ne peut apparaître ici",
  "un attribut 'target' non reconnu empêche cette routine d'être utilisée par la routine de résolution",
  "%t n'est pas un type de vecteur",
  "les types de vecteur %t1 et %t2 doivent avoir la même longueur",
  "les arguments par défaut ajoutés ne peuvent pas entraîner la déclaration d'un constructeur par défaut ou de copie",
  "un argument template sans type de type référence doit être lié à une fonction ou à un objet complet",
  "%t non autorisé ici",
  "l'utilisation du spécificateur de classe de stockage 'register' n'est pas autorisée",
  "l'utilisation du spécificateur de classe de stockage 'register' est dépréciée",
  "incrémentation de valeur booléenne non autorisée",
  "%sq, déclaré comme itérateur de l'instruction 'for' basée sur une plage, ne peut pas être redéclaré dans cette étendue",
  "un espace de noms d'attribut ne peut pas être utilisé ici (car un préfixe 'using' a été spécifié)",
  "espace de noms d'attribut %sq non reconnu",
  "un initialiseur de membre par défaut n'est pas autorisé dans une classe value",
  "'--implicit_noexcept' nécessite un mode qui active noexcept",
  "impossible de plier une opération impliquant une classe de base virtuelle (%t)",
  "l'initialisation n'est pas constante",
  "impossible d'évaluer la valeur du %t incomplet",
  "valeur retournée ignorée dans la routine déclarée avec l'attribut 'nodiscard'",
  "type valeur retourné ignoré avec l'attribut 'nodiscard'",
  "l'attribut 'nodiscard' ne s'applique pas aux destructeurs ou routines ayant le type de retour void",
  "l'attribut 'fallthrough' s'applique uniquement aux instructions ayant une valeur null",
  "l'attribut 'fallthrough' peut apparaître uniquement dans une instruction switch englobante",
  "l'instruction fallthrough doit précéder l'étiquette case ou default de switch",
  "référence ou pointeur vers un objet temporaire avec une durée de vie limitée",
  "impossible d'accepter l'adresse d'une fonction avec un attribut 'enable_if' dont la condition n'est pas true de manière inconditionnelle",
  "les attributs 'enable_if' utilisés avec des conditions qui ne sont pas des valeurs de constante ne sont pas pris en charge",
  "attribut déclaré ici",
  "__has_include ne peut pas apparaître en dehors de #if",
  "impossible d'ajouter la classe de base CComCoClass",
  "ne représente pas une chaîne finissant par une valeur null",
  "impossible d'utiliser le type non-scalaire %t dans un appel de pseudo-destructeur",
  "l'adresse de 'weak' %n n'est pas une constante",
  "trop de substitutions récursives des signatures de modèle de fonction",
  "spécificateur non valide pour la déclaration de liaison structurée",
  "syntaxe de liaison structurée non valide",
  "initialiseur manquant",
  "le type %t n'a aucun composant auquel se lier",
  "trop d'identificateurs",
  "il existe plus d'éléments que de noms de liaisons",
  "'std::tuple_element' non défini",
  "impossible d'instancier 'std::tuple_element' pour <%s, %t>",
  "impossible d'appeler la fonction membre 'get<%s>()' pour le type %t",
  "aucune instance de %no ne correspond à la liste d'arguments",
  "cette liaison structurée nécessite une fonction %sq adaptée, mais celle-ci est introuvable",
  "une liaison structurée ne peut pas être déclarée 'inline'",
  "une liaison structurée ne peut pas être déclarée 'constexpr'",
  "une liaison structurée ne peut pas déclarer une classe de stockage explicite",
  "std::tuple_size<%t>::value n'est pas une expression constante intégrale valide",
  "une déclaration de condition doit déclarer une variable",
  "une déclaration de condition doit inclure un initialiseur",
  "un initialiseur entre parenthèses n'est pas autorisé pour une déclaration de condition",
  "une déclaration de condition peut déclarer uniquement une seule variable",
  "une liaison structurée ne peut pas se lier au type de clôture",
  "impossible d'effectuer une liaison au %n non public",
  "impossible d'effectuer une liaison au type incomplet %t",
  "cette déclaration est non valide ici",
  "le corps d'une fonction constexpr ne peut pas être un bloc try de fonction",
  "transfert de contrôle non autorisé dans un bloc if de constexpr",
  "impossible de capturer la liaison structurée",
  "la version émulée Microsoft doit être au moins la version 1911 pour permettre l'utilisation de '--ms_c++17'",
  "tentative de lecture au-delà de la fin de l'objet",
  "les expressions lambda constexpr ne sont pas activées dans ce mode",
  "une expression constante ne peut pas contenir une expression lambda",
  "la valeur dépasse le nombre d'arguments de modèle",
  "le second opérateur de l'expression fold binaire ne correspond pas au premier",
  "opérateur d'expression fold non valide",
  "impossible d'appliquer une expression fold binaire à deux packages de paramètres",
  "extension vide non valide pour cette expression fold",
  "impossible de déclarer un membre de données non statique comme étant inline",
  "l'expression fold ne fait pas référence à un package de paramètres",
  "impossible de surcharger deux fonctions ayant les mêmes types de paramètre mais des spécifications d'exceptions distinctes",
  "les spécifications d'exceptions dynamiques ne sont pas autorisées dans ce mode",
  null,
  "opérande non valide pour le spécificateur noexcept",
  "l'expression lambda ne peut pas apparaître dans le spécificateur noexcept d'un modèle",
  "%nfd est inaccessible",
  "spécificateur non valide dans une déclaration de modèle d'enum",
  "Les types à virgule flottante 80 bits ne sont pas pris en charge dans cette configuration",
  "Les types à virgule flottante 128 bits ne sont pas pris en charge dans cette configuration",
  "valeur d'énumérateur non valide",
  "doit être un type qualifié _Atomic",
  "le type d'élément de tableau doit être complet",
  "l'attribut always_inline a été supprimé pour cette fonction",
  "aucune valeur négative n'est autorisée ici",
  "un élément de pack d'entiers ne peut pas correspondre à %n",
  "un élément de pack d'entiers ne peut pas correspondre à %n",
  "désignateur inattendu",
  "impossible d'évaluer __builtin_offsetof",
  "impossible de définir le guide de déduction %t",
  "le guide de déduction doit être déclaré dans la même étendue que %n",
  "spécificateur non valide pour la déclaration du guide de déduction (seul 'explicit' est autorisé)",
  "impossible d'accéder à la valeur mutable %n d'une constante dans une expression constante",
  "le modificateur de fonction ne s'applique pas à une déclaration de membre statique",
  "l'attribut 'overloadable' nécessite une déclaration de fonction prototypée",
  "impossible de déduire le type de paramètre de modèle 'auto' %t1 à partir de %t2",
  "Le nom du modèle de classe doit être un espace réservé pour le type complet en cours d'initialisation (et non pour un composant de ce type)",
  "les déclarations d'alias sont une fonctionnalité C++11",
  "les modèles d'alias sont une fonctionnalité C++11",
  "le type de retour doit désigner directement une spécialisation du modèle de classe associé",
  "l'initialisation de copie de liste ne peut pas utiliser un %n 'explicit'",
  "guide de déduction",
  "Valeur non valide pour l'opérateur de littéral défini par l'utilisateur",
  "__has_cpp_attribute ne peut pas apparaître en dehors de #if ou #elif",
  "le guide de déduction doit être déclaré avec la même accessibilité que %n",
  "un lambda n'est pas autorisé dans ce contexte",
  "l'alignement spécifié n'est pas équivalent à la déclaration précédente",
  "aucun alignement spécifié dans la définition ; la déclaration précédente avait spécifié un alignement",
  "la fonction intégrée n'est pas disponible, car les types à virgule flottante 128 bits ne sont pas pris en charge",
  "le déplacement vers la gauche d'une valeur négative a un comportement non défini",
  "les désignateurs de tableau ne sont pas standard en C++",
  "les désignateurs chaînés ne sont pas standard en C++",
  "le mélange d'initialiseurs désignés et non désignés n'est pas standard en C++",
  "les initialiseurs hors service ne sont pas standard en C++",
  "un modèle d'opérateur de littéral de chaîne doit avoir une liste de paramètres de modèle de type '<typename T, T ...>'",
  "un désignateur en double n'est pas autorisé",
  "conflit d'attributs avec l'attribut likely/unlikely précédent",
  "la capture par copie implicite de 'this' est dépréciée",
  "une liste de paramètres de modèle vide n'est pas autorisée dans une expression lambda",
  "la version émulée Microsoft doit être au moins la version 1920 pour permettre l'utilisation de '--ms_c++20'",
  "Argument de pragma STDC non accepté dans ce mode",
  "constexpr si les instructions sont une fonctionnalité C++17",
  "l'expansion de pack n'est pas autorisée dans une liste d'initialiseurs désignée",
  "le désignateur de champ n'a aucune valeur",
  "une union peut avoir au maximum un initialiseur de champ",
  "type std::%s valide introuvable (<compare> doit être inclus)",
  "types non valides (%t1 et %t2) pour l'opérateur intégré<=>",
  "les expressions fold ne sont pas standard dans ce mode",
  "le répertoire spécifié via l'option --current_directory n'est pas un répertoire : %s",
  "Avertissement PCH",
  "la fin de l'en-tête doit se trouver au niveau de l'étendue globale. Aucun fichier PCH IntelliSense n'a été généré.",
  "appel de macro en cours. Aucun fichier PCH IntelliSense n'a été généré.",
  "la fin de l'en-tête ne se situe pas au niveau de l'étendue du fichier. Aucun fichier PCH IntelliSense n'a été généré.",
  "la fin de l'en-tête ne peut pas se situer dans une macro ou un bloc #if. Aucun fichier PCH IntelliSense n'a été généré.",
  "la fin de l'en-tête ne peut pas se situer dans un bloc de liaison. Aucun fichier PCH IntelliSense n'a été généré.",
  "l'emplacement de fin d'en-tête adapté est introuvable. Aucun fichier PCH IntelliSense n'a été généré.",
  "impossible d'utiliser des directives line dans un fichier PCH. Aucun fichier PCH IntelliSense n'a été généré.",
  "spécificateur de restriction non valide",
  "la fonction %nfd restreinte à amp doit être appelée à partir d'une fonction à restriction amp",
  "la fonction %nfd1 a des spécificateurs de restriction incompatibles avec l'appel de la fonction %nfd2",
  "aucun candidat de surcharge n'a les spécificateurs de restriction appropriés",
  "%t non autorisé dans la fonction à restriction amp %nfd",
  "type interdit %t dans ce pointeur pour la fonction membre %nfd restreinte à amp",
  "type de retour interdit %t pour la fonction à restriction amp %nfd",
  "type de paramètre interdit %t pour la fonction à restriction amp %nfd",
  null,
  "classe de stockage interdite %s dans la fonction à restriction amp %nfd",
  "%s non autorisé dans la fonction à restriction amp %nfd",
  "cast non conforme dans la fonction à restriction amp",
  "spécification d'exception non autorisée dans la fonction à restriction amp",
  "indirection non conforme dans la fonction à restriction amp %nfd",
  "appels de fonction virtuels non conformes dans la fonction à restriction amp %nfd",
  "appels de fonction indirects non conformes dans la fonction à restriction amp %nfd",
  "classe de stockage tile_static non autorisée ici",
  "étiquette non conforme dans la fonction à restriction amp %nfd",
  "champ de bits non conforme pour la fonction à restriction amp %nfd",
  "ellipse non conforme pour la fonction à restriction amp %nfd",
  "base virtuelle non conforme pour le type %nfd compatible avec amp",
  "référence externe non conforme dans la fonction à restriction amp %nfd",
  "valeur de constante en dehors de la plage prise en charge dans la fonction à restriction amp %nfd",
  "valeur de pragma pack non conforme %s pour la fonction à restriction amp",
  "spécificateurs de restriction en chevauchement non autorisés",
  "les spécificateurs de restriction du destructeur doivent couvrir l'union des spécificateurs de restriction sur tous les constructeurs",
  null,
  "nostdlib nécessite au moins un using forcé",
  null,
  null,
  null,
  null,
  "les spécificateurs de restrictions multiples ne sont pas pris en charge sur les fonctions \"C\" externes",
  "pointeur vers des fonctions membres, pointeurs de fonction, références à des fonctions avec spécificateur de restriction 'amp' non autorisés",
  "la classe de base, le membre de données ou l'élément de tableau doivent être alignés sur au moins 4 octets pour la fonction à restriction amp %nfd",
  "le décalage d'un membre de données doit être un multiple de son alignement naturel pour la fonction à restriction amp %nfd",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "les variables tile_static ne peuvent pas être associées à un initialiseur",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "/clr:nostdlib nécessite la présence de mscorlib.dll dans la liste des using forcés",
  "Quand vous utilisez /clr:netcore avec /clr:nostdimport, System.Runtime.dll, System.Runtime.Extensions.dll, System.Runtime.InteropServices.dll et System.Runtime.CompilerServices.VisualC.dll doivent se trouver dans la liste des using forcés",
  null,
  null,
  null,
  null,
  null,
  "<échec d'émission de diagnostic>",
  "Il existe trop d'erreurs pour que le moteur IntelliSense puisse fonctionner correctement. Certaines de ces erreurs ne sont pas visibles dans l'éditeur.",
  "l'assignation à l'anachronisme 'this' n'est pas compatible avec le mode C++11",
  "une erreur inconnue s'est produite. Aucun fichier PCH IntelliSense n'a été généré.",
  "Impossible de mapper un ou plusieurs chemins distants à des chemins locaux existants. L'expérience IntelliSense risque d'être dégradée.",
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  null,
  "'>>>' attendu",
  "la déclaration __cudaPushCallConfiguration est introuvable. L'installation du kit de ressources CUDA est peut-être endommagée.",
  "l'initialiseur de style C++17 n'est pas standard dans ce mode",
  "la capture de *this n'est pas standard dans ce mode",
  "Le préfixe d'attribut 'using' de style C++17 n'est pas standard dans ce mode",
  "Les espaces de noms imbriqués de style C++17 ne sont pas standard dans ce mode",
  "seule une instance de 'constexpr', 'consteval' et 'constinit' peut apparaître dans une déclaration",
  "une fonction ne peut pas être à la fois consteval et virtual dans ce mode",
  "'consteval' n'est pas autorisé sur une directive d'instanciation explicite",
  "'consteval' est non valide ici",
  "un destructeur ne peut pas être consteval",
  "le constructeur d'une classe avec des bases virtuelles ne peut pas être consteval",
  "'consteval' n'est pas autorisé dans la déclaration d'une variable ou d'un membre de données statique",
  "%nd a été déclaré consteval",
  "%nd n'a pas été déclaré consteval",
  "impossible de déclarer la fonction 'main' consteval",
  "l'appel au %n consteval n'a pas généré une expression constante valide",
  "adresse du %n consteval dans le résultat de l'expression constante",
  "le membre consteval ne peut pas remplacer le %n non consteval",
  "le membre non consteval ne peut pas remplacer le %n consteval",
  "liaison structurée",
  "le dynamic_cast vers le sous-objet de type %t1 est non valide (le type le plus dérivé est %t2)",
  "l'identificateur __VA_OPT__ peut uniquement apparaître dans les listes de remplacement de macros variadiques",
  "__VA_OPT__ ne peut pas apparaître dans un opérande __VA_OPT__",
  "parenthèse fermante manquante pour __VA_OPT__",
  "__VA_OPT__ doit être suivi de '('",
  "'##' ne doit pas être placé en premier dans un opérande __VA_OPT__",
  "'##' ne doit pas être placé en dernier dans un opérande __VA_OPT__",
  "Les espaces de noms inline imbriqués de style C++20 ne sont pas standard dans ce mode",
  "impossible de convertir le pointeur vers la classe de base %t2 en pointeur vers la classe dérivée %t1 -- tentative de pointage au-delà de l'objet le plus dérivé",
  null,
  "impossible d'utiliser 'main' en tant que nom de variable globale ou liaison de langage C spécifique",
  "la fonction 'main' ne peut pas être déclarée dans une spécification de liaison",
  "la liaison structurée n'est pas autorisée dans une condition",
  "un identificateur d'espace de noms d'attribut est obligatoire avant '::'",
  "un seul espace de noms d'attribut est autorisé",
  "'return' non autorisé ici",
  "une liaison structurée ne peut pas être associée à d'autres déclarateurs",
  "impossible de créer une branche à partir d'un contexte d'évaluation de constante",
  "les modèles de liaison structurée ne sont pas autorisés",
  "un initialiseur entre parenthèses doit être une expression et non une liste entre accolades",
  "impossible de déduire les arguments de modèle de classe",
  "impossible de déclarer un opérateur new ou delete 'consteval'",
  "impossible d'utiliser ici l'adresse d'une fonction consteval",
  "l'alignement d'un type de fonction (%t) n'est pas standard",
  "l'alignement d'un tableau aux limites non spécifiées n'est pas standard en C",
  "une variable ne peut pas avoir à la fois les attributs 'common' et 'internal_linkage'",
  "l'attribut 'internal_linkage' n'est pas apparu dans une déclaration antérieure",
  "aucun candidat de déduction d'argument de modèle viable n'a été localisé pour %n",
  "un appel de constructeur complet n'est pas autorisé",
  "un opérateur de comparaison par défaut doit être membre ou ami de la classe à laquelle il s'applique",
  "type %t incorrect pour le paramètre de l'opérateur de comparaison par défaut (il doit s'agir d'une 'référence à const X' où X est le type classe englobant)",
  "le type de retour de l'opérateur de comparaison par défaut doit être 'bool'",
  "un opérateur de comparaison de membres par défaut doit être 'const'",
  null,
  "le type de promesse %t d'une coroutine ne peut pas avoir à la fois 'return_void' et 'return_value' définis",
  "'return_value' déclaré dans %p",
  "'return_void' déclaré %p",
  "instruction co_return manquante alors que %t n'a aucun 'return_void' à la fin de %n",
  "variante nothrow de la fonction globale 'operator new' introuvable pour l'allocation d'état de la coroutine",
  "'operator delete' viable introuvable pour la désallocation d'état de la coroutine",
  "une fonction constexpr ne peut pas être une coroutine",
  "l'opérande de cette expression %s est résolu en un %t qui n'est pas une classe",
  "une expression co_await n'est pas autorisée dans un initialiseur statique",
  "l'expression co_await qui appelle %n ne doit pas lever d'exception",
  "trop d'opérations de réécriture de comparaison récursive",
  "un type de retour déductible pour un opérateur par défaut <=> doit être 'auto'",
  "copie implicite d'une source non constante",
  "une liaison structurée ne peut pas déclarer une autre classe de stockage explicite que static ou thread_local",
  "les opérateurs de comparaison par défaut ne sont pas pris en charge pour les champs de propriété Microsoft non triviaux",
  "le type de comparaison standard (%t) doit être un type classe avec un seul membre de données non statique de type intégral",
  "membre de données statique constexpr %sq introuvable dans %t",
  "nombre d'éléments (%d) trop grand pour une allocation dynamique",
  "demande d'allocation dynamique constexpr trop grande",
  "désallocation de stockage non alloué dynamiquement",
  "la taille de désallocation (%d1) ne correspond pas à la taille allouée (%d2)",
  "une allocation s'est produite ici",
  "le type de désallocation (%t1) ne correspond pas au type d'allocation (%t2)",
  "certaines allocations dynamiques (nombre total = %d) n'ont pas été libérées",
  "%n intrinsèque déclaré avec une signature inattendue (type %t)",
  ">> sortie de std::__report_constexpr_value",
  ">> fin de la sortie de std::__report_constexpr_value",
  "impossible d'utiliser un tableau avec une taille de tableau dépendante dans l'évaluation constexpr",
  "valeur retournée ignorée dans la routine déclarée avec l'attribut 'nodiscard' (%sq)",
  "type valeur retourné ignoré avec l'attribut 'nodiscard' (%sq)",
  "le constructeur utilisé pour créer un objet abandonné a l'attribut 'nodiscard'",
  "le constructeur utilisé pour créer un objet abandonné a l'attribut 'nodiscard' (%sq)",
  "le type d'objet abandonné a l'attribut 'nodiscard'",
  "le type d'objet abandonné a l'attribut 'nodiscard' (%sq)",
  "une référence à un pseudo-destructeur peut être utilisée uniquement pour un appel à un pseudo-destructeur",
  "un appel à un destructeur explicite n'est pas autorisé dans une expression constante",
  "l'utilisation d'un opérateur virgule non placé entre parenthèses dans une expression d'indice de tableau est dépréciée",
  "le nombre d'éléments alloués dynamiquement (%d) est trop faible pour l'initialiseur",
  "l'utilisation d'un opérande volatile dans l'expression %s est dépréciée",
  "l'utilisation du résultat d'une affectation dans un objet scalaire volatile est dépréciée",
  "l'utilisation d'un type de destination volatile pour une expression d'affectation composée est dépréciée",
  "l'utilisation d'un paramètre de fonction volatile est dépréciée",
  "l'utilisation d'un type de retour volatile est dépréciée",
  "l'utilisation d'un qualificateur volatile sur une liaison structurée est dépréciée",
  "l'argument 'ext_vector_type' doit être compris entre 1 et 2 047",
  "l'attribut 'ext_vector_type' peut apparaître uniquement dans un typedef",
  "l'attribut 'ext_vector_type' s'applique uniquement aux types entiers ou à virgule flottante",
  "cette macro de test de fonctionnalité est ignorée (et retourne 0) dans le mode de compilation actuel",
  "impossible d'évaluer un initialiseur d'agrégat avec plusieurs éléments pour une union",
  "La sélection de %nd pour la réécriture d'opérateur ne retourne pas le type bool",
  "une expression new qui appelle une fonction d'allocation spécifique à une classe ne peut pas être évaluée en tant que constante",
  "une expression new de placement ne peut pas être évaluée en tant que constante",
  "une suppression via un pointeur de sous-objet nécessite un destructeur virtuel",
  "%npTd, avec des arguments inversés",
  "l'opérande de __INTADDR__ doit être décalé par rapport au pointeur null",
  "La construction _Generic correspond à plusieurs types",
  "l'autre correspondance est %t",
  "l'attribut 'availability' utilisé ici est ignoré",
  "L'instruction de l'initialiseur de style C++20 dans une instruction 'for' basée sur une plage n'est pas standard dans ce mode",
  "co_await peut s'appliquer uniquement à une instruction for basée sur une plage",
  "impossible de déduire le type de la plage dans une boucle 'for' basée sur une plage",
  "les variables inline sont une fonctionnalité C++17",
  "l'opérateur delete de destruction nécessite %t en tant que premier paramètre",
  "un opérateur delete de destruction ne peut pas avoir d'autres paramètres que std::size_t et std::align_val_t",
  "les options de classe abstraite non limitées peuvent uniquement être utilisées durant la compilation en C++",
  "début d'expression non valide dans la clause requires",
  "une expression cast dans une clause requires doit être entre parenthèses",
  "cet opérateur ne peut pas apparaître au niveau supérieur (sans parenthèses) dans une clause requires",
  "la contrainte atomique doit être de type bool",
  "échec de substitution de la contrainte atomique",
  "la contrainte atomique n'est pas une constante",
  "la contrainte atomique a la valeur false",
  "contrainte de modèle non satisfaite",
  "la définition de concept ne peut pas apparaître dans cette étendue",
  "redéclaration non valide de %nd",
  "échec de la substitution des arguments %T pour l'ID de concept",
  "le concept est faux pour les arguments %T",
  "une clause requires n'est pas autorisée ici (il ne s'agit pas d'une fonction basée sur un modèle)",
  "modèle de concept",
  "clause requires incompatible avec %nfd",
  "attribut attendu",
  null,
  "nom de type attendu",
  "un paramètre ellipse n'est pas autorisé dans une expression requires",
  "un paramètre sans nom dans une expression requires n'a aucun effet",
  "nom de concept attendu",
  "un appel à %s apparaissant dans une expression constante produit toujours 'true'",
  "un appel à %s apparaissant dans un contexte consteval produit toujours 'true'",
  "un appel à %s apparaissant dans une fonction non constexpr produit toujours 'false'",
  "échec de la contrainte de type pour %t",
  "l'option 'export' ne peut pas être utilisée dans les modes où les modules C++ sont activés",
  "une déclaration de fragment de module global doit précéder toute autre déclaration",
  "une déclaration de module ne peut être précédée que d'un fragment de module global",
  "un fragment de module privé doit être précédé d'une déclaration de module",
  "un fragment de module %s ne peut pas être exporté",
  "impossible de déclarer plusieurs modules",
  "impossible de déclarer plusieurs fragments de module %s",
  "un module doit être déclaré avec un nom non vide",
  "%sq n'est pas un en-tête importable",
  "impossible d'importer un module sans nom",
  "un module ne peut pas avoir de dépendance d'interface par rapport à lui-même",
  "le module %sq a déjà été importé",
  "fichier de module",
  "fichier de module introuvable pour le module %sq",
  "impossible d'importer le fichier de module %sq",
  "%s1 attendu, %s2 trouvé à la place",
  "à l'ouverture du fichier de module %sq",
  "nom de partition inconnu %sq",
  "fichier de module inconnu",
  "fichier de module d'en-tête importable",
  "fichier de module EDG",
  "fichier de module IFC",
  "fichier de module inattendu",
  "le type du deuxième opérande %t2 doit avoir la même taille que %t1",
  "le type doit pouvoir être copié de façon triviale",
  "le type %t n'est pas pris en charge pour l'évaluation de constexpr de __builtin_bit_cast",
  "les types classe avec des champs de bits %t ne sont pas pris en charge pour l'évaluation de constexpr de __builtin_bit_cast",
  "un membre de données non statique de type référence %t empêche l'évaluation de constexpr de __builtin_bit_cast",
  "un type volatile %t empêche l'évaluation de constexpr de __builtin_bit_cast",
  "un type union, pointeur ou pointeur vers membre %t empêche l'évaluation de constexpr de __builtin_bit_cast",
  "%npTd, hérité via l'utilisation de decl %p",
  "la construction de sous-objet de %t pour l'héritage de constructeurs ne peut pas être effectuée -- le constructeur par défaut implicite est supprimé",
  "%n doit retourner void",
  "début de déclaration de membre non valide",
  "'auto' attendu",
  "cet opérateur n'est pas autorisé à ce stade ; mettez entre parenthèses l'expression new précédente",
  "utilisation non valide du concept",
  "un opérateur de comparaison de membres par défaut ne peut pas être qualifié en tant que '&&'",
  "la fonction de comparaison constexpr par défaut appelle la fonction non constexpr %nd",
  "la comparaison de mémoire constexpr est prise en charge uniquement pour les objets d'entiers ou les objets de tableaux d'entiers",
  "un modèle de concept ne peut pas avoir de contraintes associées",
  "'export' n'est pas autorisé",
  "l'exportation de membres de classe individuels n'est pas autorisée",
  "une déclaration exportée doit introduire un nom",
  "une déclaration export ne peut pas contenir de déclaration export (déclaration précédente %p)",
  "une déclaration export ne peut pas contenir de déclaration import de module",
  "une déclaration export ne peut apparaître que dans une unité d'interface de module",
  "une déclaration export ne peut pas exporter un nom avec une liaison interne",
  "la déclaration using inclut %nfd",
  "la fonction intégrée n'est pas disponible, car les types à virgule flottante __fp16 ne sont pas pris en charge",
  "une expression requires doit spécifier au moins une exigence",
  "'constinit' est non valide ici",
  "'constinit' est valide uniquement pour les déclarations de variables ayant une durée de stockage statique ou de thread",
  "la variable constinit nécessite une initialisation dynamique",
  "la variable a été déclarée avec 'constinit' %p",
  "utilisation d'un déclarateur de fonction non-prototype",
  "l'argument ne peut pas avoir un type qualifié const",
  "un pointeur vers membre de type incomplet %t n'est pas autorisé",
  "l'expansion de pack dans init-capture n'est pas activée dans ce mode",
  "l'expansion de pack dans init-capture est une fonctionnalité C++20",
  "un opérateur de comparaison par défaut dans une définition de classe doit être la première déclaration de cet opérateur de comparaison (%nd)",
  "une expansion de pack dans une capture d'initialisation peut uniquement être utilisée dans un modèle variadique",
  "la contrainte de type utilise %nd qui n'est pas un concept de type (c'est-à-dire un modèle de concept dont le premier paramètre est un paramètre de type)",
  "échec de la contrainte de type pour le type d'espace réservé déduit %t",
  "le constructeur par défaut pour %t n'est pas éligible",
  "le destructeur pour %t est ambigu en raison de contraintes non ordonnées",
  "le destructeur pour %t est inéligible en raison de l'échec de contraintes",
  "candidat destructeur ambigu",
  "une fonction virtuelle ne peut pas avoir de clause requires de fin",
  "%nd ne respecte pas ses contraintes",
  "le résultat du qualificateur decltype %t n'est pas une classe ou une énumération",
  "la comparaison est ambiguë dans la norme C++20, car l'opérateur de comparaison implicite avec des paramètres inversés représente une correspondance tout aussi appropriée (cela est généralement dû à un qualificateur 'const' manquant sur l'opérateur de comparaison) ; consultez %nod",
  "ID de concept non valide",
  "échec de la substitution des arguments %T pour la clause requires",
  "les contraintes pour %nd ne sont pas satisfaites",
  "le type de variable %t dans la fonction constexpr a des classes de base virtuelles",
  "une expression constante ne peut pas allouer un sous-objet de base virtuel (pour le type %t)",
  "un paramètre de modèle de type classe doit être de type classe structurelle",
  "la prise en charge des littéraux UTF-8 nécessite une prise en charge du littéral u.",
  "mappage de fichier de module pour '%s' spécifié plusieurs fois",
  "mappage d'unité d'en-tête pour '%s' spécifié plusieurs fois",
  "aucun mappage spécifié pour '%s'",
  "le mappage de fichier de module pour '%s' est non valide",
  "l'en-tête '%s' à importer est introuvable",
  "plusieurs fichiers dans la liste de fichiers de module correspondent à '%s'",
  "le fichier de module trouvé pour '%s' est destiné à un autre module",
  "n'importe quel genre de fichier de module",
  "impossible de lire le fichier de module",
  "la fonction intégrée n'est pas disponible, car le type char8_t n'est pas pris en charge avec les options actuelles",
  "l'option de ligne de commande --ms_await ne peut pas être spécifiée si les coroutines C++20 sont activées",
  "utilisation non standard du constructeur explicite %nod pour l'initialisation de l'élément d'agrégation par défaut",
  "la source ou la destination de l'intrinsèque de type memcpy ne pointe pas vers un objet",
  "l'intrinsèque de type memcpy tente de copier les types représentatifs distincts %t1 et %t2",
  "l'intrinsèque de type memcpy tente de copier le type non trivialement copiable %t",
  "l'intrinsèque de type memcpy tente de copier un objet partiel",
  "l'intrinsèque de type memcpy tente de copier au-delà de la limite du tableau",
  "l'intrinsèque de type memcpy tente de copier des plages d'octets qui se chevauchent (en utilisant plutôt l'opération memmove correspondante)",
  "une déclaration friend avec une clause requires de fin doit être une définition",
  "l'expression doit avoir un type arithmétique ou pointeur mais elle a le type %t",
  "l'expression doit avoir un type arithmétique, enum ou pointeur mais elle a le type %t",
  "l'expression doit avoir un type arithmétique, enum non délimité ou pointeur mais elle a le type %t",
  "l'expression doit avoir un type pointeur mais elle a le type %t",
  "opérateur -> ou ->* appliqué à %t au lieu de l'être à un type pointeur",
  "le type classe incomplet %t n'est pas autorisé",
  "impossible d'interpréter la disposition des bits pour cette cible de compilation",
  "aucun opérateur correspondant pour l'opérateur IFC %sq",
  "aucune convention d'appel correspondante pour la convention d'appel IFC %sq",
  "le module %sq contient des constructions non prises en charge",
  "construction IFC non prise en charge : %sq",
  "__is_signed n'est plus un mot clé à partir de ce point",
  "une dimension de tableau doit avoir une valeur d'entier non signé constante",
  "le fichier IFC %sq a une version non prise en charge : %d1.%d2",
  "les modules ne sont pas activés dans ce mode",
  "'import' n'est pas autorisé dans un nom de module",
  "'module' n'est pas autorisé dans un nom de module",
  null,
  null,
  "%n n'est pas un type énumération",
  "l'énumérateur %no2 est en conflit avec %n1",
  "l'énumérateur %no a déjà été déclaré dans cette étendue %p",
  "la spécification 'throw()' ne fait pas partie de C++20 ni des versions ultérieures",
  "plusieurs entrées dans le mappage d'unité d'en-tête correspondent à '%s'",
  "#Le diagnostic pragma doit avoir un argument « push » ou « pop »",
  "Aucun « #pragma diagnostic push » n’a été trouvé en correspondance à ce « diagnostic pop »",
  "%sq ne peut pas être une macro quand il est utilisé dans une directive d’importation ou de module",
  "cette directive ne peut apparaître que dans l’étendue de l’espace de noms global",
  "une déclaration « export » peut apparaître uniquement dans l’étendue globale ou de l’espace de noms",
  "Le %sq est ensuite analysé en tant qu’identificateur plutôt qu’en tant que mot clé, car les jetons qui suivent ne correspondent pas à ceux d’une directive de préprocesseur",
  "cette directive semble être le début d’une directive de préprocesseur, mais l’absence de « ; » suivie immédiatement d’une nouvelle ligne empêche",
  "il s’agit d’une directive de prétraitement de modules, mais une telle directive ne peut pas apparaître dans une extension de macro",
  "une directive « module » ne peut pas apparaître dans le cadre de l’inclusion conditionnelle (par exemple, #if, #else, #elseif, etc.)",
  "l’importation de %sq a été ignorée",
  "le type de promesse %t doit déclarer get_return_object_on_allocation_failure en tant que fonction membre statique ne nécessitant aucun argument",
  "un modèle d'alias ne peut pas être explicitement spécialisé",
  "pour correspondre à ce '{'",
  "dans cette invocation de macro",
  "l'appel nécessite une conversion d'argument ambiguë",
  "la déclaration appartenant au module %s est en conflit avec %nd",
  "la déclaration appartenant au module global est en conflit avec %nd appartenant à un module nommé",
  "le premier argument d'un attribut 'malloc' doit être une fonction",
  "impossible de capturer %nod",
  "impossible de capturer 'this'",
  "déjà dans un contexte consteval",
  "« if consteval » et « if not consteval » nécessitent des instructions dépendantes resserrés",
  "« if consteval » et « if not consteval » ne sont pas valides dans une fonction non constexpr",
  "le transfert de contrôle dans une instruction « if consteval » ou « if not consteval » n’est pas autorisé",
  "l’évaluation constante ne peut pas passer par la déclaration d’une variable avec une durée de stockage statique ou de thread",
  "le qualificateur mutable n’est pas autorisé sur une expression lambda avec un paramètre « this » explicite",
  "une fonction membre déclarée avec « static » ne peut pas avoir de paramètre « this » explicite",
  "un paramètre « this » explicite doit être le premier paramètre déclaré",
  "« this » n’est pas autorisé ici",
  "une fonction de comparaison avec « this » explicite ne peut pas être par défaut",
  "une fonction « this » explicite nécessite un opérande de sélecteur",
  "« if consteval » et « if not consteval » ne sont pas standard dans ce mode",
  "l’omission de « () » dans un déclarateur lambda n’est pas standard dans ce mode",
  "une clause requires de fin n’est pas autorisée lorsque la liste de paramètres lambda est omise",
  "module %sq partition non valide demandée",
  "module %sq1 partition non définie (on pense qu’il s’agirait de %sq2) demandée",
  "module %sq1 position de fichier %d1 (position relative %d2) demandée pour la partition %sq2, qui est vide",
  "module %sq1 position de fichier %d1 (position relative %d2) demandée pour la partition %sq2, qui précède le début de la partition",
  "module %sq1 position de fichier %d1 (position relative %d2) demandée pour la partition %sq2, qui dépasse la fin de sa partition",
  "module %sq1 position de fichier %d1 (position relative %d2) demandée pour la partition %sq2, qui est mal alignée avec ses éléments de partitions",
  "à partir du sous-champ %sq (position relative par rapport au nœud %d)",
  "à partir de la partition %sq, élément %d1 (position de fichier %d2, position relative %d3)",
  "les attributs lambda ne sont pas standard ici",
  "l’identificateur %sq peut être confondu avec un identificateur visuellement similaire qui apparaît %p",
  "ce commentaire contient des caractères de contrôle de mise en forme Unicode suspects",
  "cette chaîne contient des caractères de contrôle de mise en forme Unicode qui peuvent entraîner un comportement d’exécution inattendu",
  "%d1 avertissement supprimé rencontré lors du traitement du module %sq1",
  "%d1 avertissements supprimés rencontrés lors du traitement du module %sq1",
  "%d1 erreur supprimé rencontré lors du traitement du module %sq1",
  "%d1 erreurs supprimées rencontrées lors du traitement du module %sq1",
  "Y compris",
  "Supprimé",
  "une fonction membre virtuelle ne peut pas avoir un paramètre « this » explicite",
  "la prise de l’adresse d’une fonction « this » explicite nécessite un nom qualifié",
  "la création de l’adresse d’une fonction « this » explicite nécessite l’opérateur '&'",
  "impossible d’utiliser un littéral de chaîne pour initialiser un membre de tableau flexible",
  "La représentation IFC de la définition de la fonction %sq n’est pas valide.",
  "une correction a été apportée pour supprimer « ce » paramètre implicite.",
  "un graphique IFC UniLevel n’a pas été utilisé pour spécifier des paramètres.",
  "%d1 paramètre a été spécifié par le graphique de définition de paramètres IFC alors que %d2 paramètres ont été spécifiés par la déclaration IFC.",
  "%d1 paramètre a été spécifié par le graphique de définition de paramètres IFC alors que %d2 paramètres ont été spécifiés par la déclaration IFC.",
  "%d1 paramètre a été spécifié par le graphique de définition de paramètres IFC alors que %d2 paramètres ont été spécifiés par la déclaration IFC.",
  "La représentation IFC de la définition de la fonction %sq est manquante.",
  "Le modificateur de fonction ne s'applique pas à la déclaration du modèle de membre.",
  "la sélection de membre implique un trop grand nombre de types anonymes imbriqués",
  "il n’existe aucun type commun entre les opérandes",
  "pointeur vers membre attendu",
  "un membre de tableau flexible ne peut pas être déclaré dans un type autrement vide.",
  "expected 'std::source_location::__impl' to be defined to a class with only the data members '_M_function_name', '_M_file_name', '_M_column', '_M_line'",
  "lors de l’initialisation de 'std::source_location::__impl', le numéro de colonne dépasse le membre '_M_column' de type %t",
  "lors de l’initialisation de 'std::source_location::__impl', le numéro de ligne dépasse le membre '_M_line' de type %t",
  "une constante de caractères UTF-16 ne peut pas occuper plusieurs unités de code ; valeur tronquée",
  "les deux arguments doivent avoir le même type",
  "le type %t n’est pas valide en tant qu’argument pour ce builtin",
  "appelé à partir de %nd :",
  "un type qualifié n’est pas standard pour les champs de bits anonymes.",
  "le type d’élément de la condition vectorielle (%t1) doit avoir la même taille que le type d’élément du résultat (%t2).",
  "le type d’opérande vectoriel à virgule flottante (%t) n’a pas de type de vecteur entier correspondant.",
  "La gestion des expressions \"requires\" n'est pas encore implémentée.",
  "en raison d’un attribut 'unavailable'",
  "a tenté de construire un élément à partir d’une partition IFC %sq à l’aide d’un index dans la partition IFC %sq.",
  "le %sq de partition a spécifié sa taille d’entrée %d1 alors que %d2 était attendu.",
  "une exigence IFC inattendue s’est produite lors du traitement du module %sq1.",
  "échec de la condition à la ligne %d dans %s1 : %sq2",
  "la contrainte atomique dépend d’elle-même.",
  "La fonction 'noreturn' a un type de retour non vide",
  "une correction a été effectuée en supprimant le paramètre %sq (au %d d’index relatif)",
  "nom d’identificateur IFC non valide %sq rencontré lors de la reconstruction de l’entité",
  "identificateur IFC non valide nommé %sq ignoré lors de la reconstruction de l’entité",
  "le module %sq valeur de tri non valide",
  "un modèle de fonction chargé à partir d’un module IFC a été analysé de manière incorrecte en tant que %nd",
  "échec du chargement d’une référence d’entité IFC dans le module %sq",
  "Tri d’index IFC = %d1, valeur = %d2"
]