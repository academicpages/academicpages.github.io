---
title: "[WAFFLE] 04-3 SQLAlchemy"
date: 2024-10-05
permalink: /study/2024-10-05-waffle-4-3
categories: Waffle
tags:
  - SQLAlchemy
---

In this post, concepts of SQLAlchemy will be provided.

# SQLAlchemy
과제에서 사용한 io는 db와 소통한 SQLAlchemy 밖에 없다. SQLAlchemy 내부에는 비동기 API도 있는데 이를 사용해야 제대로 FastAPI를 활용할 수 있다. 

```python
from typing import Any, Generator
from sqlalchemy import create_engine
from sqlalchemy.orm import Session, sessionmaker

from database.coomon import Base

class DatabaseManager:
    def __init__(self):
        # TODO pool 이 뭘까요?
        # pool_recycle 은 뭐고 왜 28000으로 설정해두었을까요?
        self.engine = create_engine(
            DB_SETTINGS.url,
            pool_recycle=28000,
            pool_pre_ping=True,
        )
        self.session_factory = sessionmaker(bind=self.engine, expire_on_commit=False)

def get_db_session() -> Generator[Session, Any, None]:
    session = DatabaseManager().session_factory()
    try:
        yield session
        session.commit()
    except Exception as e:
        session.rollback()
        raise e
    finally:
        session.close()
```
SQLAlchemy는 가장 로우 레벨에서는 engine이 있고 connection이 있음
engine은 어떤 db와 연결하기 위한 연결정보를 저장하는 곳. 그 연결정보를 바탕으로 connection을 만들어낼 수 있는 것.
여러개의 db와 연결하려면 여러 개의 engine 사용.
engine을 만들고 그 engine을 이용해서 sessionmaker를 만듦. session_factory에 이를 저장해두고 get_db_session에서 활용.


```python
class UserStore:
    def __init__(self, session: Annotated[Session, Depends(get_db_session)]) -> None:
        self.session = session
```
여기서 sesion을 종속성으로 주입받음. get_db_session을 여기서 호출됨.

종속성으로 session이 필요할 때 get_db_session을 호출해서 session_factory로 session을 만들고 그걸 yield를 하고 요청에 대한 응답이 반환이 되면 그 뒤에 코드가 실행이 되면서 롤백이나 세션 클로스가 실행됨.
종속성 방식의 장점은 하나의 세션을 여러 개 요청이 공유하게 되면 동시성 문제가 발생함. 각각의 요청은 고유한 세션을 받아야함. 그런 관점에서 종속성으로 세션을 관리하면 알아서 매번 세션을 만들어주고 관리해주므로 문제 없음. 그러나 동기 세션이기 때문에 비동기 함수 내부에서 호출하게 되면 이벤트 루프 전체가 블락 되는 상황이 발생함. 그래서 이부분을 비동기 api로 바꿔야 함.


```python
from typing import Any, Generator
from sqlalchemy import create_engine
from sqlalchemy.orm import Session, sessionmaker
from sqlalchemy.ext.asynicio import AsyncSession, async_session_maker, create_async_engine

from database.coomon import Base

class DatabaseManager:
    def __init__(self):
        # TODO pool 이 뭘까요?
        # pool_recycle 은 뭐고 왜 28000으로 설정해두었을까요?
        self.engine = create_async_engine(
            DB_SETTINGS.url,
            pool_recycle=28000,
            pool_pre_ping=True,
        )
        self.session_factory = async_sessionmaker(bind=self.engine, expire_on_commit=False)

async def get_db_session() -> AsyncGenerator[AsyncSession, Any, None]:
    session = DatabaseManager().session_factory()
    try:
        yield session
        await session.commit()
    except Exception as e:
        await session.rollback()
        raise e
    finally:
        await session.close()
```
1. from sqlalchemy.ext.asynicio import AsyncSession, async_session_maker, create_async_engine 추가.
2. 일반 engine을 async로 바꿈, sesion_maker도 async로 바꿈.
3. get_db_session도 수정.
4. Store, service, views 도 변경.
```python
class UserStore:
    def __init__(self, session: Annotated[AsyncSession, Depends(get_db_session)]) -> None:
        self.session = session

    async def get_user_by_username(self, username: str) -> User | None:
        return await self.session.scalar(select(User).where(User.username == username))
```


