---
title: "[CS50] 06 Data Structures"
date: 2024-04-17
permalink: /study/2024-04-17-cs50-6
categories: basic
tags:
  - data structures
---

In this post, the sixth lecture of CS50 is summarized.

# Resizing Arrays
Assume that we defined an array of integer with size 3(12 bytes). Suppose now we want to add a fourth number to the array. Since we don't know what's going on the computer's memory right next to the array we defined(just by bad luck, string "hello, wrold\0" could be allocated right next to the array), we can't simply add the fourth integer right next to it.  
!!! pic of 123 hello world garbange values.!!!
One solution for this problem is to abstract the array and move to a different location of bigger memory. 
```c
int list[3];

list[0] = 1;
list[1] = 2;
list[2] = 3;
```
Now, I want to copy the 'list' array to new array with size 4 and remove the old one. In order to do this, I can't use an traditional array syntax to define 'list' because that makes the variable, forever of size 3 and can't free it. Instead, we will use mallic.
```c
int *list = malloc(3 * sizeof(int));
if (list == NULL){
  return 1;
}

list[0] = 1;
list[1] = 2;
list[2] = 3;
```
In extreme cases malloc can return not the address of an actual chunk of memory. In cases of error, it will return NULL which represents address 0. It's a good practice to check whether malloc returns NULL.
We can still use the bracket when assigning the values because 'list' is still a chunk of memory. We can treat this chunk of memory as though it's an array(think about pointer arithmetic in last week).
Now, this code here does not need to change because list is now still a chunk of memory of size 12, I can actually get away with still using square bracket notation and treating this chunk of memory as though it's an array. And this is a bit subtle. But recall from last time, we talked briefly about pointer arithmetic, whereby the computer can do some arithmetic, some addition, subtraction on the actual addresses to get from one location to the other. And that's what the computer is going to do here. Because it says list bracket 0, that's essentially just going to put the number 1 literally at the beginning of that chunk of memory. And because this is a modern computer, it's going to take four bytes in total. But I don't want to put the number 4 here to shift it over myself. Because I'm using square brackets and because the computer knows that this chunk of memory is being treated as a chunk of addresses of integers, pointer arithmetic magically kicks in. So what the computer is going to do for me is put this 1 at location 0. It's going to put this number 2 at location 1 times size of int, so 4. And it's going to put this number 3 at location 2 times size of int, which gives me 8. So in other words, you don't have to think about how big that chunk of memory is if you already gave the compiler a clue as to the size. 
Now let's assume in this moment I want to dynamically allocate more space and free up the old.
```c
int *list = malloc(3 * sizeof(int));
if (list == NULL){
  return 1;
}

list[0] = 1;
list[1] = 2;
list[2] = 3;

int *tmp = malloc(4 * sizeof(int));
if (tmp == NULL){
  free(list);
  return 1;
}

for (int i = 0; i < 3; i++){
  tmp[i] = list[i];
}
tmp[3] = 4;

free(list);
list = tmp;

for (int i = 0; i < 4; i++){
  printf("%i\n", list[i]);
}

free(list);
return 0;
```
In the line where I defined 'tmp', the computer gives you space for 4 integers elsewhere that might very well be grabage values now. 
I should not forget to free up 'list' when 'tmp' equals to NULL because otherwise, memory leak will occur. This is where C does get a little annoying because the programmer have to remember all of these details. Although technically when any progam quits, all of the memory is going to be given back to the operating system, but still it's a good practice.
Then, we copy each value which takes $$O(n)$$ time complexity.
It's a lot of work to do. Ideally, we would not do this in the first place. Instead, maybe we should allocate more memory from the get go, for instance, allocate an array of size 1000. But this solution also remains issues. You can waste large amount of memory if you only deal with a few numbers. Also, we can still run into the exact same problem because if I want to put 1001 numbers in the list. Linked List would be a nice solution.

# Linked List
Instead of using contiguous chunk of memory, linked list connect values that are stored in seperate memory location using pointers. In this process, larger amount of memory is used to save time by avoiding stupid copying of data from one place to another. There is always a trade of between time and space. 
!!! linked list pic!!!
Inside of each of these nodes is two values, the actual number(data) we care about and then a pointer(metadata). Metadata is distince from data in taht I don't fundamentally care about the metadata. It's an implementation detail. But it does help me ornaize my actual data. In the picture we can see each node stores the address of next element. The last node stores 0x0, which is NULL.
The store linked list will generally use one more value. If I declare a variable that points to the first node, I can implement a linked list as a picture below.
!!! linked list pictogram!!!
```c
typedef struct{
  int number;
  node *next;
} node;
```
In order to implement node, you might be inclined to write 'node *next;'. However, the word 'node' does not exist until you get to this last line of code. Here is the simple fix for this code.
```c
typedef struct node{
  int number;
  struct node *next;
} node;
```
Since C code is read from top to bottom, if you give this structure a name called 'struct node', you can refer to it inside of the bracket. It's annoying to write 'struct node' everywhere in your code so this last line now gives you a synonym. It shortens 'struct node' to just 'node'.
## initialize
```c
node *list = NULL;
```
!!! list pic!!!
Instead of just declaring 'node *list;', which will lead 'list' to store a garbage value, we can initialize it to NULL.
## memory allocation
```c
node *n = malloc(sizeof(node));
```
!!! list pic!!!
## assign value
```c
(*n).number = 1;
(*n).next = NULL;
```
The syntax is cryptic. The below is a code that you can synonymously use instead.
```c
n->number = 1;
n->next = NULL:

list = n;
```
'n' is a pointer and '->' means 'go there'. Exactly same thing as '(*n)'. The last line means 'whatever address is in 'n', put it to 'list'. Pictorially what that menas is, temporarily point both pointers to the same exact place. Why? Because 'list' is that I care about long term. This may be my global variable that I'm goint to keep around forever in my computer's memory. 'n' is just a temporary pointer so that I could get a chunk of memory and go to its locations and update it with those values. Eventually, it is probably goint to go away. 
!!! list pic !!!
## 
