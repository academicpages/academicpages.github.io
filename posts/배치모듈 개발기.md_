---
title: 배치모듈 개발기
format: list
feed: show
date: 13-10-2023
---
오리는 아이스 아메리카노 한 잔을 손에 들고 사무실에 앉았어요. <br>
23년 여름 오리는 회사 서비스의 <br>
백오피스 및 배치 모듈 개발을 담당하게 됐어요. <br>

서비스를 운영 및 관리하면서 <br>
프로세스는 나름 잘 알게 되었다고 자신하며 프로젝트를 시작한 오리 <br>
배치모듈 개발 요구사항을 듣고 **충격**을 받았어요.

> 서비스는 **[A,B,C,D]** 4가지로 이루어져 있고, 데이터는 하루에는 대략 30 ~ 50만 건이 쌓인다고 해요.

>  아래는 프로젝트 시작 전 전달받았던 요구사항이에요.
>1. 데이터를 [10분, 일별, 월별] 단위로 나누어 처리해야 해요.
>2. 다중화된 서버 환경에서의 데이터 처리를 고려해야 해요.
>3. 30분 이전의 데이터를 통계 내어야 해요
>4. 결과 통계가 명확해야 해요.


### 데이터 동기화와 쿼리 최적화

오리는 어떻게 배치모듈을 개발 해야할 지 생각했어요.<br>
"4개의 서비스의 사용 건수를 10분 단위로 집계하고<br>
10분 단위로 집계된 데이터를 다시 일별로 집계하고<br>
마찬가지로 월별도 일별을 집계하는 방식으로 가면 되겠구나!!"<br>

오리는 자신이 무친 천재가 아닐까 생각했어요. <br>

먼저 오리는 <br>
실시간으로 대량의 데이터가 쌓이는 상황에서, <br> 
여러 테이블과 데이터베이스 간의 효율적인 데이터 처리 방안을 고려하게 됐어요.

[//]: # (오리는 서비스별로 쌓이는 데이터를 하나로 합칠 필요가 있었어요.<br>
[//]: # (10분 단위, 하루 단위, 한 달 단위로 통계 테이블을 각각 생성하고, 관리해야 했어요.<br>)

> 오리가 떠올린 고려사항과 방법은 다음과 같아요.<br>
> A. 데이터의 일관성과 정확성을 유지하면서 빠른 처리가 가능한 DB 쿼리 최적화 방안<br>
> B. 다중화된 서버 환경에서 데이터 처리 작업의 분산 처리<br>
> C. 코드를 알아보기 쉽고 유지보수하기 편하게 만들자

오리는 데이터의 일관성과 처리 속도를 동시에 고려하기 위해 <br>
조회와 삽입 작업을 동시에 수행하는 쿼리를 작성하기로 했어요.

``` sql
INSERT INTO 테이블
(X_DATE, A_ID, B_ID, C_ID, D_TYPE, E_CNT, F_CNT, G_CNT, H_CNT, I_DATE)
SELECT '현재시간' AS X_DATE
     , A_ID
     , B_ID
     , C_ID
     , '지정된타입' AS D_TYPE
     , COUNT(E_TX_ID) AS E_CNT
     , COUNT(
          CASE            
          WHEN F_TYPE = 'fTypeA' AND G_CODE IN ('1234')
                  OR F_TYPE = 'fTypeB'
                  OR F_TYPE = 'fTypeC'
                  THEN 1
              END
       ) AS F_CNT
     , COUNT(
          CASE            
          WHEN F_TYPE = 'fTypeC' AND G_CODE IN ('1234')
                  OR F_TYPE = 'fTypeB' AND G_CODE IN ('1234')
                  THEN 1
              END
       ) AS G_CNT
     , '시간 변수' AS I_DATE
FROM LMNOP_TBL
WHERE 1 = 1
  AND I_DATE >= '조회시간'
  AND I_DATE < '조회시간'
GROUP BY B_ID, C_ID, A_ID

```

조회와 삽입을 하나의 쿼리에서 진행하다보니 쿼리 최적화가 필요했고,<br>
DB 인덱싱을 통해 오랜시간 DB를 점유하는 것을 최소화 시켰어요.

#### 조회와 삽입을 분리하여 사용하는 방법의 장단점  
> **장점**:
> 1. **명확한 로직 분리와 확장성**: 조회와 삽입 로직이 분리되어 있기 때문에 각 기능별로 코드를 사용할 수 있고, 활용해서 사용할 수 있어요.
> 2. **유연한 유지보수**: 한 쪽의 로직만 변경해야 할 경우, 다른 쪽에 영향을 미치지 않아 유지보수가 편리해요.
> 3. **오류 예방**: 삽입과 조회 중 하나에서 오류가 발생하더라도 다른 로직에는 영향을 미치지 않아요.
>
>**단점**:
>1. **통신 횟수 증가**: 조회와 삽입이 따로 이루어지기 때문에, 데이터베이스와의 통신 횟수가 증가해요. 이로 인해 전체적인 처리 시간이 길어질 수 있어요.
>2. **트랜잭션 관리 어려움**: 조회 후 삽입이 이루어져야 하는 상황에서는 트랜잭션 관리가 복잡해질 수 있어요.
>3. **일관성 유지의 어려움**: 조회와 삽입이 따로 이루어질 경우, 조회 후에 데이터 상태가 변경될 가능성이 있어, 삽입 시점의 데이터 일관성 유지가 어려울 수 있어요.
>4. **복잡한 예외 처리**: 조회와 삽입 작업이 따로 이루어지면, 각각의 작업에서 발생할 수 있는 예외 상황을 따로 처리해야해요.
>5. **리소스 비효율**: 두 개의 쿼리를 실행하기 때문에, 리소스 사용량이 증가하며, 이로 인해 전반적인 시스템 퍼포먼스가 저하될 수 있어요.

#### 조회와 삽입을 동시에 사용하는 쿼리의 장단점
>**장점**:
>1. **통신 횟수 감소**: 단 한 번의 쿼리로 두 가지 작업을 처리할 수 있기 때문에, DB와의 통신 횟수를 줄일 수 있습니다.
>2. **일관성 보장**: 조회와 삽입이 동시에 이루어지므로, 데이터의 일관성을 보장할 수 있습니다.
>3. **트랜잭션 관리의 간소화**: 하나의 쿼리에서 처리되기 때문에 트랜잭션 관리가 더욱 간편해집니다.
>
**단점**:
>
>1. **로직 복잡성**: 조회와 삽입을 동시에 처리하는 쿼리는 로직이 복잡해질 수 있으며, 이로 인해 유지보수가 어려워질 수 있습니다.
>2. **오류 예방의 어려움**: 쿼리에 오류가 발생하면, 조회와 삽입 둘 다에 문제가 생길 수 있습니다. 이 경우, 오류의 원인 파악이 복잡해질 수 있습니다.
>3. **튜닝의 어려움**: 동시에 수행하는 쿼리는 최적화하기가 더 어려울 수 있습니다.


그리고 오리는 다중화된 서버 환경에서 <br>
자신이 만든 모듈을 배포하게 된다고하니 생각이 많아졌어요.<br>
(데이터가 삽입되는도중 데드락이 걸리면안돼..nn)<br>

'그럼 순차적인 동기처리를 하면되겠다!' 라고 오리는 생각했어요.

오리는 데이터의 순차적인 삽입 처리를 위해 DB lock 테이블을 생성해요.<br>

```sql
CREATE TABLE `STAT_UPDATE_LOCK` (
  `STAT_TYPE` varchar(10) NOT NULL COMMENT '배치 종류. 서비스명 + MIN,DAY,MONTH : 분,일,월',
  `LOCK_YN` char(1) NOT NULL COMMENT '잠금 여부. (Y : 사용, N :  미사용)',
  `LAST_UPDATE` timestamp NULL DEFAULT NULL COMMENT '마지막 업데이트 시간',
  PRIMARY KEY (`STAT_TYPE`)
) 
```

#### DB lock 테이블을 사용한 스케줄링 로직 관리
오리는 데이터베이스에 해당 타겟 메서드가 실행되었을 때 <br>
시간과 실행된 서비스 이름, 잠금여부를<br>
DB lock 테이블에 저장하여 관리하기로해요.<br>
> 이렇게 하면 동시에 같은 데이터를 수정하려는 다른 요청이나<br>
스케쥴러 작업을 효과적으로 방지할 수 있어요.<br>


이제 오리가 만든 배치모듈을 테스트하기위해<br>
한달치 평균 mock data를 생성해서<br>
배치모듈을 서버에서 실행시켜봤어요.

그런데 !! <br>
통계 데이터 처리하는 과정에서 여러 문제를 발견하게 되었어요.<br>

대량의 오류 코드를 찍고있던 배치모듈을 정지시키고 나서 생각했어요.<br>

오리의 배치모듈 오류들을 분석하는데 <br>
모든 Exception을 롤백시켜주지 않는 다는 것을 알게되었어요. <br>

"메서드에 `@Transactional`이 붙어있으면 <br> 
삽입 또는 업데이트를 진행하는 도중 Exception이 발생하면 <br>
전부 롤백시켜주는거 아닌가?" 라고 생각하고 만들었던 오리는 <br>
`@Transactional`에대해 공부해보기로 합니다.

> 사용 건수가 특정 수를 초과하면 'UsageLimitExceededException' 이라는 <br>
> 사용자 정의 Exception을 발생시켰습니다. <br>
> 해당 예외는 관리자에게 알림을 보내는 등 특별한 처리가 필요하여 사용하였는데
> 사용자정의 Exception은 롤백이 되지 않더라구요..ㅎㅎ;

### `@Transactional`을 알아보고 조금 더 활용해보자

오리는 데이터의 안정성과 정확성을 위해, `@Transactional` 어노테이션의 활용을 알아보기로요.<br>

`@Transactional` 트랜잭션이란 ?<br>
트랜잭션은 단일 작업 단위로 실행되는 하나 이상의 작업 시퀀스입니다.<br>
트랜잭션의 주요 목적은 **데이터 무결성**과 **데이터 일관성**을 보장하는 것입니다.<br>
우리가 알고있는 데이터베이스 시스템에서의 트랜잭션은 일반적으로 Select, Update, Insert, Delete와 같은 작업들 입니다.<br>

트랜잭션이 완료되려면 우리가 알고있는 ACID 속성을 충족해야합니다.<br>

원자성 : 이는 트랜잭션의 모든 작업이 성공적으로 완료되거나 전혀 완료되지 않음을 의미합니다.<br>
하나의 작업이 실패하면 전체 트랜잭션이 롤백되고 변경 사항이 적용되지 않습니다.<br>

일관성 : 데이터베이스는 모든 트랜잭션 이후에도 일관된 상태를 유지해야 합니다.<br>
어떤 트랜잭션도 데이터베이스에 있는 데이터에 부정적인 영향을 미쳐서는 안 됩니다.<br>
트랜잭션 실행 전에 데이터베이스가 일관된 상태였다면 트랜잭션 실행 후에도 일관된 상태를 유지해야 합니다.<br>
> 예를 들어, 한 계좌에서 다른 계좌로 자금을 이체하는 애플리케이션에서 일관성 속성은 각 거래의 시작과 종료 시점에 두 계좌의 총 자금 가치가 동일하도록 보장합니다.

격리성 : 각 트랜잭션은 다른 트랜잭션과 격리되어 실행되므로 트랜잭션이 완료될 때까지 한 트랜잭션의 작업이 다른 트랜잭션에서 숨겨집니다.
>여기서 숨겨진다는 의미는 다른트랜잭션에서 해당 트랜잭션의 중간상태를 보지 못하게 하는 것입니다.

내구성(영속성) : 트랜잭션이 완료되면 그 효과는 영구적이며, 이후의 시스템 장애에도 변경 사항이 유지됩니다.
>내구성은 트랜잭션이 성공적으로 완료된 후 그 결과가 영구적으로 저장되어야 한다는 원칙을 의미합니다. 즉, 트랜잭션이 커밋(commit)된 이후에는 시스템 장애, 전원 문제, 하드웨어 고장 등 어떠한 상황에서도 해당 트랜잭션에 의한 변경사항이 손실되어서는 안 됩니다.


`@Transactional` 은 주로 데이터베이스 트랜잭션 관리에 사용되는 어노테이션입니다.<br>
주로 Spring Framework와 JPA(Java Persistence API)에서 사용됩니다.

### `@Transactional` 을 사용함으로써 얻을 수 있는 것
1. 코드의 간결성: 트랜잭션의 시작, 커밋, 롤백 등의 관리를 수동으로 할 필요가 없습니다.
2. 일관성: 애플리케이션 전체에서 일관된 트랜잭션 관리 방식을 사용할 수 있습니다.
3. 유연성: 다양한 트랜잭션 설정과 옵션을 쉽게 적용할 수 있습니다.


#### `@Transactional` 어노테이션을 사용함으로써 Spring 프레임워크에서 제공하는 주요 트랜잭션 관리 기능
1.&nbsp;**선언적 트랜잭션 관리**: `@Transactional`은 선언적 트랜잭션 관리를 제공해줍니다. 이는 코드의 가독성을 향상시키고, 오류 가능성을 줄이며, 트랜잭션 관련 코드의 중복을 최소화합니다.

2.&nbsp;**롤백 규칙**: 기본적으로 런타임 예외가 발생하면 트랜잭션은 롤백됩니다.<br>

3.&nbsp;**격리 수준 설정**: 데이터베이스에서 동시에 여러 트랜잭션이 실행될 때 발생할 수 있는 문제를 방지하기 위해 트랜잭션의 격리 수준을 설정할 수 있습니다.

4.&nbsp;**전파 동작**: `propagation` 속성을 사용하여 트랜잭션의 전파 방식을 설정할 수 있습니다.
   예를 들면, 이미 트랜잭션이 진행중일 떄 기존 트랜잭션에 합류할지, 새로운 트랜잭션을 시작할지 등의 동작을 결정합니다.

5.&nbsp;**읽기 전용 트랜잭션**: `readOnly` 속성을 사용하여 트랜잭션을 읽기 전용으로 설정할 수 있습니다. 이는 성능 최적화에 도움이 될 수 있습니다.

6.&nbsp;**타임아웃 설정**: 트랜잭션이 너무 오랜 시간 동안 실행되는 것을 방지하기 위해 `timeout` 속성을 사용하여 타임아웃을 설정할 수 있습니다.

7.&nbsp;**프록시 기반 접근**: Spring은 `@Transactional`이 적용된 메서드를 호출할 때 내부적으로 프록시를 사용하여 트랜잭션을 관리합니다.<br>
   따라서 동일한 클래스 내부에서의 메서드 호출은 프록시를 우회하게 되어 트랜잭션이 적용되지 않는 점을 유의해야 합니다.


@Transactional 어노테이션은 트랜잭션 경계를 선언적으로 정의하는 방법을 제공하므로<br> 
개발자는 트랜잭션 관리의 복잡성을 프레임워크에 맡기고 비즈니스 로직에 집중할 수 있도록 합니다.


### 롤백 처리
`@Transactional` 어노테이션은 데이터의 일관성을 보장하기 위해 예외 발생 시 트랜잭션을 롤백하는 기능을 제공해요.<br>
하지만!!  모든 예외가 데이터의 일관성을 위협하지 않기 때문에, 스프링은 특정 예외에 대해서만 기본적으로 롤백을 수행한다고 해요.<br>
1.&nbsp;**기본 롤백 규칙**:
   스프링의 `@Transactional`에서는 런타임 예외(`RuntimeException`)와 `Error`가 발생했을 때 기본적으로 롤백을 수행합니다. 반면, 체크 예외(`checked exceptions`)는 롤백 대상에서 제외됩니다. 이는 체크 예외가 일반적으로 복구 가능한 예외로 간주되기 때문입니다.

2.&nbsp;**롤백 설정의 커스터마이징**:
   `@Transactional` 어노테이션의 `rollbackFor` 속성을 사용하여 롤백을 수행할 예외를 명시적으로 지정할 수 있습니다. 또한, `noRollbackFor` 속성을 사용하여 롤백을 하지 않을 예외를 지정할 수도 있습니다.

```java
@Transactional(rollbackFor = CustomException.class)
```

3. **프로그래밍적 롤백**:
   때로는 코드 내에서 조건에 따라 롤백을 수행해야 할 경우가 있습니다. 이럴 때는 `TransactionAspectSupport`의 `currentTransactionStatus().setRollbackOnly()` 메서드를 호출하여 프로그래밍적으로 롤백을 수행할 수 있습니다.

```java

@Service  
public class MyService {  
  
    @Transactional  
    public void myTransactionalMethod() {  
        try {  
            // 어떤 조건에 따라 롤백을 수행하고 싶을 때  
            if (someCondition()) {  
                // 프로그래밍적으로 롤백 수행  
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();  
                return;  
            }  
  
            // ... 다른 비즈니스 로직 ...  
        } catch (SpecificException1 e1) {  
            // 특정 예외에 대한 처리 로직  
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();  
        } catch (SpecificException4 e2) {  
            // 롤백을 수행하지 않는 예외 처리 로직  
        } catch (Exception e) {  
            // 그 외의 예외에 대한 처리 로직  
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();  
        }  
    }  
  
    private boolean someCondition() {  
        // 임의의 조건  
        return true;  
    }  
}


```

오리는 롤백 처리하는 다양한 방법에 대해 공부해보고 예외 상황에서도 데이터의 일관성과 안정성을 유지할 수 있는 방법을 배웠습니다.

---  

이를 바탕으로 동시성 관리 전략을 효과적으로 적용하면, 데이터의 안정성과 처리 속도를 동시에 달성할 수 있게 되었어요.

**이번 프로젝트는 혼자서 프로젝트를 진행하며 다양한 기술과 환경을 접하게 되었는데, 다양한 기술이 있더라도 그 중에서도 본인에게 꼭 필요한 기술인지 고민하여 적용하는 것**이 중요하다는 깨달음을 얻었습니다. 😊
