---
title: 'Transactional Boosting: A Methodology for Highly-Concurrent Transactional Objects'
date: 2022-04-24
permalink: /posts/2022/04/transactional_boosting/
tags:
  - Transactions
  - Transactional Boosting
  - Non-Blocking algorithms
  - Abstract locks
  - Transactional memory
  - Commutativity
---

Software transactional memory (STM) is an emergent alternative to mutual exclusion. In STM, the activities are organised as transactions which can commit or abort. Most transactional memory systems synchronise on the basis of read/write conflicts. Two transactions are said to be in conflict if they modify at-least one same object. When conflicting transactions need to commit, we need some mechanism to resolve this conflict. This can be done by forcing either transaction to abort. The benefit of this type of conflict detection and resolution is that the overhead of managing conflicts does not fall to the programmer. But at the same time, this method also severely restricts the concurrency for shared objects which come under contention very often. 

The [paper](https://dl.acm.org/doi/10.1145/1345206.1345237) presents a methodology for transforming a large class of highly linearizable objects into highly-concurrent objects. Transactional boosting considers each object to be a black box. Only a specification, specifying the objects state and the methods that affect it, are required to successfully create a boosted object. 

## Background
Informally, two operations are commutative if the application order of these operations on the same state does not affect the final outcome. For example, in a set, two operations ***add(x)*** and ***add(y)*** commute if ***x =/= y***. 

In this situation, an ***abstract lock*** is associated with each invocation of the boosted object. Abstract locks prevent non-commutative operations from executing concurrently. 

For any method ***m***, it's inverse ***m'*** is sound if applying ***m'*** immediately after ***m*** undoes the effect of ***m***. In this way if method inverses are known, then the recovery can be performed at a granularity level of method calls. 

## Boosted Transactions

In a boosted transaction, every method call has an inverse. When a transaction executes, it logs the inverses of the operations that take effect. If there is no conflict and the transaction can commit, the log generated by the transaction is discarded. If the transaction has to abort, the log entries are visited in reverse and executed. 

## Correctness rules for a transactional boosting system

- **Commutativity Isolation -** "For any non-commutative method calls I<sub>1</sub>, R<sub>1</sub>  &isin; T<sub>1</sub> and I<sub>2</sub> , R<sub>2</sub> &isin; T<sub>2</sub> ; either T<sub>1</sub> commits or aborts before any additional method calls from T<sub?2</sub> are invoked, or vice-versa".
- **Compensating Actions -** "For any history *h* and transaction *T*, if <T, aborted> &isin; *h*, then it must be the case that *h*|*T* = <T, init> . I<sub>0</sub> . R<sub>0</sub> .....  I<sub>i</sub> . R<sub>i</sub> . <T, aborted>  I<sub>i</sub><sup>-1</sup> . R<sub>i</sub><sup>-1</sup> .....  I<sub>0</sub><sup>-1</sup> . R<sub>0</sub><sup>-1</sup> . <T, aborted> where *i* indexes the last successfully completed method call. "
- **Disposable method calls -** "For any history *h* and Transaction *T*, any method call <T, xm(v)> . <T, r> that occurs after <T, commit> or <T, abort> must be disposable." 

