---
title: 'Deploy raphtory locally'
collection: documentation
type: "Documentation"
permalink: /documentation/deploylocal
order: 4
tags:
  - quick-start
  - deployment
---

You've learned so far how to build a docker image of Raphtory and write the necessary bits to ingest and analyse your data -- Give yourself a pat on the back!

This already makes the deployment of Raphtory much easier. There are different ways to achieve that: simply running it as a single container, or using orchestrators such as docker swarm or kubernetes to scale up your application. For now, in this tutorial, you're going to learn how to run Raphtory in your local machine using [docker-compose](https://docs.docker.com/compose/install/) to deploy raphtory components as one container.

### Docker-compose
The first step is to define the `compose.yml` configuration file that describes the services that are to be deployed; In this case, Raphtory. All you need to define is the name of your image, the ports that should be opened and the file that holds your environment variables `.env`

```yml
version: '3.3'
networks:
  default:
    ipam:
      config:
        - subnet: 10.0.0.0/24

services:
    raphtory:
        image: <image name here>/raphtory:latest
        container_name: raphtory
        ports:
             - 8081:8081
        command: env-setter.sh local
        env_file: .env
```
We're not going to do it here, but know that you can add a volume to a service where data generated by Raphtory persists even when the container is stopped. (Read more about this [here](https://docs.docker.com/storage/volumes/))

### Setting up Environment Variables
The Raphtory service requires some environment variables be set before deployment.
`SPOUT` -- The path to the spout class that will ingest your raw data.  
`GRAPHBUILDER` -- The path to the router class that will update the graph with ingested data.  
`PARTITION_MIN`/`ROUTER_MIN` -- Number of partition managers and routers to deploy.

This is, in addition to other variables that have been defined by the user. For our example of LOTR dataset, the `.env` content would look like this;

```sh
COMPOSE_PROJECT_NAME=raphtory
JAVA_OPTS=-Xms1G
DOCKER=true
SPOUT=com.raphtory.examples.lotr.LOTRSpout
GRAPHBUILDER=com.raphtory.examples.lotr.LOTRGraphBuilder
PARTITION_MIN=1
ROUTER_MIN=1
LOTR_DIRECTORY=<path to your data>
LOTR_FILE_NAME=lotr.csv
```
All that's left to do now is to launch your application to start the graph ingestion.

```sh
docker-compose --file <path to compose.yml> up
```

### Analysis Managers REST API
Up to this point, you've setup the environment for Raphtory to start ingesting your data and build the temporal graph. Finally, you can submit your queries to Raphtory so that some analysis can start going. We rely on a REST API to submit these queries, so the question now is what algorithms to test and what type of analysis to perform.

There are different types of analysis that can be achieved through Raphtory that will be tackled in depth in other blogs. What we're going to do here is have a query to apply the _Six degrees of Gandalf_ analyser, that we've written previously, on the first $1000$ sentences of the books -- This is what we call a **View Analysis**.

When the Raphtory container returns that `Cluster ready for Analysis` message, you can submit this query:

```sh
curl -X POST 127.0.0.1:8081/ViewAnalysisRequest \
-H "Content-Type: application/json" \
--data-binary @- << EOF
{
	"jsonrpc":"2.0",
	"jobID":"job-lotr-6deg-gandalf",
	"analyserName":"com.raphtory.core.analysis.Algorithms.lotrExample",
	"timestamp":1000
}
EOF
```

This should return the following results:

```json
View Analysis Task job-lotr-6deg-gandalf received, running com.raphtory.core.analysis.Algorithms.lotrExample at time 1000
{"time":1000,"total":11,"direct":4,"viewTime":91}
View Analysis manager for job-lotr-6deg-gandalf at 1000 finished
```

---
Congrats! You've finished the quick-start tutorials. You're officially a Raphtorian!
